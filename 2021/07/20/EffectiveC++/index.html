<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Effective C++ | 若则</title>
  <meta name="keywords" content=" C++ ">
  <meta name="description" content="Effective C++ | 若则">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="喜欢计算机理论的大学生一名">
<meta property="og:type" content="website">
<meta property="og:title" content="分类">
<meta property="og:url" content="http://example.com/categories/index.html">
<meta property="og:site_name" content="若则">
<meta property="og:description" content="喜欢计算机理论的大学生一名">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-07-18T02:48:30.000Z">
<meta property="article:modified_time" content="2021-07-18T02:50:14.629Z">
<meta property="article:author" content="Rouze">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar2.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/sublime.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 5.4.1"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar2.jpg"/>
</a>
<div class="author">
    <span>Rouze</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/Rouze"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="facebook"
               href="https://www.facebook.com/faker.tops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-facebook"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            <a title="zhihu"
               href="https://www.zhihu.com/people/jaytp/activities"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-zhihu"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
            <a title="email"
               href="mailto:2128099421@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=2128099421&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(25)</small>
            
        </div>
    </li>
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="25">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>操作系统 操作系统真相还原</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>基于项目acwj的编译器学习</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>计网</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>设计模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>深度学习</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>深度学习 计算机视觉</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>数据库</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>算法刷题</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>网络协议</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>acm</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>C</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>C 汇编</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>C++</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>git</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>os lab</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>python 爬虫</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>python 源码</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>SICP笔记</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Unix命令</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>windows</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 "
           href="/2024/04/16/mit-6-828/"
           data-tag="os lab"
           data-author="" >
            <span class="post-title" title="mit-6.828">mit-6.828</span>
            <span class="post-date" title="2024-04-16 00:12:16">2024/04/16</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2024/04/08/python%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"
           data-tag="python 源码"
           data-author="" >
            <span class="post-title" title="python源码阅读">python源码阅读</span>
            <span class="post-date" title="2024-04-08 12:17:22">2024/04/08</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2024/02/27/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E5%85%A5%E9%97%A8/"
           data-tag="python 爬虫"
           data-author="" >
            <span class="post-title" title="python爬虫实战入门">python爬虫实战入门</span>
            <span class="post-date" title="2024-02-27 13:52:23">2024/02/27</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2024/02/21/TCPNote/"
           data-tag="网络协议"
           data-author="" >
            <span class="post-title" title="TCPNote">TCPNote</span>
            <span class="post-date" title="2024-02-21 16:38:07">2024/02/21</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2024/02/20/Guide-to-Uinix/"
           data-tag="Unix命令"
           data-author="" >
            <span class="post-title" title="Guide_to_Uinix">Guide_to_Uinix</span>
            <span class="post-date" title="2024-02-20 21:49:43">2024/02/20</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2024/02/20/HttpNote/"
           data-tag="网络协议"
           data-author="" >
            <span class="post-title" title="HttpNote">HttpNote</span>
            <span class="post-date" title="2024-02-20 20:43:49">2024/02/20</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2024/01/29/%E6%95%B0%E6%8D%AE%E5%BA%93/"
           data-tag="数据库"
           data-author="" >
            <span class="post-title" title="数据库学习笔记">数据库学习笔记</span>
            <span class="post-date" title="2024-01-29 11:30:55">2024/01/29</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2024/01/19/%E5%88%B7%E9%A2%98/"
           data-tag="算法刷题"
           data-author="" >
            <span class="post-title" title="刷题">刷题</span>
            <span class="post-date" title="2024-01-19 11:47:35">2024/01/19</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2024/01/12/C%E8%AF%AD%E8%A8%80%E6%8B%BE%E9%81%97/"
           data-tag="C"
           data-author="" >
            <span class="post-title" title="C语言拾遗">C语言拾遗</span>
            <span class="post-date" title="2024-01-12 09:26:07">2024/01/12</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2024/01/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E7%A1%80/"
           data-tag="深度学习"
           data-author="" >
            <span class="post-title" title="深度学习-基础">深度学习-基础</span>
            <span class="post-date" title="2024-01-08 09:57:53">2024/01/08</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2024/01/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E8%A7%86%E8%A7%89/"
           data-tag="深度学习 计算机视觉"
           data-author="" >
            <span class="post-title" title="深度学习-视觉">深度学习-视觉</span>
            <span class="post-date" title="2024-01-08 09:07:24">2024/01/08</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/07/01/%E6%95%B0%E6%8D%AE%E4%B8%8E%E5%87%BD%E6%95%B0/"
           data-tag="SICP笔记"
           data-author="" >
            <span class="post-title" title="数据与函数">数据与函数</span>
            <span class="post-date" title="2023-07-01 19:21:32">2023/07/01</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2022/10/15/%E8%AE%A1%E7%BD%91-%E9%93%BE%E8%B7%AF%E5%B1%82/"
           data-tag="计网"
           data-author="" >
            <span class="post-title" title="计网-链路层">计网-链路层</span>
            <span class="post-date" title="2022-10-15 19:43:14">2022/10/15</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2022/10/07/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"
           data-tag="操作系统 操作系统真相还原"
           data-author="" >
            <span class="post-title" title="内存管理">内存管理</span>
            <span class="post-date" title="2022-10-07 19:12:16">2022/10/07</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2022/10/02/%E4%B8%AD%E6%96%AD/"
           data-tag="操作系统 操作系统真相还原"
           data-author="" >
            <span class="post-title" title="中断">中断</span>
            <span class="post-date" title="2022-10-02 20:31:38">2022/10/02</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2022/10/01/Pratt-Parse%E7%9A%84%E7%90%86%E8%A7%A3/"
           data-tag="基于项目acwj的编译器学习"
           data-author="" >
            <span class="post-title" title="Pratt-Parse的理解">Pratt-Parse的理解</span>
            <span class="post-date" title="2022-10-01 23:30:49">2022/10/01</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2022/09/25/C%E8%AF%AD%E8%A8%80%E9%87%8C%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90/"
           data-tag="C 汇编"
           data-author="" >
            <span class="post-title" title="C语言里函数返回结构体的汇编分析">C语言里函数返回结构体的汇编分析</span>
            <span class="post-date" title="2022-09-25 08:54:51">2022/09/25</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2022/07/04/git%E5%AD%A6%E4%B9%A0/"
           data-tag="git"
           data-author="" >
            <span class="post-title" title="git学习">git学习</span>
            <span class="post-date" title="2022-07-04 08:40:38">2022/07/04</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2022/04/24/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="大话设计模式">大话设计模式</span>
            <span class="post-date" title="2022-04-24 18:47:07">2022/04/24</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2022/04/04/Windows%E7%BC%96%E7%A8%8B/"
           data-tag="windows"
           data-author="" >
            <span class="post-title" title="Windows编程">Windows编程</span>
            <span class="post-date" title="2022-04-04 20:29:52">2022/04/04</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2021/07/20/EffectiveC++/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="Effective C++">Effective C++</span>
            <span class="post-date" title="2021-07-20 15:26:15">2021/07/20</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2021/07/20/ExceptionalC++/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="Exceptional C++">Exceptional C++</span>
            <span class="post-date" title="2021-07-20 15:26:15">2021/07/20</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2021/07/20/Kuangbin-%E5%B9%B6%E6%9F%A5%E9%9B%86/"
           data-tag="acm"
           data-author="" >
            <span class="post-title" title="Kuangbin-并查集">Kuangbin-并查集</span>
            <span class="post-date" title="2021-07-20 15:26:15">2021/07/20</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2021/07/20/MoreEffectiveC++/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="More Effective C++">More Effective C++</span>
            <span class="post-date" title="2021-07-20 15:26:15">2021/07/20</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2021/07/20/Kuangbin-%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2/"
           data-tag="acm"
           data-author="" >
            <span class="post-title" title="Kuangbin-简单搜索">Kuangbin-简单搜索</span>
            <span class="post-date" title="2021-07-20 00:03:54">2021/07/20</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="p-EffectiveC++" class="article article-type-p" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Effective C++</h1>
    
    <div class="article-meta">
        
        
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color4">C++</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2024-02-25 19:56:54'>2021-07-20 15:26</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AF%E8%AF%AD"><span class="toc-text">术语</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE1%EF%BC%9A%E5%B0%BD%E9%87%8F%E4%BB%A5const-enum-inline%E6%9B%BF%E6%8D%A2-define"><span class="toc-text">条款1：尽量以const,enum,inline替换#define</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE2-%E5%B0%BD%E5%8F%AF%E8%83%BD%E7%94%A8const"><span class="toc-text">条款2: 尽可能用const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE3%EF%BC%9A%E7%A1%AE%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">条款3：确定初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE4%EF%BC%9A%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%83%B3%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%EF%BC%8C%E5%BA%94%E8%AF%A5%E6%8A%8A%E7%9B%B8%E5%BA%94%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%BAprivate%E5%B9%B6%E4%B8%94%E4%B8%8D%E4%BA%88%E5%AE%9E%E7%8E%B0"><span class="toc-text">条款4：如果不想编译器自动生成函数，应该把相应的成员函数声明为private并且不予实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE5%EF%BC%9A%E5%B8%A6%E5%A4%9A%E6%80%81%E6%80%A7%E8%B4%A8%E7%9A%84%E5%9F%BA%E7%B1%BB%E5%BA%94%E8%AF%A5%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AAvirtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E7%B1%BB%E8%AE%BE%E8%AE%A1%E5%87%BA%E6%9D%A5%E4%B8%8D%E6%98%AF%E4%B8%BA%E4%BA%86%E4%BD%9C%E4%B8%BAbase-class-%E9%82%A3%E5%B0%B1%E4%B8%8D%E5%BA%94%E8%AF%A5%E5%A3%B0%E6%98%8Evirtual%E6%9E%90%E6%9E%84%EF%BC%8C%E5%9B%A0%E4%B8%BAvirtual%E7%9A%84%E5%A3%B0%E6%98%8E%E4%BC%9A%E5%A2%9E%E5%A4%A7%E7%B1%BB%E7%9A%84%E7%A9%BA%E9%97%B4"><span class="toc-text">条款5：带多态性质的基类应该声明一个virtual析构函数，如果一个类设计出来不是为了作为base class,那就不应该声明virtual析构，因为virtual的声明会增大类的空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE6%EF%BC%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%8D%E8%A6%81%E5%90%90%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-text">条款6：析构函数不要吐出异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE10-operator-x3D-%E5%BA%94%E8%AF%A5%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AAreference-to-this"><span class="toc-text">条款10: operator&#x3D;应该返回一个reference to *this</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE11%EF%BC%9Aoperator-x3D-%E5%BA%94%E8%AF%A5%E5%A4%84%E7%90%86%E5%A5%BD%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC%E5%AE%89%E5%85%A8%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8"><span class="toc-text">条款11：operator&#x3D;应该处理好自我赋值安全与异常安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE12%EF%BC%9Acopying%E6%93%8D%E4%BD%9C%E8%A6%81%E8%AE%B0%E5%BE%97copy%E5%A4%84%E7%90%86%E5%A5%BD%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%BB%A5%E5%8F%8A%E2%80%9Cbase-class%E2%80%9D%E6%88%90%E5%88%86"><span class="toc-text">条款12：copying操作要记得copy处理好每一个成员变量以及“base class”成分</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#x3D-x3D-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-x3D-x3D"><span class="toc-text">&#x3D;&#x3D;资源管理&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE13%EF%BC%9A%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90"><span class="toc-text">条款13：用对象管理资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE14%EF%BC%9A%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83%E5%A4%84%E7%90%86copying%E8%A1%8C%E4%B8%BA"><span class="toc-text">条款14：在资源管理类中小心处理copying行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE15%EF%BC%9A%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E8%A6%81%E6%8F%90%E4%BE%9B%E5%A5%BD%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">条款15：资源管理类要提供好对原始资源的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE17%EF%BC%9A%E7%94%A8%E7%8B%AC%E7%AB%8B%E7%9A%84%E8%AF%AD%E5%8F%A5%E5%B0%86new%E5%AF%B9%E8%B1%A1%E7%BD%AE%E5%85%A5%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">条款17：用独立的语句将new对象置入智能指针</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#x3D-x3D-%E5%A3%B0%E6%98%8E%E4%B8%8E%E8%AE%BE%E8%AE%A1-x3D-x3D"><span class="toc-text">&#x3D;&#x3D;声明与设计&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE25%EF%BC%9A%E5%BD%93%E9%9C%80%E8%A6%81%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AAswap%E5%87%BD%E6%95%B0%E6%97%B6%E5%85%88%E7%A1%AE%E5%AE%9A%E5%85%B6%E4%B8%8D%E8%A6%81%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%EF%BC%8C%E5%90%8C%E6%97%B6%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AAnon-member%E7%9A%84%E7%89%88%E6%9C%AC%E8%B0%83%E7%94%A8%E8%AF%A5swap%E5%87%BD%E6%95%B0%EF%BC%8C%E6%AD%A4non-member%E5%8F%AF%E4%BB%A5%E6%94%BE%E5%9C%A8class%E7%9A%84%E5%90%8C%E4%B8%80%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%86%85%EF%BC%8C%E6%9C%80%E5%90%8E%E5%8F%AF%E4%BB%A5%E5%AF%B9std-swap%E8%BF%9B%E8%A1%8C%E5%85%A8%E7%89%B9%E5%8C%96%E4%BD%86%E4%B8%8D%E8%83%BD%E5%BE%80std%E5%86%85%E5%8A%A0%E5%85%A5%E5%85%A8%E6%96%B0%E7%9A%84%E4%B8%9C%E8%A5%BF"><span class="toc-text">条款25：当需要自己写一个swap函数时先确定其不要抛出异常，同时提供一个non-member的版本调用该swap函数，此non-member可以放在class的同一命名空间内，最后可以对std::swap进行全特化但不能往std内加入全新的东西</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#x3D-x3D-%E5%AE%9E%E7%8E%B0-x3D-x3D"><span class="toc-text">&#x3D;&#x3D;实现&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE26%EF%BC%9A%E5%B0%BD%E9%87%8F%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E5%87%BA%E7%8E%B0%E6%97%B6%E9%97%B4%EF%BC%8C%E4%BB%A5%E5%A2%9E%E5%8A%A0%E7%A8%8B%E5%BA%8F%E6%B8%85%E6%99%B0%E5%BA%A6%E5%92%8C%E6%94%B9%E5%96%84%E6%95%88%E7%8E%87"><span class="toc-text">条款26：尽量延后变量定义的出现时间，以增加程序清晰度和改善效率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE27%EF%BC%9A%E5%B0%BD%E9%87%8F%E5%B0%91%E5%81%9A%E8%BD%AC%E5%9E%8B%E5%8A%A8%E4%BD%9C"><span class="toc-text">条款27：尽量少做转型动作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE29-%E5%B0%BD%E9%87%8F%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E7%9A%84handles"><span class="toc-text">条款29: 尽量避免返回对象的handles</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE30%EF%BC%9Ainling%E7%9A%84%E9%87%8C%E9%87%8C%E5%A4%96%E5%A4%96"><span class="toc-text">条款30：inling的里里外外</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE31%EF%BC%9A%E5%B0%86%E6%96%87%E4%BB%B6%E9%97%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E5%B0%86%E8%87%B3%E6%9C%80%E4%BD%8E"><span class="toc-text">条款31：将文件间的编译依存将至最低</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE33%EF%BC%9A%E9%81%BF%E5%85%8D%E9%81%AE%E6%8E%A9%E7%BB%A7%E6%89%BF%E6%9D%A5%E7%9A%84%E5%90%8D%E5%AD%97"><span class="toc-text">条款33：避免遮掩继承来的名字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE37%EF%BC%9A%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E6%9D%A5%E7%9A%84non-virtual%E5%87%BD%E6%95%B0"><span class="toc-text">条款37：绝不重新定义继承来的non-virtual函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE38%EF%BC%9A%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%80%BC"><span class="toc-text">条款38：绝不重新定义继承而来的缺省参数值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE42-%E4%BA%86%E8%A7%A3typename%E7%9A%84%E5%8F%8C%E9%87%8D%E6%84%8F%E4%B9%89"><span class="toc-text">条款42:了解typename的双重意义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE49-%E4%BA%86%E8%A7%A3new-handler%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-text">条款49:了解new-handler的行为</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ol>
<li><p>defalut构造函数一般定义成explicit，防止编译器做一些预期外的转换</p>
<pre><code class="cpp">class B&#123;
    public:
        explicit B(int x=0,bool b=true);
&#125;;
void doSomething(class B);
B b1;
doSomething(b1);
B b2(28);
doSomething(28);//此处如果没有将构造函数声明为explicit,那编译器将用这个28去构造一个B传给doSomething,这就是预期之外的，由于声明了explicit此处就会报错。
</code></pre>
</li>
</ol>
<h4 id="条款1：尽量以const-enum-inline替换-define"><a href="#条款1：尽量以const-enum-inline替换-define" class="headerlink" title="条款1：尽量以const,enum,inline替换#define"></a>条款1：尽量以const,enum,inline替换#define</h4><blockquote>
<p>因为#define不被视为语言的一部分，也许在某些情况下编译器从来不会见到#define 后面的东西</p>
</blockquote>
<ol>
<li>尽量用常量去替换#defines.</li>
</ol>
<ul>
<li><p>一个例子是常量指针，如#define name “rouze”可以替换为 const char* const name &#x3D; “rouze”;或者用STL的const string name(“rouze”);</p>
</li>
<li><p>再者就是<strong>class的专属常量</strong>，其实#define是无法定义一个class的专属常量的，因为#define出来的东西对该条语句后面的所有语句有效，无法提供私有性。要想使它专属那就要放在private里面，要想只留一份就要static，如果是常量还要加const,类似</p>
<pre><code class="cpp">class obj&#123;
    private:
    static const int num=5;
&#125;;
</code></pre>
<p>上面这种份代码是一份声明，放在头文件当中，但即使是static成员在旧编译器也是不允许的，因此需要在实现文件里赋值const obj::num&#x3D;5;</p>
</li>
<li><p>“enum hack”–enum类型在定义出来后可以当作一个整型常量</p>
<pre><code class="cpp">class Player&#123;
    private:
    static const int NumTurns=10;
    int score[NumTurns];
&#125;;
//如果编译器不支持类中初始化上述定义会报错，但又实在需要NumTurns为一个确定的大小才能通过编译使用enum如下
class Player&#123;
    private:
    enum &#123;NumTurns=10&#125;;
    int score[NumTurns];
&#125;;
//上述定义就能通过编译
</code></pre>
<p>综上所述，<strong>尽量用const或者enum替换掉#defines</strong>，<strong>尽量用inline替换形似函数的宏</strong></p>
</li>
</ul>
<h4 id="条款2-尽可能用const"><a href="#条款2-尽可能用const" class="headerlink" title="条款2: 尽可能用const"></a>条款2: 尽可能用const</h4><blockquote>
<p>const的作用是允许指定一个“约束”，编译器会强制实施这个约束，const 在不同场景有着不同的作用，主要讲一下在member funciton 的</p>
</blockquote>
<pre><code class="cpp">class TextBlock&#123;
    public:
    const char&amp; operator[]const&#123;&#125;
    char&amp; operator[]&#123;&#125;
  
&#125;;
//注意上面函数中两个const 各自的意义
</code></pre>
<p><strong>编译器强制实施的是bitwise-constness</strong>，但在编程过程当中可以通过与const对应的mutable实现<strong>conceptual constness</strong></p>
<p><strong>当const和non-const版本的实现等价只有返回不同时应在non-const版本里调用const版本来避免代码重复</strong></p>
<h4 id="条款3：确定初始化"><a href="#条款3：确定初始化" class="headerlink" title="条款3：确定初始化"></a>条款3：确定初始化</h4><h4 id="条款4：如果不想编译器自动生成函数，应该把相应的成员函数声明为private并且不予实现"><a href="#条款4：如果不想编译器自动生成函数，应该把相应的成员函数声明为private并且不予实现" class="headerlink" title="条款4：如果不想编译器自动生成函数，应该把相应的成员函数声明为private并且不予实现"></a>条款4：如果不想编译器自动生成函数，应该把相应的成员函数声明为private并且不予实现</h4><ul>
<li><p>默认生成的copy assignment运算会自动调用所有成员对象的copy assignment运算完成复制</p>
</li>
<li><p>默认的析构函数会自动调用所有的non-static成员的析构函数进行析构</p>
<pre><code class="cpp">//版本一
class BankAcount&#123;
  private:
    int num;
    BankAcount&amp; operator=(const BankAcount&amp;);
    BankAcount(BankAcount&amp;);
&#125;;
//当复制操作被外部调用时编译会发生错误表示不可调用，当内部函数或者friend函数调用复制操作时会发生链接错误，因为没有函数的实现

//版本二通过继承一个不可复制的类来阻止复制操作
class Uncopyable&#123;
    public:
  Uncopyable()&#123;&#125;
  ~Uncopyable()&#123;&#125;
    private:
  Uncopyable&amp; operator=(const Uncopyable&amp;);
  Uncopyable(const Uncopyable);
&#125;;
class BankAcount:private Uncopyable&#123;
    ...
&#125;;
//相比版本一好处就是错误会被放到编译时期来，因为当BankAcount对象在进行复制行为时势必会调用Uncopyable的复制函数(除非你写的BankAcount是错误的在copy操作没有考虑基类成员，这有悖于条款11)
</code></pre>
</li>
</ul>
<h4 id="条款5：带多态性质的基类应该声明一个virtual析构函数，如果一个类设计出来不是为了作为base-class-那就不应该声明virtual析构，因为virtual的声明会增大类的空间"><a href="#条款5：带多态性质的基类应该声明一个virtual析构函数，如果一个类设计出来不是为了作为base-class-那就不应该声明virtual析构，因为virtual的声明会增大类的空间" class="headerlink" title="条款5：带多态性质的基类应该声明一个virtual析构函数，如果一个类设计出来不是为了作为base class,那就不应该声明virtual析构，因为virtual的声明会增大类的空间"></a>条款5：带多态性质的基类应该声明一个virtual析构函数，如果一个类设计出来不是为了作为base class,那就不应该声明virtual析构，因为virtual的声明会增大类的空间</h4><h4 id="条款6：析构函数不要吐出异常"><a href="#条款6：析构函数不要吐出异常" class="headerlink" title="条款6：析构函数不要吐出异常"></a>条款6：析构函数不要吐出异常</h4><p>如果析构函数吐出异常可能导致其后需要的析构无法进行</p>
<h4 id="条款10-operator-x3D-应该返回一个reference-to-this"><a href="#条款10-operator-x3D-应该返回一个reference-to-this" class="headerlink" title="条款10: operator&#x3D;应该返回一个reference to *this"></a>条款10: operator&#x3D;应该返回一个reference to *this</h4><h4 id="条款11：operator-x3D-应该处理好自我赋值安全与异常安全"><a href="#条款11：operator-x3D-应该处理好自我赋值安全与异常安全" class="headerlink" title="条款11：operator&#x3D;应该处理好自我赋值安全与异常安全"></a>条款11：operator&#x3D;应该处理好自我赋值安全与异常安全</h4><pre><code class="cpp">//通过精心安排的语句能避免一些自我赋值与异常处理
class Widget&#123;
    private:
    Bitmap *pb;
    public:
    ...
&#125;;
//错误版本一,如果pb等于rhs.pb即自我赋值的情况，delete pb之后rhs.pb将指向一块删除的地方，这样就会产生错误
Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123;
    delete pb;
    pb = new Bitmap(*rhs.pb);
    return *this;
&#125;
//版本二，解决了自我赋值，但在new 操作错误时pb将指向错误的地方
Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123;
    if(pb == rhs.pb)
        return *this;
    delete pb;
    pb = new Bitmap(*rhs.pb);
    return *this;
&#125;
//正确版本
Widget&amp; Widget::operator=(const Widget&amp; rhs)
&#123;
    //主要思想就是在复制好原本的资源之前不要delete掉那个指针
    Bitmap * pOrig=pb;
    pb = new Bitmap(*rhs.pb);
    delete pOrig;
    return *this
&#125;
</code></pre>
<h4 id="条款12：copying操作要记得copy处理好每一个成员变量以及“base-class”成分"><a href="#条款12：copying操作要记得copy处理好每一个成员变量以及“base-class”成分" class="headerlink" title="条款12：copying操作要记得copy处理好每一个成员变量以及“base class”成分"></a>条款12：copying操作要记得copy处理好每一个成员变量以及“base class”成分</h4><pre><code class="cpp">class Base&#123;
    private:
    int base;
    public:
    Base&amp; operator=(const Base&amp;rhs);
&#125;;
class Derived:public Base&#123;
    private:
    int derive;
    public:
    Derived&amp; operator=(const Derived&amp;rhs)&#123;
        derive = rhs.derive;
        return *this;
    &#125;
&#125;;
//Base部分的成员变量没有被copy
//正确版本
Derived&amp; Derived::operator=(const Derived&amp;rhs)&#123;
    derive = rhs.derive;
    Base::operator=(rhs);
    return *this;
&#125;
</code></pre>
<pre><code>**另外copy构造函数与copy assignment函数可能代码很大部分一样，但不要在一个copying 函数里面去调用另一个copying函数来实现自己，好的方法是把共同的代码单独写成一个函数供两者调用**
</code></pre>
<h1 id="x3D-x3D-资源管理-x3D-x3D"><a href="#x3D-x3D-资源管理-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;资源管理&#x3D;&#x3D;"></a>&#x3D;&#x3D;资源管理&#x3D;&#x3D;</h1><h4 id="条款13：用对象管理资源"><a href="#条款13：用对象管理资源" class="headerlink" title="条款13：用对象管理资源"></a>条款13：用对象管理资源</h4><ul>
<li>为了防止资源泄露，最好使用RALL对象来管理资源，这样可以通过C++对象的析构函数去自动释放资源</li>
<li>常见的RALL class有auto_ptr(其复制行为有点诡异，当赋值发生时被赋值的对象拥有资源的管理权，而另一个将被置为null),tr1::shared_ptr通过持续的追踪有多少对象指向某笔资源来确定是否释放该资源，因此赋值正常</li>
<li>这两个对象在释放资源时都是进行的delete行为而非delete[]，因此不要将数组指针交给这两个对象管理</li>
</ul>
<h4 id="条款14：在资源管理类中小心处理copying行为"><a href="#条款14：在资源管理类中小心处理copying行为" class="headerlink" title="条款14：在资源管理类中小心处理copying行为"></a>条款14：在资源管理类中小心处理copying行为</h4><ul>
<li><p>如果想要禁止copying行为可以参考条款6将copying函数声明为私有并且不予实现</p>
</li>
<li><p>如果想表现出RCSP的特性可以将底层的资源用tr1::shared_ptr控制，并且其可以指定指定删除行为，缺省时表现为释放资源*std::tr1::shared_ptr<code>&lt;typename&gt;</code> obj(typename,function)*，其中的function就是自己定义的函数</p>
<pre><code class="cpp">class Lock&#123;
    public:
    explicit Lock(Mutex* pm):
    mutexPtr(pm,unlock)&#123;
        lock(mutexPtr.get());
    &#125;
    private:
    std::tr1::shared_ptr&lt;Mutex&gt; mutexPtr;
&#125;;
//将普通的Mutex换成shared_ptr管理，可以表现出RCSP的特性，注意没有写析构函数是因为默认的析构函数会调用non-static的析构函数，而shared_ptr的析构会去执行deleter的行为即指定的unl
</code></pre>
</li>
</ul>
<h4 id="条款15：资源管理类要提供好对原始资源的访问"><a href="#条款15：资源管理类要提供好对原始资源的访问" class="headerlink" title="条款15：资源管理类要提供好对原始资源的访问"></a>条款15：资源管理类要提供好对原始资源的访问</h4><blockquote>
<p>资源管理类并不是为了封装而存在，它只是为了确保“资源释放”这个特殊行为会发生而存在，因此它做的是隐藏客户不需要看的部分，但要备足客户需要的所有东</p>
</blockquote>
<pre><code class="cpp">//当把一个指针交给一个资源管理对象如auto_ptr时，很多函数接口需要的还是原始的指针类型，如果直接将auto_ptr传给函数会发生编译错误，因此资源管理对象就需要提供相应的类型转换

//方法一显示转换
class Manage&#123;
    private:
    Something s;
    public:
    explicit Manage(Something x):
    s(x)
    &#123;
        ...
    &#125;
    ~Manage()&#123;
        ...
    &#125;
    Something get()const&#123;
        return s;
    &#125;
&#125;;//通过Manage对象调用get()返回内部资源
//方法二隐式转换
class Manage&#123;
    public:
    ...
    operator Something()const&#123;
        return s;
    &#125;
&#125;;//在需要类型转换时编译器会自动调用转换函数，这样对客户来说比较轻松，但这样可能就会隐藏危险
</code></pre>
<h4 id="条款17：用独立的语句将new对象置入智能指针"><a href="#条款17：用独立的语句将new对象置入智能指针" class="headerlink" title="条款17：用独立的语句将new对象置入智能指针"></a>条款17：用独立的语句将new对象置入智能指针</h4><p>考虑下面这样的代码</p>
<pre><code class="cpp">int priority();
void process(std::auto_ptr&lt;Widget&gt; pw,pty);

//以下方式调用process函数
process(new Widget,priority());
//首先会报错，因为智能指针的初始化是显式的
process(std::auto_ptr&lt;Widget&gt;(new Widget),priority());

//乍看没问题，但可能造成资源泄露，在调用process之前编译器知道要先做下面几件事
/*1.执行new Widget
2.执行 priority()
3. 执行auto_ptr的构造函数*/
//但只能确定new Widget在auto_ptr之前发生，priority()的执行是无法确定的，如果恰好是按上述顺序，那在priority()出错时new出来的对象将无法放到智能指针里面去
//正确形式
std::auto_ptr&lt;Widget&gt; pw(new Widget);
process(pw,priority());
</code></pre>
<h1 id="x3D-x3D-声明与设计-x3D-x3D"><a href="#x3D-x3D-声明与设计-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;声明与设计&#x3D;&#x3D;"></a>&#x3D;&#x3D;声明与设计&#x3D;&#x3D;</h1><h4 id="条款25：当需要自己写一个swap函数时先确定其不要抛出异常，同时提供一个non-member的版本调用该swap函数，此non-member可以放在class的同一命名空间内，最后可以对std-swap进行全特化但不能往std内加入全新的东西"><a href="#条款25：当需要自己写一个swap函数时先确定其不要抛出异常，同时提供一个non-member的版本调用该swap函数，此non-member可以放在class的同一命名空间内，最后可以对std-swap进行全特化但不能往std内加入全新的东西" class="headerlink" title="条款25：当需要自己写一个swap函数时先确定其不要抛出异常，同时提供一个non-member的版本调用该swap函数，此non-member可以放在class的同一命名空间内，最后可以对std::swap进行全特化但不能往std内加入全新的东西"></a>条款25：当需要自己写一个swap函数时先确定其不要抛出异常，同时提供一个non-member的版本调用该swap函数，此non-member可以放在class的同一命名空间内，最后可以对std::swap进行全特化但不能往std内加入全新的东西</h4><pre><code class="cpp">//假设有一个类，它只管理一个对象指针，定义如下
class WidgetImpl&#123;
    public:
    ...
    private:
    std::vector&lt;int&gt; v;
    ...
&#125;;
class Widget&#123;
    public:
    ...
    Widget&amp;operator=(const Widget&amp;rhs)&#123;
        ...
        *pImpl = *(rhs.pImpl);//这里是通过WidgetImpl对象的operator=完成一个深拷贝而不是直接pImpl=rhs.pImpl
        ...
    &#125;
    private:
    WidgetImpl* pImpl;
&#125;;
//如果直接交换两个,std::swap只是最简单的交换
namespace std&#123;
    template&lt;typename T&gt;
    void swap(T&amp;a,T&amp;b)&#123;
        T temp(a);
        a = b;
        b = tmp;
    &#125;
&#125;
//如果调用std::swap交换那swap会调用最底层的WidgetImpl的operator=,会有ector拷贝的操作，而实际中我们只需要交换两个Widget管理的指针即可，所以有了特化的std::swap
namespace std&#123;
    template&lt;&gt;
    void swap&lt;Widget&gt;(Wiget&amp;lhs,Widget&amp;rhs)&#123;
        //由于成员是private，所以应该定义一个swap成员函数来对指针进行操作，而这里只是进行一个调用
        lhs.swap(rhs);
    &#125;
&#125;
//这样在使用std::swap时编译器会自动找到该版本进行相应的特化操作
/*后面还有如果类是一个模板类需要注意的地方，以后再写吧-_-*/
</code></pre>
<h1 id="x3D-x3D-实现-x3D-x3D"><a href="#x3D-x3D-实现-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;实现&#x3D;&#x3D;"></a>&#x3D;&#x3D;实现&#x3D;&#x3D;</h1><h4 id="条款26：尽量延后变量定义的出现时间，以增加程序清晰度和改善效率"><a href="#条款26：尽量延后变量定义的出现时间，以增加程序清晰度和改善效率" class="headerlink" title="条款26：尽量延后变量定义的出现时间，以增加程序清晰度和改善效率"></a>条款26：尽量延后变量定义的出现时间，以增加程序清晰度和改善效率</h4><p>最好就是在得到能够初始化这个变量的数据出现时定义该变量，一方面可读性较高另一方面也能减少一些初始化引起的问题</p>
<h4 id="条款27：尽量少做转型动作"><a href="#条款27：尽量少做转型动作" class="headerlink" title="条款27：尽量少做转型动作"></a>条款27：尽量少做转型动作</h4><blockquote>
<p>C++提供的四种新转型方式</p>
<p>const_cast<code>&lt;T&gt;</code>(expression)–&gt;用来移除常量性，也是唯一有这个能力的转型操作符</p>
<p>dynamic_cast<code>&lt;T&gt;</code>(expression)</p>
<p>reinterpret_cast<code>&lt;T&gt;</code>(expression)</p>
<p>static_cast<code>&lt;T&gt;</code>(expression)</p>
</blockquote>
<p><strong>类型转换并不是简单的一个类似声明一样的东西，任何一个类型转换往往令编译器编译出运行期执行的代码</strong></p>
<pre><code class="cpp">class Base1&#123;...&#125;;
class Base2&#123;...&#125;;
class Derived:public Base1,public Base2&#123;...&#125;;

Derived d;
Base1* p1 = &amp;d;
Base2* p2 = &amp;d;
Derived* p3 = &amp;d;
//将d的地址转型成Base1的指针，只有编译器知道在继承过程当中属于Base1的那个部分在d的哪里也就是有一个偏移量需要调整，因此p1,p2,p3很可能不同，这就是转型d
</code></pre>
<h4 id="条款29-尽量避免返回对象的handles"><a href="#条款29-尽量避免返回对象的handles" class="headerlink" title="条款29: 尽量避免返回对象的handles"></a>条款29: 尽量避免返回对象的handles</h4><blockquote>
<p>当对象成员的handles(reference,pointer,迭代器等)被成员函数返回，这会破坏封装性，即使返回的是const reference,当对象内部的成员被销毁时，这个留在外面的handle就会成为一个空掉着的handle。但并不代表这是一定不行的，像string的operator[]就需要返回内部字符的reference，以及各种迭代器都需要这样。</p>
</blockquote>
<h4 id="条款30：inling的里里外外"><a href="#条款30：inling的里里外外" class="headerlink" title="条款30：inling的里里外外"></a>条款30：inling的里里外外</h4><blockquote>
<p>inline函数除了能免除函数调用的成本，简单的inlined函数还有可能被编译器优化成更短的目标码，这样有较高的指令高速缓存装置击中率。</p>
<p>但是，如果对一个程序库来说，一个inline 函数f,如果设计者改变了f，那么客户中所有使用了f函数的地方都要重新编译，而如果没有inline只需要重新连接一下，另外不是说某些看起来很简单的代码就一定可以inline，例子如下</p>
</blockquote>
<pre><code class="cpp">class Base&#123;
    public:
    ...
    private:
    std::string b1,b2; 
&#125;;
class Derived :public Base&#123;
    public:
    Derived()&#123;&#125;
    private:
    std::string d1,d2;
&#125;;
//看上去默认构造函数是一个绝佳的inline对象，但在实际的编译之后为了保证程序的正常运行，编译器会添加一些代码，其可能的样子如下
Derived()&#123;
    Base::Base();
    try&#123;d1.std::string::string();&#125;
    catch(...)&#123;
        Base::~Base();
        throw;
    &#125;
    try&#123;d2.std::string::string()&#125;
    catch(...)&#123;
        Base::~Base();
        throw;
    &#125;
    ...
&#125;
//Derive函数先构造好继承的成分，之后再尝试构造自己的成员，如果出现异常就释放已经构造的资源

//上述代码只是简单的描述了一下编译器可能的操作，实际可能更加精致复杂，如果说将所有的构造函数都inlined，那Derive函数将有四份string构造函数的代码（Base成分那里两个再加上自己的两个），如果情况再稍微复杂一些构造函数的代码就可能非常巨大，不再适合inline
</code></pre>
<h4 id="条款31：将文件间的编译依存将至最低"><a href="#条款31：将文件间的编译依存将至最低" class="headerlink" title="条款31：将文件间的编译依存将至最低"></a>条款31：将文件间的编译依存将至最低</h4><blockquote>
<p>C++并没有把“接口从实现中分离”这件事做得很好，Class的定义式不仅描述了接口，还有实现细节，如下面代码所示</p>
</blockquote>
<pre><code class="cpp">class Person&#123;
    //各种接口
    public:
    Person(const std::string&amp;,const Date&amp;,const Address&amp;);
    std::string name()const;
    std::string birthDate()const;
    std::string Address()const;
    private:
    //下面就是所说的实现细节
    std::string theName;
    Date theBirthDate;
    Address theAddress;
&#125;;
</code></pre>
<p>首先上面的代码是无法通过编译的，因为Date和Address是为定义的类型，所以前面常会有include&quot;date.h”这样的东西，其次Person的定义文件和每一个含入了Person class的文件就形成了一种编译依存关系，任何一个头文件的改变都将引起其它文件的的重新编译</p>
<p><strong>解决方案:</strong></p>
<ol>
<li>使用Pimpl技法，将Person分割成为两个classes,一个只提供接口，另一个负责实现接口,Person的定义将如下:</li>
</ol>
<pre><code class="cpp">#include&lt;string&gt;
#include&lt;memory&gt;//shared_ptr所在库
//实现接口的类
class PersonImpl;
//将Date与Address作为前置声明而非直接#include相应头文件这样可以减少由于#include引进的依存

//因为现在的Person只提供接口，需要知道的只是Date与Address这两种类型而非细节，即在Person的定义中Date与Address要么是函数返回类型用到要么是函数参数类型用到,这两种情况下编译都是可以通过的

//但这里无法去实现Person的成员函数
class Date;
class Address;
class Person&#123;
    //各种接口
    public:
    Person(const std::string&amp;,const Date&amp;,const Address&amp;);
    std::string name()const;
    std::string birthDate()const;
    std::string Address()const;
    private:
    //下面是一个指向实物的指针而非具体细节
    std::tr1::shared_ptr&lt;PersonImpl&gt; PImpl;
&#125;;
</code></pre>
<p>现在来看，Person的使用者就完全不需要知道Person的实现细节了，那些关于Person实现的任何修改也不再需要Person的使用者重新编译了，因为从头到尾Person的使用者只是在通过一个指针来进行各种操作，并不能写出依赖于Person细节实现的代码，也就没有了这层编译依赖</p>
<h4 id="条款33：避免遮掩继承来的名字"><a href="#条款33：避免遮掩继承来的名字" class="headerlink" title="条款33：避免遮掩继承来的名字"></a>条款33：避免遮掩继承来的名字</h4><blockquote>
<p>“名称遮掩规则”在类的继承中仍然起作用，想要改变可以使用using</p>
</blockquote>
<pre><code class="cpp">class Base&#123;
    private:
    int x;
    public:
    virtual void mf1()=0;
    virtual void mf1(int);
    void mf3();
    void mf3(int);
&#125;;
class Derived :public Base&#123;
    public:
    virtual void mf1();
    void mf3();
    void mf4();
&#125;;

Derived d;
d.mf1();//right
d.mf1(1);//wrong
d.mf3();//right
d.mf3(1);//wrong
//继承中的名字会覆盖掉所有继承而来的同名函数就像内部的同名变量会掩盖外部的同名变量,本质的原因是*作用域的嵌套*
class Derived :public Base&#123;
    public:
    using Base::mf1;
    using Base::mf3;
    virtual void mf1();
    void mf3();
    void mf4();
&#125;;
//用using解决该问题
</code></pre>
<h4 id="条款37：绝不重新定义继承来的non-virtual函数"><a href="#条款37：绝不重新定义继承来的non-virtual函数" class="headerlink" title="条款37：绝不重新定义继承来的non-virtual函数"></a>条款37：绝不重新定义继承来的non-virtual函数</h4><blockquote>
<p>继承而来的non-virtual函数指定了接口继承以及一份强制性实现，因此non-virtual函数不应该被重写，如果想要表现特异性凌驾于其不变性之上，那该函数就应该声明为virtual</p>
</blockquote>
<h4 id="条款38：绝不重新定义继承而来的缺省参数值"><a href="#条款38：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款38：绝不重新定义继承而来的缺省参数值"></a>条款38：绝不重新定义继承而来的缺省参数值</h4><blockquote>
<p>首先能重新定义的是virtual函数，因此本条款是针对于virtual函数的</p>
</blockquote>
<pre><code class="cpp">class Shape&#123;
    public:
    enum ShapeColor&#123;Red,Black,Green&#125;;
    virtual void draw(ShapeColor color=Red);
&#125;;
class Circle:public Shape&#123;
    public:
    virtual void draw(ShapeColor color=Green);
&#125;;
Shape *pc = new Circle;
pc-&gt;draw();
//上面代码中pc的静态类型是Shape*,不管pc指向什么pc的静态类型都是Shape*,但此刻pc的动态类型为Circle*,由于draw函数是动态调用的，所以会调用Circle的draw，但缺省的参数值是静态绑定的，使用的是Shape类的Red,最终结果就会是这样:
pc-&gt;Circle::draw(Shape::Red);//这是诡异的状态
</code></pre>
<h4 id="条款42-了解typename的双重意义"><a href="#条款42-了解typename的双重意义" class="headerlink" title="条款42:了解typename的双重意义"></a>条款42:了解typename的双重意义</h4><blockquote>
<p>typename与class在作为template参数时对于C++的意义是完全一样的</p>
</blockquote>
<ul>
<li>在模板当中出现的名称如果依赖于模板参数，则这个名称被称为依赖名称(dependent names)</li>
</ul>
<pre><code class="cpp">template&lt;typename T&gt;
void f(const T&amp; container)&#123;
    T::iterator iter(container.begin());
    //typename T::iterator iter(container.begin());
    int x;
&#125;
//iter这个名称的定义需要依赖于模板参数T，因为编译器不知道T::iterator是一个什么，如果T::iterator是一个静态变量那结果就会跟我们想的完全不同，因此需要在这一行加上typename告诉编译器iterator是一个类型，即typename还能用来修饰从属性名称,但这种修饰不能在继承列表和初始化列表出现
</code></pre>
<ul>
<li>以下是通过传入的迭代器来备份某个对象的函数</li>
</ul>
<pre><code class="cpp">template&lt;typename iterT&gt;
void CopyWithIter(iterT iter)&#123;
    typename std::iterator_traits&lt;iterT&gt;::value_type tmp(*iter);
&#125;
//std::iterator_traits&lt;iterT&gt;::value_type,这句话是库通过iterT找到它所指向的对象，value_type就是这个对象类型,去翻stl的源码会发现每个容器的定义前面总会有一堆typedefs，其中就有一个value_type,这是STL的Traits技术，或者说一种规范,更详细的内容可参考条款47)
</code></pre>
<h3 id="条款49-了解new-handler的行为"><a href="#条款49-了解new-handler的行为" class="headerlink" title="条款49:了解new-handler的行为"></a>条款49:了解new-handler的行为</h3><blockquote>
<p>当operator new抛出异常之前，会先调用一个客户指定的错误处理函数，叫new_handler(是一个typedef,typedef void (*new_handler)())直到内存够用或返回一个null使得operator new 抛出异常</p>
</blockquote>
<pre><code class="cpp">void outOfmem()&#123;
    //如果在处理函数中又有new操作且失败那又会反复调用该函数，形成无限递归一样的效果
    std::cerr&lt;&lt;&quot;Unable to new&quot;&lt;&lt;&#39;\n&#39;;
    std::abort();
&#125;

int main()
&#123;
    std::set_new_handler(outOfmem);//set_new_handler使用户指定自己的错误处理函数
    new int[100000000000000000];
  
&#125;
</code></pre>
<p>一个设计良好的new_handler应该可以做到以下条件中的一些:</p>
<ol>
<li>让更多的内存可以被使用，如果系统的operator new失败,但new_handler可以分配出更多内存那下一次new可能就成功了，做法之一就是先申请一块大内存，当new_handler被调用时将它们一点一点归还给系统</li>
<li>安装另一个new_handler。如果当前的new_handler无法获取更多内存但它知道某个new_handler有这个能力那当前的new_handler可以调用set_new_handler替换自己，那下次调用就是最新的new_handler。</li>
<li>卸除new_handler,将null指针传给set_new_handler,这样operator new会抛出异常</li>
<li>抛出bad_alloc异常，这样的异常不会被operator new捕获，因此会传至内存申请处。</li>
<li>直接调用abort或exit</li>
</ol>
<p>如果想为一个class制定特殊的set_new_handler则其部分声明应该如下</p>
<pre><code class="cpp">class Widget&#123;
    public:
    static std::set_new_handler(std::new_handler p)throw();
    static void* operator new(std::size_t size)throw(std::bad_alloc);
    private:
    std::new_handler currentHandler;
&#125;;

Widget::set_new_handler(std::new_handler p)throw()&#123;
    std::new_handler oldHandler = currentHandler;
    currentHandler = p;
    return oldHandler;
&#125;
</code></pre>
<p>但是为了确保global handler总是能被安装回去(因为Widget类在调用set_new_handler时会用自己的handler去替换掉之前的global handler,而如果替换后操作失败就无法再将之前的global handler安装回去了)使用资源管理对象管理global handler</p>
<pre><code class="cpp">class NewHandlerHolder&#123;
    public:
    explicit NewHandlerHolder (std::new_handler nh):handler(nh)&#123;&#125;//这个nh就是被管理的global handler
    ~NewHandlerHolder()&#123;std::set_new_handler(hanlder);&#125;//保证之前的global handler能被安装回去
    private:
    std::new_handler handler;
    NewHandlerHolder(const NewHandlerHolder&amp;);
    NewHandlerHolder&amp; operator=(const NewHandlerHolder&amp;);
&#125;;
//下面客户Widget会这样定义其operator new

void * Widget::operator new(std::size_t size)&#123;
    NewHanlderHolder h(std::set_new_handler(currentHandler));//先将自己的处理函数currentHandler装上去
    return ::operator new(size);//如果这里失败h会被析构之前的global handler会自动装回去
&#125;;

//Widget的客户会这样使用new_handling

void outOfMem();

Widget::set_new_handler(outOfMem); //用户将自己定义的处理函数作为Widget对象分配失败的处理函数
Widget* pw1 = new Widget; //如果失败将调用outOfMem
std::string *ps = new std::string;//如果分配失败会调用global handler(如果有的话)

Widget::set_new_handler(0); //设定Widget 的专属new_handling
Widget* pw2 = new Widget; //分配失败直接报错
</code></pre>
<p>上述方案的实现不会因为类的不同而不同,于是一个将这部分功能单独抽离出来作为一个基类的想法就出现了，先上代码</p>
<pre><code class="cpp">template&lt;typename T&gt;
class NewHandlerSupport&#123;
    public:
    static std::new_handler set_new_handler(std::new_handler p)throw();
    static void*operator new(std::size_t size)(throw std::bad_alloc);

    private:
    static std::new_handler currentHandler;
&#125;;
template&lt;typename T&gt;
std::new_handler
NewHandlerSupport&lt;T&gt;::set_new_handler(std::new_handler p)throw()
&#123;
    std:new_hanlder oldHandler = currentHandler;
    currentHandler = p;
    return oldHandler;
&#125;
template&lt;typename T&gt;
void * operator new(std::size_t size)throw(std::bad_alloc)&#123;
    NewHanlderHolder h(std::set_new_handler(currentHandler));
    return ::operator new(size);
&#125; 
//将每一个currentHandler初始化为null
template&lt;typename T&gt;
std::new_handler NewHandlerSupport&lt;T&gt;::currentHandler = 0;

//现在Widget只需要继承即可
class Widget : public NewHandlerSupport&lt;Widget&gt;&#123;
    
&#125;;
</code></pre>
<p>有两个点说一下,首先为什么这里要使用模板,因为在NewHandlerSupport这个类中其实没有用到T的地方。<br>原因就是这个类是为了让不同的类继承并拥有各自的new_handler,因为currentHandler是一个静态的变量,<br>如果不适用模板那所有子类拥有的是同一份currentHandler。使用模板后不同的类就会产生一个不同的模板,使得它们拥有实体互异的currentHandler<br>其次就是这里提到的minxin风格,简而言之就是一种通过模板来达到多重继承效果的手法,下面是一个简单的例子</p>
<pre><code class="cpp">//这种风格的base class一般是这样的写法
template&lt;typename T&gt;
class A:public T&#123;
    
&#125;;

//假设有一个struct,它管理一个数据,其实可以写成一个template，这里为了简单直接设定为一个int
struct Number&#123;
    int x;
    typedef int value_type;
    void set(int n)&#123;
        x = n;
    &#125;
    int get()const&#123;
        return x;
    &#125;
&#125;;
//在此基础上实现一个可以撤回一次操作的数
template&lt;typename BASE,typename T=BASE::value_type&gt;
struct Undoable:public BASE&#123;
    typedef T value_type;
    T before;
    void set(int n)&#123;
        before = BASE::get();
        BASE::set(n);
    &#125;
    void undo()&#123;
        BASE::set(before);
    &#125;
&#125;;
//在此基础上实现一个可以再做一次的操作的数据
template&lt;typename BASE,typename T=BASE::value_type&gt;
struct Redoable:public BASE&#123;
    typedef T value_type;
    T after;
    void set(int n)&#123;
        after = BASE::get();
        BASE::set(n);
    &#125;
    void redo()&#123;
        BASE::set(after);
    &#125;
&#125;;
//现在如果想要实现一个既可以撤回又可以重做一次的数就可以通过模板组合的方式实现
typedef Redoable&lt;Undoable&lt;Number&gt;&gt; Mynum;
int main()&#123;
    Mynum num1;
    num1.set(10);
    num1.set(29);
    num1.undo();
    cout&lt;&lt;num1.get();
    return 0;
&#125;
</code></pre>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 2128099421@qq.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>






    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2022Rouze
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":200,"height":324},"mobile":{"show":true},"log":false});</script></body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: ;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
    #post .pjax article :not(pre) > code {
        color: #24292e;
        font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
        background-color: rgba(27,31,35,.05);
        border-radius: 3px;
        font-size: 85%;
        margin: 0;
        padding: .2em .4em;
    }
    
</style>







</html>
