<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言里函数返回结构体的汇编分析</title>
    <url>/2022/09/25/C%E8%AF%AD%E8%A8%80%E9%87%8C%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>在之前写操作系统内核的过程中经常需要接触到汇编和C语言,发现一个函数的返回值通常是由寄存器-eax存储的,但是在C语言里是能返回一个结构体的,如果结构体很大那寄存器肯定放不下,所以就好奇编译查看了一下,下面是测试的代码:</p>
<pre><code class="c">//test.c
struct A&#123;
        int a;
        int b;
        int c;
&#125;;

struct A f()&#123;
        struct A b;
        b.a =0;
        b.b=2;
        b.c=4;
        return b;
&#125;
int main()&#123;
        struct A a;
        a.a=31;
        a = f();
        a.b = 64;
        return 0;
&#125;
</code></pre>
<p>下面是通过gcc test.c -m32 -S产生的test.s的部分结果</p>
<p><img src="https://s2.loli.net/2022/09/26/uCqpyGgRWi47hBj.jpg" alt="test1s.jpg"><br>可以看到在call f之前有一个类似将eax寄存器的值入栈的操作,即<code>movl %eax,(%esp)</code>,查看前面eax已经被赋值成ebp-12了(<code>leal -12(%ebp),%eax</code>),这个值就是变量a的地址(一个int这里是4字节,一个struct A占12个字节)进入f函数后前面几步是常规地在自己的栈内构建变量然后赋值,(如果对函数内构建变量不是很清楚的话建议先去翻翻CSAPP里汇编那一部分的内容)但是从13行开始后面几条命令是将刚构建好的结构体拷贝到另一个地方,拷贝的目的地是以eax里面的值为基址的,往前看可以看到eax被赋成了ebp+8处的内容(<code>movl 8(%ebp),%eax</code>),常规进入函数之后一般ebp+0处是主调函数的栈底,用来恢复主调函数的栈(即函数开头push %ebp的作用),ebp+4处是主调函数的返回地址,这是call指令自动压入的,再往上就是函数的参数,由于在main函数里call f之前最后一次压栈操作是<code>movl %eax,(%esp)</code>,所以现在f内的ebp+8就是main里那个eax的内容即a的地址,所以f内构建出来的变量b就直接拷贝到a那里去了,另外比较特别的是可以看到函数返回时有一个ret $4的操作,表示的就是从栈里取出ip后再弹出4个字节的值,而在ip(也就是主调函数的返回地址)后面的4个字节内容就是刚刚说的那个eax的内容即某个变量的地址。</p>
<p>这里猜测和总结一下：<br>f函数本身没有函数参数,但在编译出来的汇编代码中会传入一个地址一样的值,f函数内部会将自己构建好的结构体拷贝到该地址去。<br>猜测:函数f本身不知道什么时候该拷贝什么时候不该拷贝,上面的代码中是a&#x3D;f();是需要拷贝的情况,但也存在单独调用的情况如f();所以可能的一个策略就是f不管该不该拷贝,反正它是一定会进行复制操作,也一定会拷到eax指定那个地方,至于这个eax指定哪由调用自己的那个地方决定。所以如果在main里调用f而不使用它的返回值那main里应该会有一个”腾出一个struct A”大小的操作,让f拷但又不去破坏到其它的变量,同时也能符合为什么要ret 4而不是ret,因为f知道虽然自己没有显示声明参数但一定会传一个参数过来给自己拷贝,所以离开的时候顺便把这个参数出栈了。下面是进行测试的代码</p>
<pre><code class="c">struct A&#123;
        int a;
        int b;
        int c;
&#125;;

struct A f()&#123;
        struct A a;
        a.a =0;
        a.b=2;
        a.c=4;
        return a;
&#125;
int main()&#123;
        struct A a;
        a.a=31;
        f();
        a.b = 64;
        return 0;
&#125;
</code></pre>
<p>同样使用gcc test.c -m32 -S产生test.s的部分结果:<br><img src="https://s2.loli.net/2022/09/26/3byKCRO8FtBiv7g.jpg" alt="test.s2.jpg"><br>可以看到这次是ebp-40传给了eax而不是ebp-12,所以符合上面的猜想,只是这次分配的空间变成了20字节一个结构体,至于为什么要变大我也不是很清楚,CSAPP里面提过一下</p>
<p>最后再用下面的代码去测试一下这个”腾出来的”空间制造的变量是不是可用的,可以把f的返回值当作另一个函数的参数,调用f之后栈里就会存在一个结构体,然后又将此结构体的值移一一入栈给另一个函数。</p>
<pre><code class="c">struct A&#123;
        int a;
        int b;
        int c;
&#125;;

struct A f()&#123;
        struct A a;
        a.a =0;
        a.b=2;
        a.c=4;
        return a;
&#125;
void g(struct A x)
&#123;&#125;
int main()&#123;
        struct A a;
        a.a=31;
        g(f());
        a.b = 64;
        return 0;
&#125;
</code></pre>
<p>仍然使用上面的指令可以得到如下结果:<br><img src="https://s2.loli.net/2022/09/26/JTFveXcU1t8bka4.jpg" alt="test3s.jpg"><br>可以看到在g之前的拷贝就是拷的那个临时构建的变量,符合前面的猜想</p>
]]></content>
      <tags>
        <tag>C 汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++</title>
    <url>/2021/07/20/EffectiveC++/</url>
    <content><![CDATA[<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ol>
<li><p>defalut构造函数一般定义成explicit，防止编译器做一些预期外的转换</p>
<pre><code class="cpp">class B&#123;
    public:
        explicit B(int x=0,bool b=true);
&#125;;
void doSomething(class B);
B b1;
doSomething(b1);
B b2(28);
doSomething(28);//此处如果没有将构造函数声明为explicit,那编译器将用这个28去构造一个B传给doSomething,这就是预期之外的，由于声明了explicit此处就会报错。
</code></pre>
</li>
</ol>
<h4 id="条款1：尽量以const-enum-inline替换-define"><a href="#条款1：尽量以const-enum-inline替换-define" class="headerlink" title="条款1：尽量以const,enum,inline替换#define"></a>条款1：尽量以const,enum,inline替换#define</h4><blockquote>
<p>因为#define不被视为语言的一部分，也许在某些情况下编译器从来不会见到#define 后面的东西</p>
</blockquote>
<ol>
<li>尽量用常量去替换#defines.</li>
</ol>
<ul>
<li><p>一个例子是常量指针，如#define name “rouze”可以替换为 const char* const name &#x3D; “rouze”;或者用STL的const string name(“rouze”);</p>
</li>
<li><p>再者就是<strong>class的专属常量</strong>，其实#define是无法定义一个class的专属常量的，因为#define出来的东西对该条语句后面的所有语句有效，无法提供私有性。要想使它专属那就要放在private里面，要想只留一份就要static，如果是常量还要加const,类似</p>
<pre><code class="cpp">class obj&#123;
    private:
    static const int num=5;
&#125;;
</code></pre>
<p>上面这种份代码是一份声明，放在头文件当中，但即使是static成员在旧编译器也是不允许的，因此需要在实现文件里赋值const obj::num&#x3D;5;</p>
</li>
<li><p>“enum hack”–enum类型在定义出来后可以当作一个整型常量</p>
<pre><code class="cpp">class Player&#123;
    private:
    static const int NumTurns=10;
    int score[NumTurns];
&#125;;
//如果编译器不支持类中初始化上述定义会报错，但又实在需要NumTurns为一个确定的大小才能通过编译使用enum如下
class Player&#123;
    private:
    enum &#123;NumTurns=10&#125;;
    int score[NumTurns];
&#125;;
//上述定义就能通过编译
</code></pre>
<p>综上所述，<strong>尽量用const或者enum替换掉#defines</strong>，<strong>尽量用inline替换形似函数的宏</strong></p>
</li>
</ul>
<h4 id="条款2-尽可能用const"><a href="#条款2-尽可能用const" class="headerlink" title="条款2: 尽可能用const"></a>条款2: 尽可能用const</h4><blockquote>
<p>const的作用是允许指定一个“约束”，编译器会强制实施这个约束，const 在不同场景有着不同的作用，主要讲一下在member funciton 的</p>
</blockquote>
<pre><code class="cpp">class TextBlock&#123;
    public:
    const char&amp; operator[]const&#123;&#125;
    char&amp; operator[]&#123;&#125;
  
&#125;;
//注意上面函数中两个const 各自的意义
</code></pre>
<p><strong>编译器强制实施的是bitwise-constness</strong>，但在编程过程当中可以通过与const对应的mutable实现<strong>conceptual constness</strong></p>
<p><strong>当const和non-const版本的实现等价只有返回不同时应在non-const版本里调用const版本来避免代码重复</strong></p>
<h4 id="条款3：确定初始化"><a href="#条款3：确定初始化" class="headerlink" title="条款3：确定初始化"></a>条款3：确定初始化</h4><h4 id="条款4：如果不想编译器自动生成函数，应该把相应的成员函数声明为private并且不予实现"><a href="#条款4：如果不想编译器自动生成函数，应该把相应的成员函数声明为private并且不予实现" class="headerlink" title="条款4：如果不想编译器自动生成函数，应该把相应的成员函数声明为private并且不予实现"></a>条款4：如果不想编译器自动生成函数，应该把相应的成员函数声明为private并且不予实现</h4><ul>
<li><p>默认生成的copy assignment运算会自动调用所有成员对象的copy assignment运算完成复制</p>
</li>
<li><p>默认的析构函数会自动调用所有的non-static成员的析构函数进行析构</p>
<pre><code class="cpp">//版本一
class BankAcount&#123;
  private:
    int num;
    BankAcount&amp; operator=(const BankAcount&amp;);
    BankAcount(BankAcount&amp;);
&#125;;
//当复制操作被外部调用时编译会发生错误表示不可调用，当内部函数或者friend函数调用复制操作时会发生链接错误，因为没有函数的实现

//版本二通过继承一个不可复制的类来阻止复制操作
class Uncopyable&#123;
    public:
  Uncopyable()&#123;&#125;
  ~Uncopyable()&#123;&#125;
    private:
  Uncopyable&amp; operator=(const Uncopyable&amp;);
  Uncopyable(const Uncopyable);
&#125;;
class BankAcount:private Uncopyable&#123;
    ...
&#125;;
//相比版本一好处就是错误会被放到编译时期来，因为当BankAcount对象在进行复制行为时势必会调用Uncopyable的复制函数(除非你写的BankAcount是错误的在copy操作没有考虑基类成员，这有悖于条款11)
</code></pre>
</li>
</ul>
<h4 id="条款5：带多态性质的基类应该声明一个virtual析构函数，如果一个类设计出来不是为了作为base-class-那就不应该声明virtual析构，因为virtual的声明会增大类的空间"><a href="#条款5：带多态性质的基类应该声明一个virtual析构函数，如果一个类设计出来不是为了作为base-class-那就不应该声明virtual析构，因为virtual的声明会增大类的空间" class="headerlink" title="条款5：带多态性质的基类应该声明一个virtual析构函数，如果一个类设计出来不是为了作为base class,那就不应该声明virtual析构，因为virtual的声明会增大类的空间"></a>条款5：带多态性质的基类应该声明一个virtual析构函数，如果一个类设计出来不是为了作为base class,那就不应该声明virtual析构，因为virtual的声明会增大类的空间</h4><h4 id="条款6：析构函数不要吐出异常"><a href="#条款6：析构函数不要吐出异常" class="headerlink" title="条款6：析构函数不要吐出异常"></a>条款6：析构函数不要吐出异常</h4><p>如果析构函数吐出异常可能导致其后需要的析构无法进行</p>
<h4 id="条款10-operator-x3D-应该返回一个reference-to-this"><a href="#条款10-operator-x3D-应该返回一个reference-to-this" class="headerlink" title="条款10: operator&#x3D;应该返回一个reference to *this"></a>条款10: operator&#x3D;应该返回一个reference to *this</h4><h4 id="条款11：operator-x3D-应该处理好自我赋值安全与异常安全"><a href="#条款11：operator-x3D-应该处理好自我赋值安全与异常安全" class="headerlink" title="条款11：operator&#x3D;应该处理好自我赋值安全与异常安全"></a>条款11：operator&#x3D;应该处理好自我赋值安全与异常安全</h4><pre><code class="cpp">//通过精心安排的语句能避免一些自我赋值与异常处理
class Widget&#123;
    private:
    Bitmap *pb;
    public:
    ...
&#125;;
//错误版本一,如果pb等于rhs.pb即自我赋值的情况，delete pb之后rhs.pb将指向一块删除的地方，这样就会产生错误
Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123;
    delete pb;
    pb = new Bitmap(*rhs.pb);
    return *this;
&#125;
//版本二，解决了自我赋值，但在new 操作错误时pb将指向错误的地方
Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123;
    if(pb == rhs.pb)
        return *this;
    delete pb;
    pb = new Bitmap(*rhs.pb);
    return *this;
&#125;
//正确版本
Widget&amp; Widget::operator=(const Widget&amp; rhs)
&#123;
    //主要思想就是在复制好原本的资源之前不要delete掉那个指针
    Bitmap * pOrig=pb;
    pb = new Bitmap(*rhs.pb);
    delete pOrig;
    return *this
&#125;
</code></pre>
<h4 id="条款12：copying操作要记得copy处理好每一个成员变量以及“base-class”成分"><a href="#条款12：copying操作要记得copy处理好每一个成员变量以及“base-class”成分" class="headerlink" title="条款12：copying操作要记得copy处理好每一个成员变量以及“base class”成分"></a>条款12：copying操作要记得copy处理好每一个成员变量以及“base class”成分</h4><pre><code class="cpp">class Base&#123;
    private:
    int base;
    public:
    Base&amp; operator=(const Base&amp;rhs);
&#125;;
class Derived:public Base&#123;
    private:
    int derive;
    public:
    Derived&amp; operator=(const Derived&amp;rhs)&#123;
        derive = rhs.derive;
        return *this;
    &#125;
&#125;;
//Base部分的成员变量没有被copy
//正确版本
Derived&amp; Derived::operator=(const Derived&amp;rhs)&#123;
    derive = rhs.derive;
    Base::operator=(rhs);
    return *this;
&#125;
</code></pre>
<pre><code>**另外copy构造函数与copy assignment函数可能代码很大部分一样，但不要在一个copying 函数里面去调用另一个copying函数来实现自己，好的方法是把共同的代码单独写成一个函数供两者调用**
</code></pre>
<h1 id="x3D-x3D-资源管理-x3D-x3D"><a href="#x3D-x3D-资源管理-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;资源管理&#x3D;&#x3D;"></a>&#x3D;&#x3D;资源管理&#x3D;&#x3D;</h1><h4 id="条款13：用对象管理资源"><a href="#条款13：用对象管理资源" class="headerlink" title="条款13：用对象管理资源"></a>条款13：用对象管理资源</h4><ul>
<li>为了防止资源泄露，最好使用RALL对象来管理资源，这样可以通过C++对象的析构函数去自动释放资源</li>
<li>常见的RALL class有auto_ptr(其复制行为有点诡异，当赋值发生时被赋值的对象拥有资源的管理权，而另一个将被置为null),tr1::shared_ptr通过持续的追踪有多少对象指向某笔资源来确定是否释放该资源，因此赋值正常</li>
<li>这两个对象在释放资源时都是进行的delete行为而非delete[]，因此不要将数组指针交给这两个对象管理</li>
</ul>
<h4 id="条款14：在资源管理类中小心处理copying行为"><a href="#条款14：在资源管理类中小心处理copying行为" class="headerlink" title="条款14：在资源管理类中小心处理copying行为"></a>条款14：在资源管理类中小心处理copying行为</h4><ul>
<li><p>如果想要禁止copying行为可以参考条款6将copying函数声明为私有并且不予实现</p>
</li>
<li><p>如果想表现出RCSP的特性可以将底层的资源用tr1::shared_ptr控制，并且其可以指定指定删除行为，缺省时表现为释放资源*std::tr1::shared_ptr<code>&lt;typename&gt;</code> obj(typename,function)*，其中的function就是自己定义的函数</p>
<pre><code class="cpp">class Lock&#123;
    public:
    explicit Lock(Mutex* pm):
    mutexPtr(pm,unlock)&#123;
        lock(mutexPtr.get());
    &#125;
    private:
    std::tr1::shared_ptr&lt;Mutex&gt; mutexPtr;
&#125;;
//将普通的Mutex换成shared_ptr管理，可以表现出RCSP的特性，注意没有写析构函数是因为默认的析构函数会调用non-static的析构函数，而shared_ptr的析构会去执行deleter的行为即指定的unl
</code></pre>
</li>
</ul>
<h4 id="条款15：资源管理类要提供好对原始资源的访问"><a href="#条款15：资源管理类要提供好对原始资源的访问" class="headerlink" title="条款15：资源管理类要提供好对原始资源的访问"></a>条款15：资源管理类要提供好对原始资源的访问</h4><blockquote>
<p>资源管理类并不是为了封装而存在，它只是为了确保“资源释放”这个特殊行为会发生而存在，因此它做的是隐藏客户不需要看的部分，但要备足客户需要的所有东</p>
</blockquote>
<pre><code class="cpp">//当把一个指针交给一个资源管理对象如auto_ptr时，很多函数接口需要的还是原始的指针类型，如果直接将auto_ptr传给函数会发生编译错误，因此资源管理对象就需要提供相应的类型转换

//方法一显示转换
class Manage&#123;
    private:
    Something s;
    public:
    explicit Manage(Something x):
    s(x)
    &#123;
        ...
    &#125;
    ~Manage()&#123;
        ...
    &#125;
    Something get()const&#123;
        return s;
    &#125;
&#125;;//通过Manage对象调用get()返回内部资源
//方法二隐式转换
class Manage&#123;
    public:
    ...
    operator Something()const&#123;
        return s;
    &#125;
&#125;;//在需要类型转换时编译器会自动调用转换函数，这样对客户来说比较轻松，但这样可能就会隐藏危险
</code></pre>
<h4 id="条款17：用独立的语句将new对象置入智能指针"><a href="#条款17：用独立的语句将new对象置入智能指针" class="headerlink" title="条款17：用独立的语句将new对象置入智能指针"></a>条款17：用独立的语句将new对象置入智能指针</h4><p>考虑下面这样的代码</p>
<pre><code class="cpp">int priority();
void process(std::auto_ptr&lt;Widget&gt; pw,pty);

//以下方式调用process函数
process(new Widget,priority());
//首先会报错，因为智能指针的初始化是显式的
process(std::auto_ptr&lt;Widget&gt;(new Widget),priority());

//乍看没问题，但可能造成资源泄露，在调用process之前编译器知道要先做下面几件事
/*1.执行new Widget
2.执行 priority()
3. 执行auto_ptr的构造函数*/
//但只能确定new Widget在auto_ptr之前发生，priority()的执行是无法确定的，如果恰好是按上述顺序，那在priority()出错时new出来的对象将无法放到智能指针里面去
//正确形式
std::auto_ptr&lt;Widget&gt; pw(new Widget);
process(pw,priority());
</code></pre>
<h1 id="x3D-x3D-声明与设计-x3D-x3D"><a href="#x3D-x3D-声明与设计-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;声明与设计&#x3D;&#x3D;"></a>&#x3D;&#x3D;声明与设计&#x3D;&#x3D;</h1><h4 id="条款25：当需要自己写一个swap函数时先确定其不要抛出异常，同时提供一个non-member的版本调用该swap函数，此non-member可以放在class的同一命名空间内，最后可以对std-swap进行全特化但不能往std内加入全新的东西"><a href="#条款25：当需要自己写一个swap函数时先确定其不要抛出异常，同时提供一个non-member的版本调用该swap函数，此non-member可以放在class的同一命名空间内，最后可以对std-swap进行全特化但不能往std内加入全新的东西" class="headerlink" title="条款25：当需要自己写一个swap函数时先确定其不要抛出异常，同时提供一个non-member的版本调用该swap函数，此non-member可以放在class的同一命名空间内，最后可以对std::swap进行全特化但不能往std内加入全新的东西"></a>条款25：当需要自己写一个swap函数时先确定其不要抛出异常，同时提供一个non-member的版本调用该swap函数，此non-member可以放在class的同一命名空间内，最后可以对std::swap进行全特化但不能往std内加入全新的东西</h4><pre><code class="cpp">//假设有一个类，它只管理一个对象指针，定义如下
class WidgetImpl&#123;
    public:
    ...
    private:
    std::vector&lt;int&gt; v;
    ...
&#125;;
class Widget&#123;
    public:
    ...
    Widget&amp;operator=(const Widget&amp;rhs)&#123;
        ...
        *pImpl = *(rhs.pImpl);//这里是通过WidgetImpl对象的operator=完成一个深拷贝而不是直接pImpl=rhs.pImpl
        ...
    &#125;
    private:
    WidgetImpl* pImpl;
&#125;;
//如果直接交换两个,std::swap只是最简单的交换
namespace std&#123;
    template&lt;typename T&gt;
    void swap(T&amp;a,T&amp;b)&#123;
        T temp(a);
        a = b;
        b = tmp;
    &#125;
&#125;
//如果调用std::swap交换那swap会调用最底层的WidgetImpl的operator=,会有ector拷贝的操作，而实际中我们只需要交换两个Widget管理的指针即可，所以有了特化的std::swap
namespace std&#123;
    template&lt;&gt;
    void swap&lt;Widget&gt;(Wiget&amp;lhs,Widget&amp;rhs)&#123;
        //由于成员是private，所以应该定义一个swap成员函数来对指针进行操作，而这里只是进行一个调用
        lhs.swap(rhs);
    &#125;
&#125;
//这样在使用std::swap时编译器会自动找到该版本进行相应的特化操作
/*后面还有如果类是一个模板类需要注意的地方，以后再写吧-_-*/
</code></pre>
<h1 id="x3D-x3D-实现-x3D-x3D"><a href="#x3D-x3D-实现-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;实现&#x3D;&#x3D;"></a>&#x3D;&#x3D;实现&#x3D;&#x3D;</h1><h4 id="条款26：尽量延后变量定义的出现时间，以增加程序清晰度和改善效率"><a href="#条款26：尽量延后变量定义的出现时间，以增加程序清晰度和改善效率" class="headerlink" title="条款26：尽量延后变量定义的出现时间，以增加程序清晰度和改善效率"></a>条款26：尽量延后变量定义的出现时间，以增加程序清晰度和改善效率</h4><p>最好就是在得到能够初始化这个变量的数据出现时定义该变量，一方面可读性较高另一方面也能减少一些初始化引起的问题</p>
<h4 id="条款27：尽量少做转型动作"><a href="#条款27：尽量少做转型动作" class="headerlink" title="条款27：尽量少做转型动作"></a>条款27：尽量少做转型动作</h4><blockquote>
<p>C++提供的四种新转型方式</p>
<p>const_cast<code>&lt;T&gt;</code>(expression)–&gt;用来移除常量性，也是唯一有这个能力的转型操作符</p>
<p>dynamic_cast<code>&lt;T&gt;</code>(expression)</p>
<p>reinterpret_cast<code>&lt;T&gt;</code>(expression)</p>
<p>static_cast<code>&lt;T&gt;</code>(expression)</p>
</blockquote>
<p><strong>类型转换并不是简单的一个类似声明一样的东西，任何一个类型转换往往令编译器编译出运行期执行的代码</strong></p>
<pre><code class="cpp">class Base1&#123;...&#125;;
class Base2&#123;...&#125;;
class Derived:public Base1,public Base2&#123;...&#125;;

Derived d;
Base1* p1 = &amp;d;
Base2* p2 = &amp;d;
Derived* p3 = &amp;d;
//将d的地址转型成Base1的指针，只有编译器知道在继承过程当中属于Base1的那个部分在d的哪里也就是有一个偏移量需要调整，因此p1,p2,p3很可能不同，这就是转型d
</code></pre>
<h4 id="条款29-尽量避免返回对象的handles"><a href="#条款29-尽量避免返回对象的handles" class="headerlink" title="条款29: 尽量避免返回对象的handles"></a>条款29: 尽量避免返回对象的handles</h4><blockquote>
<p>当对象成员的handles(reference,pointer,迭代器等)被成员函数返回，这会破坏封装性，即使返回的是const reference,当对象内部的成员被销毁时，这个留在外面的handle就会成为一个空掉着的handle。但并不代表这是一定不行的，像string的operator[]就需要返回内部字符的reference，以及各种迭代器都需要这样。</p>
</blockquote>
<h4 id="条款30：inling的里里外外"><a href="#条款30：inling的里里外外" class="headerlink" title="条款30：inling的里里外外"></a>条款30：inling的里里外外</h4><blockquote>
<p>inline函数除了能免除函数调用的成本，简单的inlined函数还有可能被编译器优化成更短的目标码，这样有较高的指令高速缓存装置击中率。</p>
<p>但是，如果对一个程序库来说，一个inline 函数f,如果设计者改变了f，那么客户中所有使用了f函数的地方都要重新编译，而如果没有inline只需要重新连接一下，另外不是说某些看起来很简单的代码就一定可以inline，例子如下</p>
</blockquote>
<pre><code class="cpp">class Base&#123;
    public:
    ...
    private:
    std::string b1,b2; 
&#125;;
class Derived :public Base&#123;
    public:
    Derived()&#123;&#125;
    private:
    std::string d1,d2;
&#125;;
//看上去默认构造函数是一个绝佳的inline对象，但在实际的编译之后为了保证程序的正常运行，编译器会添加一些代码，其可能的样子如下
Derived()&#123;
    Base::Base();
    try&#123;d1.std::string::string();&#125;
    catch(...)&#123;
        Base::~Base();
        throw;
    &#125;
    try&#123;d2.std::string::string()&#125;
    catch(...)&#123;
        Base::~Base();
        throw;
    &#125;
    ...
&#125;
//Derive函数先构造好继承的成分，之后再尝试构造自己的成员，如果出现异常就释放已经构造的资源

//上述代码只是简单的描述了一下编译器可能的操作，实际可能更加精致复杂，如果说将所有的构造函数都inlined，那Derive函数将有四份string构造函数的代码（Base成分那里两个再加上自己的两个），如果情况再稍微复杂一些构造函数的代码就可能非常巨大，不再适合inline
</code></pre>
<h4 id="条款31：将文件间的编译依存将至最低"><a href="#条款31：将文件间的编译依存将至最低" class="headerlink" title="条款31：将文件间的编译依存将至最低"></a>条款31：将文件间的编译依存将至最低</h4><blockquote>
<p>C++并没有把“接口从实现中分离”这件事做得很好，Class的定义式不仅描述了接口，还有实现细节，如下面代码所示</p>
</blockquote>
<pre><code class="cpp">class Person&#123;
    //各种接口
    public:
    Person(const std::string&amp;,const Date&amp;,const Address&amp;);
    std::string name()const;
    std::string birthDate()const;
    std::string Address()const;
    private:
    //下面就是所说的实现细节
    std::string theName;
    Date theBirthDate;
    Address theAddress;
&#125;;
</code></pre>
<p>首先上面的代码是无法通过编译的，因为Date和Address是为定义的类型，所以前面常会有include&quot;date.h”这样的东西，其次Person的定义文件和每一个含入了Person class的文件就形成了一种编译依存关系，任何一个头文件的改变都将引起其它文件的的重新编译</p>
<p><strong>解决方案:</strong></p>
<ol>
<li>使用Pimpl技法，将Person分割成为两个classes,一个只提供接口，另一个负责实现接口,Person的定义将如下:</li>
</ol>
<pre><code class="cpp">#include&lt;string&gt;
#include&lt;memory&gt;//shared_ptr所在库
//实现接口的类
class PersonImpl;
//将Date与Address作为前置声明而非直接#include相应头文件这样可以减少由于#include引进的依存

//因为现在的Person只提供接口，需要知道的只是Date与Address这两种类型而非细节，即在Person的定义中Date与Address要么是函数返回类型用到要么是函数参数类型用到,这两种情况下编译都是可以通过的

//但这里无法去实现Person的成员函数
class Date;
class Address;
class Person&#123;
    //各种接口
    public:
    Person(const std::string&amp;,const Date&amp;,const Address&amp;);
    std::string name()const;
    std::string birthDate()const;
    std::string Address()const;
    private:
    //下面是一个指向实物的指针而非具体细节
    std::tr1::shared_ptr&lt;PersonImpl&gt; PImpl;
&#125;;
</code></pre>
<p>现在来看，Person的使用者就完全不需要知道Person的实现细节了，那些关于Person实现的任何修改也不再需要Person的使用者重新编译了，因为从头到尾Person的使用者只是在通过一个指针来进行各种操作，并不能写出依赖于Person细节实现的代码，也就没有了这层编译依赖</p>
<h4 id="条款33：避免遮掩继承来的名字"><a href="#条款33：避免遮掩继承来的名字" class="headerlink" title="条款33：避免遮掩继承来的名字"></a>条款33：避免遮掩继承来的名字</h4><blockquote>
<p>“名称遮掩规则”在类的继承中仍然起作用，想要改变可以使用using</p>
</blockquote>
<pre><code class="cpp">class Base&#123;
    private:
    int x;
    public:
    virtual void mf1()=0;
    virtual void mf1(int);
    void mf3();
    void mf3(int);
&#125;;
class Derived :public Base&#123;
    public:
    virtual void mf1();
    void mf3();
    void mf4();
&#125;;

Derived d;
d.mf1();//right
d.mf1(1);//wrong
d.mf3();//right
d.mf3(1);//wrong
//继承中的名字会覆盖掉所有继承而来的同名函数就像内部的同名变量会掩盖外部的同名变量,本质的原因是*作用域的嵌套*
class Derived :public Base&#123;
    public:
    using Base::mf1;
    using Base::mf3;
    virtual void mf1();
    void mf3();
    void mf4();
&#125;;
//用using解决该问题
</code></pre>
<h4 id="条款37：绝不重新定义继承来的non-virtual函数"><a href="#条款37：绝不重新定义继承来的non-virtual函数" class="headerlink" title="条款37：绝不重新定义继承来的non-virtual函数"></a>条款37：绝不重新定义继承来的non-virtual函数</h4><blockquote>
<p>继承而来的non-virtual函数指定了接口继承以及一份强制性实现，因此non-virtual函数不应该被重写，如果想要表现特异性凌驾于其不变性之上，那该函数就应该声明为virtual</p>
</blockquote>
<h4 id="条款38：绝不重新定义继承而来的缺省参数值"><a href="#条款38：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款38：绝不重新定义继承而来的缺省参数值"></a>条款38：绝不重新定义继承而来的缺省参数值</h4><blockquote>
<p>首先能重新定义的是virtual函数，因此本条款是针对于virtual函数的</p>
</blockquote>
<pre><code class="cpp">class Shape&#123;
    public:
    enum ShapeColor&#123;Red,Black,Green&#125;;
    virtual void draw(ShapeColor color=Red);
&#125;;
class Circle:public Shape&#123;
    public:
    virtual void draw(ShapeColor color=Green);
&#125;;
Shape *pc = new Circle;
pc-&gt;draw();
//上面代码中pc的静态类型是Shape*,不管pc指向什么pc的静态类型都是Shape*,但此刻pc的动态类型为Circle*,由于draw函数是动态调用的，所以会调用Circle的draw，但缺省的参数值是静态绑定的，使用的是Shape类的Red,最终结果就会是这样:
pc-&gt;Circle::draw(Shape::Red);//这是诡异的状态
</code></pre>
<h4 id="条款42-了解typename的双重意义"><a href="#条款42-了解typename的双重意义" class="headerlink" title="条款42:了解typename的双重意义"></a>条款42:了解typename的双重意义</h4><blockquote>
<p>typename与class在作为template参数时对于C++的意义是完全一样的</p>
</blockquote>
<ul>
<li>在模板当中出现的名称如果依赖于模板参数，则这个名称被称为依赖名称(dependent names)</li>
</ul>
<pre><code class="cpp">template&lt;typename T&gt;
void f(const T&amp; container)&#123;
    T::iterator iter(container.begin());
    //typename T::iterator iter(container.begin());
    int x;
&#125;
//iter这个名称的定义需要依赖于模板参数T，因为编译器不知道T::iterator是一个什么，如果T::iterator是一个静态变量那结果就会跟我们想的完全不同，因此需要在这一行加上typename告诉编译器iterator是一个类型，即typename还能用来修饰从属性名称,但这种修饰不能在继承列表和初始化列表出现
</code></pre>
<ul>
<li>以下是通过传入的迭代器来备份某个对象的函数</li>
</ul>
<pre><code class="cpp">template&lt;typename iterT&gt;
void CopyWithIter(iterT iter)&#123;
    typename std::iterator_traits&lt;iterT&gt;::value_type tmp(*iter);
&#125;
//std::iterator_traits&lt;iterT&gt;::value_type,这句话是库通过iterT找到它所指向的对象，value_type就是这个对象类型,去翻stl的源码会发现每个容器的定义前面总会有一堆typedefs，其中就有一个value_type,这是STL的Traits技术，或者说一种规范,更详细的内容可参考条款47)
</code></pre>
<h3 id="条款49-了解new-handler的行为"><a href="#条款49-了解new-handler的行为" class="headerlink" title="条款49:了解new-handler的行为"></a>条款49:了解new-handler的行为</h3><blockquote>
<p>当operator new抛出异常之前，会先调用一个客户指定的错误处理函数，叫new_handler(是一个typedef,typedef void (*new_handler)())直到内存够用或返回一个null使得operator new 抛出异常</p>
</blockquote>
<pre><code class="cpp">void outOfmem()&#123;
    //如果在处理函数中又有new操作且失败那又会反复调用该函数，形成无限递归一样的效果
    std::cerr&lt;&lt;&quot;Unable to new&quot;&lt;&lt;&#39;\n&#39;;
    std::abort();
&#125;

int main()
&#123;
    std::set_new_handler(outOfmem);//set_new_handler使用户指定自己的错误处理函数
    new int[100000000000000000];
  
&#125;
</code></pre>
<p>一个设计良好的new_handler应该可以做到以下条件中的一些:</p>
<ol>
<li>让更多的内存可以被使用，如果系统的operator new失败,但new_handler可以分配出更多内存那下一次new可能就成功了，做法之一就是先申请一块大内存，当new_handler被调用时将它们一点一点归还给系统</li>
<li>安装另一个new_handler。如果当前的new_handler无法获取更多内存但它知道某个new_handler有这个能力那当前的new_handler可以调用set_new_handler替换自己，那下次调用就是最新的new_handler。</li>
<li>卸除new_handler,将null指针传给set_new_handler,这样operator new会抛出异常</li>
<li>抛出bad_alloc异常，这样的异常不会被operator new捕获，因此会传至内存申请处。</li>
<li>直接调用abort或exit</li>
</ol>
<p>如果想为一个class制定特殊的set_new_handler则其部分声明应该如下</p>
<pre><code class="cpp">class Widget&#123;
    public:
    static std::set_new_handler(std::new_handler p)throw();
    static void* operator new(std::size_t size)throw(std::bad_alloc);
    private:
    std::new_handler currentHandler;
&#125;;

Widget::set_new_handler(std::new_handler p)throw()&#123;
    std::new_handler oldHandler = currentHandler;
    currentHandler = p;
    return oldHandler;
&#125;
</code></pre>
<p>但是为了确保global handler总是能被安装回去(因为Widget类在调用set_new_handler时会用自己的handler去替换掉之前的global handler,而如果替换后操作失败就无法再将之前的global handler安装回去了)使用资源管理对象管理global handler</p>
<pre><code class="cpp">class NewHandlerHolder&#123;
    public:
    explicit NewHandlerHolder (std::new_handler nh):handler(nh)&#123;&#125;//这个nh就是被管理的global handler
    ~NewHandlerHolder()&#123;std::set_new_handler(hanlder);&#125;//保证之前的global handler能被安装回去
    private:
    std::new_handler handler;
    NewHandlerHolder(const NewHandlerHolder&amp;);
    NewHandlerHolder&amp; operator=(const NewHandlerHolder&amp;);
&#125;;
//下面客户Widget会这样定义其operator new

void * Widget::operator new(std::size_t size)&#123;
    NewHanlderHolder h(std::set_new_handler(currentHandler));//先将自己的处理函数currentHandler装上去
    return ::operator new(size);//如果这里失败h会被析构之前的global handler会自动装回去
&#125;;

//Widget的客户会这样使用new_handling

void outOfMem();

Widget::set_new_handler(outOfMem); //用户将自己定义的处理函数作为Widget对象分配失败的处理函数
Widget* pw1 = new Widget; //如果失败将调用outOfMem
std::string *ps = new std::string;//如果分配失败会调用global handler(如果有的话)

Widget::set_new_handler(0); //设定Widget 的专属new_handling
Widget* pw2 = new Widget; //分配失败直接报错
</code></pre>
<p>上述方案的实现不会因为类的不同而不同,于是一个将这部分功能单独抽离出来作为一个基类的想法就出现了，先上代码</p>
<pre><code class="cpp">template&lt;typename T&gt;
class NewHandlerSupport&#123;
    public:
    static std::new_handler set_new_handler(std::new_handler p)throw();
    static void*operator new(std::size_t size)(throw std::bad_alloc);

    private:
    static std::new_handler currentHandler;
&#125;;
template&lt;typename T&gt;
std::new_handler
NewHandlerSupport&lt;T&gt;::set_new_handler(std::new_handler p)throw()
&#123;
    std:new_hanlder oldHandler = currentHandler;
    currentHandler = p;
    return oldHandler;
&#125;
template&lt;typename T&gt;
void * operator new(std::size_t size)throw(std::bad_alloc)&#123;
    NewHanlderHolder h(std::set_new_handler(currentHandler));
    return ::operator new(size);
&#125; 
//将每一个currentHandler初始化为null
template&lt;typename T&gt;
std::new_handler NewHandlerSupport&lt;T&gt;::currentHandler = 0;

//现在Widget只需要继承即可
class Widget : public NewHandlerSupport&lt;Widget&gt;&#123;
    
&#125;;
</code></pre>
<p>有两个点说一下,首先为什么这里要使用模板,因为在NewHandlerSupport这个类中其实没有用到T的地方。<br>原因就是这个类是为了让不同的类继承并拥有各自的new_handler,因为currentHandler是一个静态的变量,<br>如果不适用模板那所有子类拥有的是同一份currentHandler。使用模板后不同的类就会产生一个不同的模板,使得它们拥有实体互异的currentHandler<br>其次就是这里提到的minxin风格,简而言之就是一种通过模板来达到多重继承效果的手法,下面是一个简单的例子</p>
<pre><code class="cpp">//这种风格的base class一般是这样的写法
template&lt;typename T&gt;
class A:public T&#123;
    
&#125;;

//假设有一个struct,它管理一个数据,其实可以写成一个template，这里为了简单直接设定为一个int
struct Number&#123;
    int x;
    typedef int value_type;
    void set(int n)&#123;
        x = n;
    &#125;
    int get()const&#123;
        return x;
    &#125;
&#125;;
//在此基础上实现一个可以撤回一次操作的数
template&lt;typename BASE,typename T=BASE::value_type&gt;
struct Undoable:public BASE&#123;
    typedef T value_type;
    T before;
    void set(int n)&#123;
        before = BASE::get();
        BASE::set(n);
    &#125;
    void undo()&#123;
        BASE::set(before);
    &#125;
&#125;;
//在此基础上实现一个可以再做一次的操作的数据
template&lt;typename BASE,typename T=BASE::value_type&gt;
struct Redoable:public BASE&#123;
    typedef T value_type;
    T after;
    void set(int n)&#123;
        after = BASE::get();
        BASE::set(n);
    &#125;
    void redo()&#123;
        BASE::set(after);
    &#125;
&#125;;
//现在如果想要实现一个既可以撤回又可以重做一次的数就可以通过模板组合的方式实现
typedef Redoable&lt;Undoable&lt;Number&gt;&gt; Mynum;
int main()&#123;
    Mynum num1;
    num1.set(10);
    num1.set(29);
    num1.undo();
    cout&lt;&lt;num1.get();
    return 0;
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Exceptional C++</title>
    <url>/2021/07/20/ExceptionalC++/</url>
    <content><![CDATA[<h4 id="条款2-3-大小写不敏感的字符串"><a href="#条款2-3-大小写不敏感的字符串" class="headerlink" title="条款2-3:大小写不敏感的字符串"></a>条款2-3:大小写不敏感的字符串</h4><blockquote>
<p>要求实现一个大小写不敏感的string类<br><strong>这里主要利用traits技术</strong></p>
</blockquote>
<ol>
<li><p>从STL的源码当中可以看到string是一个模板生成的类型</p>
<pre><code class="cpp">typedef basic_string&lt;char&gt; string;
//进一步看basic_string的声明如下
template&lt;class charT,class traits=char_traits&lt;charT&gt;,class Allocator = allocator&lt;charT&gt;&gt;
class basic_string;
</code></pre>
<p><del>关于traits技术还不是很理解，后面学了在补上</del><br>basic_string提供了一些判断字符串大于小于等于的函数，这些函数建立在traits上，如果希望改变比较多的行为可以通过提供自定义的traits来实现<br>&#96;&#96;&#96;cpp<br>&#x2F;&#x2F;通过继承去改变那些需要替换的函数,其安全性后面讨论<br>struct my_char_traits:public char_traits<char>{<br> static bool eq(char c1,char c2){<br> return toupper(c1)&#x3D;&#x3D;toupper(c2);<br> }</char></p>
<p> static bool lt(char c1,char c2){<br> return toupper(c1)&lt;toupper(c2);<br> }</p>
<p> static int compare(const char* s1,const char* s2,size_t n){<br> for(size_t i&#x3D;0;i&lt;n;++i){<br>     if(toupper(*s1)!&#x3D;toupper(*s2))<br>     return i;<br> ++s1,++s2;<br> }<br> }</p>
<p> static const char* find(const char* s,int n,char c){<br> while(n– &gt; 0&amp;&amp;toupper(*s)&#x3D;&#x3D;toupper(c)){<br>     ++s;<br> }<br> return n&gt;&#x3D;0?s:0;<br> }</p>
</li>
</ol>
<p>};<br>&#x2F;&#x2F;现在只需像string一样产生一个类型即可<br>typedef basic_string&lt;char,my_char_traits&gt; Mystring;</p>
<pre><code>

#### 条款4-5:可用性最高的泛型容器
* 模板构造函数不是构造函数，因此即使在类里面定义了模板构造函数，编译器仍会生成对应的隐式构造函数，但就算是模板拷贝函数也会阻止编译器对默认构造函数的生成，

#### 条款26- :编译防火墙和Pimpl技法
&gt; 习惯性地#include一些不必要的头文件会严重降低编译的效率和依赖性,尤其是这些头文件又包含了其它的头文件


~~简单地理解就是在你给客户看的头文件里能少用#include就少用#include,能不包含定义就不包含定义~~

*这里插一段可以帮助理解但不一定正确的描述：在设计一个东西的时候，就假设一个类，你要把接口的这些声明放在头文件里，而具体的实现是放在.c文件里，因为这里面有你的&quot;核心&quot;算法之类的东西，然后你编译好后这个.c文件就成了一个.o文件(这里很有可能不对，但可以先暂时这样理解-_-)，类的使用者也就是客户#include你给的头文件然后编译的时候去链接这个.o文件就行了,因此客户能了解到的这个类的所有信息都来自你的头文件*

```cpp
//本章将优化下面的代码
//下面的内容是x.h最初的内容,也即客户可以看到的代码
#include&lt;iostream&gt;
#include&lt;ostream&gt;
#include&lt;list&gt;

//A,B,C,D,E都不是模板
//只有A和C定义了虚函数

#include&quot;a.h&quot;
#include&quot;b.h&quot;
#include&quot;c.h&quot;
#include&quot;d.h&quot;
#include&quot;e.h&quot;
//包含的头文件里有相关类的声明与定义

class X:public A,private B&#123;
    public:
    X(const C&amp;);
    B f(int,char*);
    C f(int,C);
    C&amp; g(B);
    E h(E);
    virtual std::ostream&amp; print(std::ostream&amp; )const;
    private:
    std::list&lt;C&gt; clist_;
    D d_;
&#125;;

inline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os,const X&amp; x)&#123;

    return x.print(os);

&#125;
</code></pre>
<p><strong>只需要声明就不要#include其定义</strong><br>比较明显的,E的定义在此头文件内是不需要的,<strong>函数返回类型，参数类型，引用类型，指针类型这些都不需要看到类的定义，只要有一个声明即可</strong>#include”e.h”可以改成Class E;<br>另外应该也清楚&lt;iostream&gt;里面是包含&lt;ostream&gt;的，所以#include&lt;ostream&gt;也是可以删除的.但是,<iostream>里面包含了ostream的声明跟定义,在这个头文件里,用到的只是ostream&amp;这个引用类型,所以有没有一个头文件只包含了ostream的声明但不含其定义呢,有,&lt;iosfwd&gt;(ios forward declare),这个头文件包含了输入输出流的各个组件的声明式,而这些组件的定义则分布在各个不同的头文件,客户根据需要包含相应的头文件.这样就达到了”尽量少包含定义”的要求,因为输入输出流的组件是非常多的,但客户不一定都会使用到它们,根据需要只包含需要的定义即可,这跟Effective的条款31那里是符合的</iostream></p>
<pre><code class="cpp">//下面的代码会报错,说fstream这个类型是不完整的,因为fstream的定义在&lt;fstream&gt;里面
#include&lt;iostream&gt;
int main()
&#123;
    std::fstream out;
    //&lt;iostream&gt;里肯定有一个#include&lt;iosfwd&gt;,而&lt;iosfwd&gt;里面有fstream这个组件的声明,所以不会报no declaration的错误而是incomplete type的错误
    return 0;
&#125;
</code></pre>
<p>所以经过初步优化，代码是这样的</p>
<pre><code class="cpp">#include&lt;iosfwd&gt;
#include&lt;list&gt;

#include&quot;a.h&quot;
#include&quot;b.h&quot;
#include&quot;c.h&quot;
#include&quot;d.h&quot;
Class E;
class X:public A,private B&#123;
    public:
    X(const C&amp;);
    B f(int,char*);
    C f(int,C);
    C&amp; g(B);
    E h(E);
    virtual std::ostream&amp; print(std::ostream&amp; )const;
    private:
    std::list&lt;C&gt; clist_;
    D d_;
&#125;;

inline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os,const X&amp; x)&#123;

    return x.print(os);

&#125;
</code></pre>
<p>现在的代码达到了只要X的基类和公有接口不变,即使对X的结构做一些修改(比如加了一个private变量),使用了X的用户代码也不会受影响,只需要重新编译一下的地步,下面看能不能继续删除一些#include</p>
<ol>
<li>首先a.h和b.h现在不能删除的原因是X继承于A跟B,因此在此头文件内必须看到A与B的定义才能知道X的大小及其它一些必要信息如虚函数等</li>
<li>list,c.h和d.h现在不能删除的原因是list<C>和D是X的私有数据成员(因为作者写这本书是很久之前了,其实作为模板参数的C现在也不需要看到其定义了,因为在这个头文件里这里的list<C>其实也只是一个”声明”类似的东西,模板还没有真正实例化的,这个模板的实例化应该在X对象的实例化那里,所以其实这里的#include”c.h”也可以用Class C代替)必须要知道其定义才能确定X的大小</C></C></li>
</ol>
<ul>
<li>Pimpl(Pointer to implemention)出现<br>先上代码<pre><code class="cpp">#include&lt;iosfwd&gt;
#include&quot;a.h&quot;
#include&quot;b.h&quot;
class C;
class E;
class X:public A,private B&#123;
  public:
  //内容不变
  private:
  struct Ximpl;
  Ximpl* pimpl_;
&#125;;
</code></pre>
跟前面的代码相比,又少了三个#include分别是c,d跟list的头文件,然后private部分变成了一个指针,再看下现在x.cpp里的内容<br>&#96;&#96;&#96;cpp<br>#include”x.h”<br>#include”c.h”<br>#include”d.h”<br>#include<list><br>&#x2F;*<br>public接口的实现细目</list></li>
</ul>
<p>*&#x2F;<br>&#x2F;&#x2F;对X::Ximpl的定义<br>struct X::Ximpl{<br>    std::list<C> clist_;<br>    D d;<br>};</C></p>
<pre><code>可以看到删掉的三个#include被搬到x.cpp文件里来了,以及在X里的那个Ximpl的定义,其实就是把以前的private数据成员捆成了一个struct,然后让原来的类里面只有一个指针来访问这些成员

看完了变化现在再来说原因
&gt; cpp设置private是为了防止客户进行一些未授权的访问

举个例子,假设你写了一个表示圆的类,它现在用的是xy垂直坐标系,然后你定义它的数据成员是一个圆心的坐标和半径,你也设计了供客户使用的计算面积的函数Square。在你提供给客户的头文件内,客户是可以看到你通过一个坐标和半径来定义一个圆,然后如果没有private,也就是说客户可以直接访问这两个数据成员,那这个时候有的客户就觉得自己很牛,要自己写一个函数计算面积,反正他可以直接访问这些成员的,然后他就写好了计算面积的函数,并且用得很开心,但是有一天你说你觉得用xy垂直坐标不好,想用极坐标来表示一个圆,然后你更改了圆这个类的定义当然之前那些数据成员也肯定改了,而客户的那个计算面积的函数是严重依赖这些内部&quot;细节&quot;的,你用垂直坐标的方法计算极坐标肯定是错的,也就导致客代码中所有依赖直接访问数据成员的地方全部需要重写,这肯定是一个噩梦

上面的例子使用private就很好解决,将数据成员变成private,客户就算能看到细节也只能乖乖用提供的Square函数去,也就避免了客户写出一些依赖于这些细节的代码。

而上面优化后的头文件,直接把private的内容也封装起来了,直接让客户看都看不到实现细节,更进一步地解决了这个依赖问题,同时在这个头文件里不需要看到D跟list,这里是声明都不需要看到,D被替换成class D;是因为前面有个函数使用了D类型。现在随便你怎么改X的私有成员,客户代码甚至连编译都不需要重新编译了(必须感叹一下这个方法很牛(⌐■_■))但这个方法也有一些不足的地方,放到最后再讨论,下面再再看下能不能优化

上面不能优化的第二点已经被Pimpl给解决掉了,现在就剩a和b这两个头文件了
注意到B是私有继承,且B没有虚函数,这就有机会了
一般情况下,私有继承是能通过复合对象的方式给替换掉的,偏偏要使用私有继承一般都是为了能访问基类的protected成员和*重写其虚函数*

又举个例子,假设你要设计一个青蛙类,这个类的对象要每秒调用一次自己的GuaGua函数,这个时候你翻到了一个写好的定时器类,定义如下
```cpp
class Timer&#123;
    public:
    explicit Timer(int tickFrequency);//它有一个自己频率
    virtual void onTick()const; //依据频率,每多少秒就调用一次该函数
&#125;
//似乎可以这样定义Frog
class Frog:public Timer&#123;
    private:
    virtual void ontick()const&#123;
        GuaGua();
    &#125;
&#125;;
//首先这个ontick一定要变成private,如果变成public会让用户认为他们可以调用它,而对于一个青蛙来说它不应该有一个tick接口,其次采用继承的方式可以去重写那个onTick函数
</code></pre>
<p>上面的代码就说明了一种偏偏要使用私有继承的情况,但这种方式也绝非必要,仍然可以通过一些方式来达到相同的效果,如下:</p>
<pre><code class="cpp">class Frog&#123;
    private:
    class WidgetTimer:public Timer&#123;
        public:
        virtual void onTick()const;
    &#125;;
    WigetTimer timer_;
&#125;;
</code></pre>
<p>现在回归正题,B这个类并没有虚函数,如果我们再假设B没有保护成员,那私有继承这种关系就太”强”了我们用不到这么”强”的关系,将其作为私有成员即可,这样就能把B纳入struct XImpl_中了<br>下面是最终的x.h文件</p>
<pre><code class="cpp">#include&lt;iosfwd&gt;
#include&quot;a.h&quot;
class B;
class C;
class E;
class X:public A
&#123;
    public:
    X(const C&amp;);
    B f(int,char*);
    C f(int,C);
    C&amp; g(B);
    E h(E);
    virtual std::ostream&amp; print(std::ostream&amp; os,const X&amp; x)const;
    private:
    struct XImpl_;
    XImpl_ * pimpl_;
&#125;;
inline std::operator&lt;&lt;(std::ostream&amp; os,const X&amp; x)&#123;
    return x.print(os);
&#125;
</code></pre>
<p>现在这个头文件只有两个#include了!比起最初的代码真是非常大的改进( ⓛ ω ⓛ *)<br>但相应的还有一些代价问题需要讨论</p>
<ol>
<li>哪些部分应该放入XImpl？</li>
<li>在XImpl中是否应该加入一个指向X的回指指针？</li>
</ol>
<p>第一个问题的常见做法有两种</p>
<ol>
<li>将所有的私有成员放进XImpl中,但要注意不能将虚函数放到这里面来。因为如果派生类需要对基类的虚函数进行覆盖(这里提一下子类就算不能访问基类的private函数但能覆盖private函数),那这个虚函数就必须出现在实际的派生类当中,当然如果你不想一个函数被覆盖,把这个函数放进XImpl就起到了一个类似final的效果</li>
<li>将XImpl写成与原来的X完全一样的形式,X的作用就是去调用XImpl对应的接口,这种方法实现的X在继承时没什么大用,因为什么东西都在XImpl中,子类没法去覆盖相应的函数</li>
</ol>
<p>现在考虑第二个问题,首先想一想为什么要加一个回指指针,因为有些private函数操作会去调用public函数,如果没有这个回指指针XImpl就调用不了相应的函数在上面的方法一中有一个折中的方法就是把只有私有函数才会调用的非私有函数放到XImpl中这样就不需要一个回指指针了,这样的被调用的函数不一起放在XImpl的原因就是要给派生类覆盖.同理,方式2直接把所有的资源都放XImpl了更不需要回指指针了</p>
<p>现在考虑一下Pimpl的性能问题<br>1.最明显的就是内存分配需要的时间</p>
<pre><code class="cpp">//下面是可能的客户代码y.h与y.cpp
//1
#include&quot;x.h&quot;
class Y&#123;
    X x_;
&#125;;
Y::Y()&#123;&#125;
//上面要求X是明确可见的,所以有下面这种代码
//2,y.h
class X;
class Y&#123;
    X *px_;
&#125;;
//y.cpp
#include&quot;x.h&quot;
Y::Y():px_(new X)&#123;&#125;
Y::~Y()&#123;delete px_;px_=0;&#125;
//第2种方法很好地隐藏了X但如果程序里大量使用Y那动态分配内存可能降低程序的性能
</code></pre>
<p>2.其次是由于资源的由一个指针访问多了至少一层间接操作,同时空间上的开销也至少多了一个指针的开销,如果考虑到对齐多出来的空间是大于等于一个指针的大小的</p>
<h4 id="条款43-正确地使用const"><a href="#条款43-正确地使用const" class="headerlink" title="条款43:正确地使用const"></a>条款43:正确地使用const</h4><ul>
<li>void f(int x)与void f(const int x)对编译器来说是同一个函数，但后者在定义体当中仍不可修改x,如果同时定义上述两个函数编译会报错</li>
<li>但void f(int&amp;)与void f(const int&amp;)对编译器来说不一样</li>
<li>对于非内置类型的返回类型，一般加一个const修饰，以帮助客户检查出类似A+B&#x3D;C(实际想要操作A+B&#x3D;&#x3D;C)的错误</li>
</ul>
<h4 id="条款44-类型转换"><a href="#条款44-类型转换" class="headerlink" title="条款44:类型转换"></a>条款44:类型转换</h4><blockquote>
<ul>
<li>新形式的类型转化中,只有dynamic_cast与C语言不等价</li>
<li>如果没有虚函数,那dynamic_cast的操作都是错误的</li>
</ul>
</blockquote>
<h3 id="区分几大内存区域"><a href="#区分几大内存区域" class="headerlink" title="区分几大内存区域"></a>区分几大内存区域</h3><table>
<thead>
<tr>
<th>内存区域</th>
<th>特性和对象的生存期</th>
</tr>
</thead>
<tbody><tr>
<td>常量数据</td>
<td>常用于存储字符串和一些编译时就知道的常量。程序的整个生存期内数据都有效且只读,因为编译器可能会<br>对这个区域的数据进行一些特殊的存储优化,擅自修改可能会出现一些未定义的行为</td>
</tr>
<tr>
<td>栈</td>
<td>存自动变量。自动变量在定义时被立即构造,并在其作用域结束时被立即销毁。<br>栈内存的分配通常比动态内存快很多,因为每次栈的分配只涉及到栈指针的自增操作</td>
</tr>
<tr>
<td>自由存储</td>
<td>两种动态内存区域之一,<em>通过new&#x2F;delete来分配&#x2F;释放</em> 。<br>对象的生存周期可能小于所分配的的存储空间的生存期,因为这里的的对象不要求分配内存时立即进行初始化,销毁对象时也不要求立即归还空间</td>
</tr>
<tr>
<td>堆</td>
<td>另一种动态内存区域,<em>通过malloc&#x2F;free函数进行分配和释放</em>。堆还是不同于自由存储的,尽管可能有些地方默认的new和delete会调用malloc和free实现。但堆中的内存不能在自由内存中安全释放,反之亦然。也就是说new出来的内存不能用free安全释放。</td>
</tr>
<tr>
<td>全局&#x2F;静态</td>
<td>程序启动时,全局和静态变量就已经分配了内存,但只有程序执行时才会进行初始化。<br>对于跨域多个编译单元的全局变量,它们的初始化顺序是未定义的,因此在管理时要特别小心它们之间的依赖性</td>
</tr>
</tbody></table>
<h3 id="实现自己特定的内存管理"><a href="#实现自己特定的内存管理" class="headerlink" title="实现自己特定的内存管理"></a>实现自己特定的内存管理</h3><blockquote>
<p>如果要重载operator new与operator delete,记得显式地将它们声明为static,虽然会默认它们是static但这样可以增加可读性,因为一个对象是由它的类创建的,而不是一个对象去创建的,所以operator new函数一定是早于对象它不可能是一个非静态的成员函数</p>
</blockquote>
<p>在此之前应该先了解一些placement new相关的知识,该方面的内容在Effective C++和More EffectiveC++中有详细描述</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Kuangbin-简单搜索</title>
    <url>/2021/07/20/Kuangbin-%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="简单搜索"><a href="#简单搜索" class="headerlink" title="简单搜索"></a>简单搜索</h1><p>[poj1321](##<a href="http://poj.org/problem?id=1321">POJ1321 – 棋盘问题 </a>)</p>
<h2 id="POJ1321-–-棋盘问题"><a href="#POJ1321-–-棋盘问题" class="headerlink" title="POJ1321 – 棋盘问题"></a><a href="http://poj.org/problem?id=1321">POJ1321 – 棋盘问题</a></h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>变版的八皇后问题，只不过棋盘不再规则只能在某些格子放棋子而已，思路不变。先假设前面k行已经摆好且没有相互矛盾，那在第k+1行就有摆和不摆两种选择，如果摆，那又有摆在哪一列的选择，用一个col数组记录前面哪些列已经用过了，如果col[x]的状态表示没有用过，那[k+1][x]就是一个可行的位置，把col[x]标记一下，然后继续向下一行探索。</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
bool col[10];//存哪些列用过来了,false表示没用过
char grid[10][10];//存图
int n, k, ans;
void dfs(int line, int num) &#123;//line表示现在在第几行，num表示前面填好了几个
    if (line==n||num == k) &#123;//行号最多n-1,到n肯定不行了
        if (num == k)//如果已经填好k个，总方案数加1
            ans++;
        return;
    &#125;
    for (int i = 0; i &lt; n; i++) &#123;
        //在该行填，将改行的每一列遍历一遍，看看哪些列可以填
        if (!col[i] &amp;&amp; grid[line][i] == &#39;#&#39;) &#123;
            col[i] = true;
            dfs(line + 1, num + 1);
            col[i] = false;//j
        &#125;
    &#125;
    //不在改行填，所以num没有加1
    dfs(line + 1, num);
&#125;
int main()
&#123;
    while (cin &gt;&gt; n &gt;&gt; k) &#123;
        if (n == k &amp;&amp; n == -1)
            break;
        memset(col, false, sizeof(col));//初始化
        ans = 0;
        for (int i = 0; i &lt; n; i++) &#123;
            cin &gt;&gt; grid[i];
        &#125;
        dfs(0, 0);//从第0行开始，已经填好0个
        cout &lt;&lt; ans &lt;&lt; endl;
    &#125;
    return 0;
&#125;
</code></pre>
<h2 id="POJ3278-3278-–-Catch-That-Cow-poj-org"><a href="#POJ3278-3278-–-Catch-That-Cow-poj-org" class="headerlink" title="[POJ3278](3278 – Catch That Cow (poj.org))"></a>[POJ3278](<a href="http://poj.org/problem?id=3278">3278 – Catch That Cow (poj.org)</a>)</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>该题注意剪枝，不让会RE（虽然我用的map），剪枝不可将x+1&gt;K和x*2&gt;k的情况剪掉，例如100-&gt;199</p>
<p>另外由于时间卡得比较紧，数量比较大所以不能用map，用map会TE</p>
<h2 id="poj3279"><a href="#poj3279" class="headerlink" title="poj3279"></a><a href="http://poj.org/problem?id=3279">poj3279</a></h2><p>题意大概说的是给定一个m*n的01矩阵，每次去翻一个位置周围四个方向的位置都会翻转，问能不能翻到全是0，能的话输出字典序最小的翻法</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>这是遇到的第一个枚举题，二进制枚举，首先确定的是每个位置只有翻和不翻两种情况，翻两次等于没翻，翻奇数次等于一次。如果去考察每一个位置的翻的情况就会有2^mn^次结果，显然时间超限，观察（看博客）易得出规律——&#x3D;&#x3D;假设第一行的状态确定（就是第一行哪些位置翻不翻确定，确定之后会得到第一行确定的状态，哪些位置是0哪些是1），从第二行开始扫描，如果发现该位置上头上的位置为1那该位置一定要翻，因为头上的位置上左右都确定了&#x3D;&#x3D;，以此扫描完整个数组，最后再对最后一行做一个检查，如果有1则不行，因为现在只能由下一行来翻转该位置，但没有下一行。</p>
<blockquote>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
using namespace std;
const int maxn = 20;
int n, m;
int maze[maxn][maxn];
int grid[maxn][maxn];
int ans[maxn][maxn];
int dir[5][2] = &#123; &#123;0,0&#125;,&#123;1,0&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;0,-1&#125; &#125;;
bool legal(int x, int y) &#123;
    return (x &gt;= 0 &amp;&amp; x &lt; n&amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m);
&#125;
void flip(int x, int y) &#123;
    ans[x][y] = 1;
    int nx, ny;
    for (int i = 0; i &lt; 5; i++) &#123;
        nx = x + dir[i][0];
        ny = y + dir[i][1];
        if (legal(nx, ny)) &#123;
            grid[nx][ny] ^= 1;
        &#125;
    &#125;
&#125;
void solve() &#123;
    for (int i = 0; i &lt; n; i++) &#123;
        for (int j = 0; j &lt; m; j++) &#123;
            printf(&quot;%d%c&quot;, ans[i][j], &quot; \n&quot;[j == (m - 1)]);
        &#125;
    &#125;
&#125;
int main() &#123;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 0; i &lt; n; i++) &#123;
        for (int j = 0; j &lt; m; j++) &#123;
            scanf(&quot;%d&quot;, &amp;maze[i][j]);
        &#125;
    &#125;
    int end = 1 &lt;&lt; m;
    int bsk;
    bool ok = true;
    for (int i = 0; i &lt; end; i++) &#123;
        ok = true;
        bsk = i;
        memcpy(grid, maze, sizeof(maze));
        memset(ans, 0, sizeof(ans));
        for (int k = 0; k &lt; m; k++) &#123;
            if (bsk &amp; 1)
                flip(0, k);
            bsk &gt;&gt;= 1;
        &#125;
        for (int j = 1; j &lt; n; j++) &#123;
            for (int k = 0; k &lt; m; k++) &#123;
                if (grid[j - 1][k])
                    flip(j, k);
            &#125;
        &#125;
        for (int k = 0, j = n - 1; k &lt; m; k++) &#123;
            if (grid[j][k]) &#123;
                ok = false;
                continue;
            &#125;
        &#125;
        if (ok) &#123;
            solve();
            break;
        &#125;
    &#125;
    if (!ok)
        printf(&quot;IMPOSSIBLE\n&quot;);
    return 0;
&#125;
</code></pre>
</blockquote>
<h2 id="POJ1426-–-Find-The-Multiple"><a href="#POJ1426-–-Find-The-Multiple" class="headerlink" title="POJ1426 – Find The Multiple "></a><a href="http://poj.org/problem?id=1426">POJ1426 – Find The Multiple </a></h2><p>题意大概是给一个数字n,找出一个n的十进制倍数m，m只能由01组成</p>
<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>虽然这道题说m不超过100位，但用unsigned long long过了，要是完全按照题意的话就还要处理大数问题，看其它文章好像也没有很好的可以解决，就直接当unsigned long long 过了</p>
<p>bfs和dfs都可以，dfs注意判断不要溢出,当然由于n比较小可以先得出200个结果打表然后再过，因为可能搜索会超时，时间卡得较紧</p>
<pre><code class="c++">#include&lt;iostream&gt;
#include&lt;queue&gt;
using namespace std;

int n;
typedef unsigned long long ull;
void bfs() &#123;
    queue&lt;ull&gt; que;
    que.push(1);

    while (!que.empty()) &#123;
        ull tmp = que.front();
        que.pop();
        if (tmp % n == 0) &#123;
            cout &lt;&lt; tmp &lt;&lt; endl;
            return;
        &#125;
        que.push(tmp * 10);
        que.push(tmp * 10 + 1);
    &#125;
&#125;
int main()
&#123;
    while (cin &gt;&gt; n&amp;&amp;n) &#123;
        bfs();
    &#125;
    return 0;
&#125;
</code></pre>
<h2 id="hdu2612"><a href="#hdu2612" class="headerlink" title="hdu2612"></a><a href="https://acm.dingbacode.com/showproblem.php?pid=2612">hdu2612</a></h2><p>题意为求两个人要到同一个@需要的最少步数乘以11.</p>
<h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>两边bfs之后将每次每一个@的步数相加，最后找出最小的那个@即可，但是要注意可能有些@是两个人都到不了的，其步数一直为0所以最后需要特殊判断一下，我legal判断x&lt;n写成x&lt;m了，RE了好几发━┳━　━┳━</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
vector&lt;string&gt; maze;
struct node &#123;
    int x, y, v;
    void init(int _x, int _y) &#123;
        x = _x;
        y = _y;
        v = 0;
    &#125;
    node(int _x, int _y) &#123;
        x = _x;
        y = _y;
        v = 0;
    &#125;
    node() &#123;&#125;
&#125;;
vector&lt;node&gt; End;
node yifenfi, mercki;
int n, m;
int dir[4][2] = &#123; &#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125; &#125;;
bool legal(int x, int y, vector&lt;string&gt;&amp; grid) &#123;
    return (x &gt;= 0 &amp;&amp; x &lt; n&amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m&amp;&amp; grid[x][y] != &#39;#&#39;);
&#125;
void bfs(node&amp; start) &#123;
    vector&lt;string&gt; grid(maze.begin(), maze.end());
    int step[205][205];
    memset(step, 0, sizeof(step));
    queue&lt;node&gt; que;
    grid[start.x][start.y] = &#39;#&#39;;
    que.push(start);
    while (!que.empty()) &#123;
        node tmp = que.front();
        que.pop();
        int nx, ny;
        for (int i = 0; i &lt; 4; i++) &#123;
            nx = tmp.x + dir[i][0];
            ny = tmp.y + dir[i][1];
            if (legal(nx, ny, grid)) &#123;
                step[nx][ny] = step[tmp.x][tmp.y] + 1;
                grid[nx][ny] = &#39;#&#39;;
                que.push(node(nx, ny));
            &#125;
        &#125;
    &#125;
    for (auto&amp; i : End) &#123;
        i.v += step[i.x][i.y];
    &#125;
&#125;
int main() &#123;

    while (cin &gt;&gt; n &gt;&gt; m&amp;&amp;n&gt;=2&amp;&amp;m&gt;=2) &#123;
        string s;
        maze.clear();
        End.clear();
        yifenfi.x = yifenfi.y = 0;
        mercki.x = mercki.y = 0;
        for (int i = 0; i &lt; n; i++) &#123;
            cin &gt;&gt; s;
            for (int j = 0; j &lt; m; j++) &#123;
                if (s[j] == &#39;@&#39;) &#123;
                    End.push_back(node(i, j));
                &#125;
                else if (s[j] == &#39;Y&#39;) &#123;
                    yifenfi.init(i, j);
                &#125;
                else if (s[j] == &#39;M&#39;)
                    mercki.init(i, j);
            &#125;
            maze.push_back(s);
        &#125;
        bfs(yifenfi);
        bfs(mercki);
        int Min = 10000;
        for (auto i : End) &#123;
            if (Min &gt; i.v&amp;&amp;i.v!=0) &#123;
                Min = i.v;
            &#125;
        &#125;
        cout &lt;&lt; Min * 11 &lt;&lt; endl;
    &#125;
    return 0;
&#125;
</code></pre>
<h2 id="hdu1401"><a href="#hdu1401" class="headerlink" title="hdu1401 "></a><a href="https://acm.dingbacode.com/showproblem.php?pid=1401">hdu1401 </a></h2><p>题意为给定一个8 $\times$ 8的棋盘，给定四个棋子的起始坐标和终止坐标，问是否能在8步以内从起始状态到终点状态</p>
<h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p>第一道双向广搜题，棋盘布局问题的一个重点是怎么查重，这就需要将每一步之后的棋盘状态给表示出来，这道题给的是一个8 $\times$ 8的棋盘，一共64个位置，因此整个棋盘的状态可以用一个long long数据来存储，64个bit位上分别可以对应棋盘上一个点是否摆放了棋子，再者还需要存储该状态是第几步得到，为了方便快速取出棋子，需要一个二维数组来存放四颗棋子的状态。中间再使用map来标记哪些状态已经到达，该map能记录每个状态需要多少步到达。</p>
<pre><code class="c++">#include&lt;bits/stdc++.h&gt;
#include&lt;unordered_map&gt;
using namespace std;
typedef unsigned long long ull;
struct maze &#123;
    int chess[4][2];//棋子状态
    ull hash;//每个状态独有的hash值
    bool grid[8][8];//棋盘状态
&#125;Front, Tail;//定义开始棋盘与终点棋盘
int dir1[4][2] = &#123; &#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125; &#125;;
int dir2[4][2] = &#123; &#123;-2,0&#125;,&#123;2,0&#125;,&#123;0,2&#125;,&#123;0,-2&#125; &#125;;//遇到旁边有棋子的移动步数

ull ToHash(maze&amp; m) &#123;
    ull re = 0;
    //将棋盘上每一个点的状态对应到long long 上每一个位
    for (int i = 0; i &lt; 8; i++) &#123;
        for (int j = 0; j &lt; 8; j++) &#123;
            re = re &lt;&lt; 1 | m.grid[i][j];
        &#125;
    &#125;
    return re;
&#125;
int solve(queue&lt;maze&gt;&amp; que, unordered_map&lt;ull, int&gt;&amp; mp1, unordered_map&lt;ull, int&gt;&amp; mp2) &#123;
    //该函数相当于while循环当中的一次que.front()...que.push()...
    maze tmp = que.front();
    que.pop();
    for (int i = 0; i &lt; 4; i++) &#123;
        //第一重遍历，遍历四颗棋子
        int x = tmp.chess[i][0], y = tmp.chess[i][1];
        for (int j = 0; j &lt; 4; j++) &#123;
            //第二重遍历，遍历四个方向
            int nx = x + dir1[j][0];
            int ny = y + dir1[j][1];
            if (nx &gt;= 0 &amp;&amp; nx &lt; 8 &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; 8 &amp;&amp; tmp.grid[nx][ny] == false) &#123;//先尝试移动一步
                maze next = tmp;
                next.grid[nx][ny] = true;
                next.grid[x][y] = false;//下一个状态里面,(x,y)已经变成了false，不用担心走回头路，因为当前棋盘的hash已经记录在map里面了
                next.hash = ToHash(next);
                next.chess[i][0] = nx, next.chess[i][1] = ny;
                if (!mp1.count(next.hash)) &#123;//如果变化后是以前没有的状态
                    mp1[next.hash] = mp1[tmp.hash] + 1;
                    que.push(next);
                    if (mp2.count(next.hash))//如果变化后与终点变过来的某一状态相同，则已经找到答案
                        return mp1[next.hash] + mp2[next.hash];
                &#125;
            &#125;
            else if (nx &gt;= 0 &amp;&amp; nx &lt; 8 &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; 8 &amp;&amp; tmp.grid[nx][ny] == true) &#123;//走一步遇到了棋子
                 nx = x + dir2[j][0];
                 ny = y + dir2[j][1];
                 if (nx &gt;= 0 &amp;&amp; nx &lt; 8 &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; 8 &amp;&amp; tmp.grid[nx][ny] == false) &#123;//尝试走两步，后面代码同上
                     maze next = tmp;
                     next.grid[nx][ny] = true;
                     next.grid[x][y] = false;
                     next.hash = ToHash(next);
                     next.chess[i][0] = nx, next.chess[i][1] = ny;
                     if (!mp1.count(next.hash)) &#123;
                         mp1[next.hash] = mp1[tmp.hash] + 1;
                         que.push(next);
                         if (mp2.count(next.hash))
                             return mp1[next.hash] + mp2[next.hash];
                     &#125;
                 &#125;
            &#125;
        &#125;
    &#125;
    return -1;//四颗棋子遍历完发现都没有return，返回失败标记
&#125;
int bfs() &#123;
    queue&lt;maze&gt; que1, que2;
    que1.push(Front);
    que2.push(Tail);
    unordered_map&lt;ull, int&gt; mp1, mp2;
    mp1[Front.hash] = 0;
    mp2[Tail.hash] = 0;
    //两个队列与map的初始化，que1代表从起始状态遍历，que2从终止状态开始，mp1和mp2分别对应两者出现过的状态
    while (que1.size() &amp;&amp; que2.size()) &#123;
        if (mp1[Front.hash] + mp2[Tail.hash] &gt; 8)//如果两者的步数和已经超过8，返回失败
            return -1;
        int re;
        if (que1.size() &lt;= que2.size()) &#123;//size小的优先，这样就能达到双端遍历的效果
            re = solve(que1, mp1, mp2);
        &#125;
        else
            re = solve(que2, mp2, mp1);
        if (re != -1 &amp;&amp; re &lt;= 8)
            return re;
        if (re &gt; 8)
            return -1;
    &#125;
    return -1;
&#125;
int main()
&#123;
    int x, y;
    while (cin &gt;&gt; x &gt;&gt; y) &#123;
        x--, y--;
        memset(Front.grid, false, sizeof(Front.grid));
        memset(Tail.grid, false , sizeof(Tail.grid));
        Front.grid[x][y] = true;
        Front.chess[0][0] = x, Front.chess[0][1] = y;
        for (int i = 1; i &lt;= 3; i++) &#123;
            cin &gt;&gt; x &gt;&gt; y;
            x--, y--;
            Front.grid[x][y] = true;
            Front.chess[i][0] = x, Front.chess[i][1] = y;
        &#125;
        for (int i = 0; i &lt; 4; i++) &#123;
            cin &gt;&gt; x &gt;&gt; y;
            x--, y--;
            Tail.grid[x][y] = true;
            Tail.chess[i][0] = x, Tail.chess[i][1] = y;
        &#125;
        Front.hash = ToHash(Front);
        Tail.hash = ToHash(Tail);
        if (Front.hash == Tail.hash)
            cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;
        else &#123;
            int re = bfs();
            if (re == -1)
                cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;
            else
                cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<h2 id="hdu1495"><a href="#hdu1495" class="headerlink" title="hdu1495 "></a><a href="https://acm.dingbacode.com/showproblem.php?pid=1495">hdu1495 </a></h2><p>题意是给定三个杯子，第一个被子装满水，通过这三个被子互相倒进倒出能否把水平分</p>
<h3 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3><p>题目的要求是出现一个杯子为空，其它两个杯子装等量的水的情况（我第一次理解成了只要可以两个人喝到相同的水就行了，于是一边倒水一边喝，wa了老久━┳━　━┳━)。搜索的重点就是去记录状态，这道题将三个杯子当前的装水量为一个状态进行搜索，所以开一个三维的vis[s的水量][n的水量][m的水量]bool数组来记录当前状态，每一个状态有6个方向分别是s-&gt;n,s-&gt;m,n-&gt;s,n-&gt;m,m-&gt;s,m-&gt;n(看起来代码长其实很多都是重复操作)</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define MAXN 105
bool vis[MAXN][MAXN][MAXN];
int s, n, m;
struct node &#123;
    int s, n, m, step;
&#125;;
node start;
node re;
int bfs() &#123;
    queue&lt;node&gt; que;
    memset(vis, false, sizeof(vis));
    vis[start.s][start.n][start.m] = true;
    que.push(start);
    while (!que.empty()) &#123;
        node tmp = que.front();
        que.pop();
        if (tmp.s == 0 &amp;&amp; tmp.m == tmp.n || tmp.m == 0 &amp;&amp; tmp.s == tmp.n || tmp.n == 0 &amp;&amp; tmp.s == tmp.m)
        &#123;
            return tmp.step;
        &#125;
        //s--&gt;n
    
        if (tmp.s &amp;&amp; n &gt; tmp.n) &#123;//s有水并且n还没灌满
            node x = tmp;
            if (tmp.s &gt; n - tmp.n) &#123;//s的水比n现在能装的还多
                x.s -= n - tmp.n;
                x.n = n;
                x.step += 1;
                if (!vis[x.s][x.n][x.m]) &#123;
                    que.push(x);
                    vis[x.s][x.n][x.m] = true;
                &#125;
            &#125;
            else &#123;
                x.s = 0;
                x.n += tmp.s;
                x.step += 1;
                if (!vis[x.s][x.n][x.m]) &#123;
                    que.push(x);
                    vis[x.s][x.n][x.m] = true;
                &#125;
            &#125;
        &#125;
        //s--&gt;m
        if (tmp.s &amp;&amp; m &gt; tmp.m) &#123;//s有水并且m还没灌满
            node x = tmp;
            if (tmp.s &gt; m - tmp.m) &#123;//s的水比m现在能装的还多
                x.s -= m - tmp.m;
                x.m = m;
                x.step += 1;
                if (!vis[x.s][x.n][x.m]) &#123;
                    que.push(x);
                    vis[x.s][x.n][x.m] = true;
                &#125;
            &#125;
            else &#123;
                x.s = 0;
                x.m += tmp.s;
                x.step += 1;
                if (!vis[x.s][x.n][x.m]) &#123;
                    que.push(x);
                    vis[x.s][x.n][x.m] = true;
                &#125;
            &#125;
        &#125;
        //n--&gt;s
        if (tmp.n &amp;&amp; s &gt; tmp.s) &#123;//n有水并且s还没灌满
            node x = tmp;
            if (tmp.n &gt; s - tmp.s) &#123;//n的水比s现在能装的还多
                x.n -= s - tmp.s;
                x.s = s;
                x.step += 1;
                if (!vis[x.s][x.n][x.m]) &#123;
                    que.push(x);
                    vis[x.s][x.n][x.m] = true;
                &#125;
            &#125;
            else &#123;
                x.n = 0;
                x.s += tmp.n;
                x.step += 1;
                if (!vis[x.s][x.n][x.m]) &#123;
                    que.push(x);
                    vis[x.s][x.n][x.m] = true;
                &#125;
            &#125;
        &#125;
        //n--&gt;m
        if (tmp.n &amp;&amp; m &gt; tmp.m) &#123;//n有水并且m还没灌满
            node x = tmp;
            if (tmp.n &gt; m - tmp.m) &#123;//n的水比m现在能装的还多
                x.n -= m - tmp.m;
                x.m = m;
                x.step += 1;
                if (!vis[x.s][x.n][x.m]) &#123;
                    que.push(x);
                    vis[x.s][x.n][x.m] = true;
                &#125;
            &#125;
            else &#123;
                x.n = 0;
                x.m += tmp.n;
                x.step += 1;
                if (!vis[x.s][x.n][x.m]) &#123;
                    que.push(x);
                    vis[x.s][x.n][x.m] = true;
                &#125;
            &#125;
        &#125;
        //m--&gt;n
        if (tmp.m &amp;&amp; n &gt; tmp.n) &#123;//n有水并且n还没灌满
            node x = tmp;
            if (tmp.m &gt; n - tmp.n) &#123;//m的水比n现在能装的还多
                x.m -= n - tmp.n;
                x.n = n;
                x.step += 1;
                if (!vis[x.s][x.n][x.m]) &#123;
                    que.push(x);
                    vis[x.s][x.n][x.m] = true;
                &#125;
            &#125;
            else &#123;
                x.m = 0;
                x.n += tmp.m;
                x.step += 1;
                if (!vis[x.s][x.n][x.m]) &#123;
                    que.push(x);
                    vis[x.s][x.n][x.m] = true;
                &#125;
            &#125;
        &#125;
        //m--&gt;s
        if (tmp.m &amp;&amp; s &gt; tmp.s) &#123;//m有水并且s还没灌满
            node x = tmp;
            if (tmp.m &gt; s - tmp.s) &#123;//m的水比s现在能装的还多
                x.m -= s - tmp.s;
                x.s = s;
                x.step += 1;
                if (!vis[x.s][x.n][x.m]) &#123;
                    que.push(x);
                    vis[x.s][x.n][x.m] = true;
                &#125;
            &#125;
            else &#123;
                x.m = 0;
                x.s += tmp.m;
                x.step += 1;
                if (!vis[x.s][x.n][x.m]) &#123;
                    que.push(x);
                    vis[x.s][x.n][x.m] = true;
                &#125;
            &#125;
        &#125;
    &#125;
    return 0;
&#125;
int main()
&#123;
    while (cin &gt;&gt; s &gt;&gt; n &gt;&gt; m) &#123;
        if (s == n &amp;&amp; n == m &amp;&amp; s == 0)
            break;
        start.s = s, start.n = 0, start.m = 0;
        start.step = 0;
        if (s &amp; 1) &#123;
            cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;
        &#125;
        else &#123;
            int re = bfs();
            if (re) &#123;
                cout &lt;&lt; re &lt;&lt; endl;
            &#125;
            else
                cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<p><a href="http://poj.org/problem?id=3126">POJ3126 – Prime Path</a></p>
<p><em>2021.7.19</em></p>
<p>题意是给定一个起始的四位的素数和目标四位的素数，每一步可以变动一个位置上的数字，要求变动之后数字还是素数，且还是要四位数，求最少步数。</p>
<h3 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h3><p>最近做这个专题发现基本上都是问最少步数，也基本上都是bfs,这道题的状态可以直接由一个数字本身确定，由于范围较小，可以提前将所有的四位素数计算出来，方便后面判断。代码如下</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;queue&gt;
#include&lt;map&gt;
using namespace std;
bool prime[100000];//判断素数

int main()
&#123;
    for (int i = 2; i &lt; 100000; i++) &#123;
        if (!prime[i]) &#123;
            for (int j = 2; j * i &lt; 100000; j++) &#123;
                prime[i * j] = true;
            &#125;
        &#125;
    &#125;//埃氏筛
    
    int t, a, b;
    cin &gt;&gt; t;
    bool flag = false;
    while (t--) &#123;
        cin &gt;&gt; a &gt;&gt; b;
        queue&lt;int&gt;que;
        map&lt;int, int&gt; mp;//bfs的标记数组，mp[1000]=1表示1000y
        mp[a] = 0;
        que.push(a);
        while (!que.empty()) &#123;
            int tmp = que.front();
            que.pop();
            if (tmp == b) &#123;
                flag = true;
                break;
            &#125;
            //下面四个for循环分别对应修改四个位置上的数字
            for (int i = 0; i &lt; 10; i++) &#123;
                int num = tmp % 1000 + i * 1000;
                if (!prime[num] &amp;&amp; mp.count(num) == 0&amp;&amp;num&gt;1000) &#123;
                    mp[num] = mp[tmp] + 1;
                    que.push(num);
                &#125;
            &#125;
            for (int i = 0; i &lt; 10; i++) &#123;
                int num = tmp - ((tmp / 100) % 10) * 100 + i * 100;
                if (!prime[num] &amp;&amp; mp.count(num) == 0&amp;&amp;num&gt;1000) &#123;
                    mp[num] = mp[tmp] + 1;
                    que.push(num);
                &#125;
            &#125;
            for (int i = 0; i &lt; 10; i++) &#123;
                int num = tmp - ((tmp / 10) % 10) * 10 + i * 10;
                if (!prime[num] &amp;&amp; mp.count(num) == 0&amp;&amp;num&gt;1000) &#123;
                    mp[num] = mp[tmp] + 1;
                    que.push(num);
                &#125;
            &#125;
            for (int i = 0; i &lt; 10; i++) &#123;
                int num = tmp -(tmp%10) + i;
                if (!prime[num] &amp;&amp; mp.count(num) == 0&amp;&amp;num&gt;1000) &#123;
                    mp[num] = mp[tmp] + 1;
                    que.push(num);
                &#125;
            &#125;
        &#125;
        if (flag)
            cout &lt;&lt; mp[b]&lt;&lt;endl;
        else
            cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;
        

    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>Kuangbin-并查集</title>
    <url>/2021/07/20/Kuangbin-%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="HDU3038"><a href="#HDU3038" class="headerlink" title="HDU3038"></a><a href="https://acm.dingbacode.com/showproblem.php?pid=3038">HDU3038</a></h2><p><em>2021.7.22</em></p>
<p>题意是假设有一段序列a，长度为n,接下来有m条信息 ，l r x表示a[l]+…+a[r]的这段区间之和为x,问这m条信息中哪些是错误的。比如1 100 10–1 10 1–11 100 2,很明显11 100 2是错误的，因为1 100 10 与 1 10 1可以推出11 100为9</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>带权并查集的应用</strong>首先从题的例子来观察，如果[1,10]的和为100，[7,10]的和为28，那就能推出来[1,6]为72，注意这里不是[1,7]，因为a[7]是在[7,10]这段序列里的，现在我们建立一个带权并查集，rela[x]表示x到自己根节点的距离，1 10 100就可以表示为pre[10]&#x3D;1,rela[10]&#x3D;100。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 200005;
int pre[maxn];
int rela[maxn];
int Find(int x) &#123;
    if (x == pre[x])
        return pre[x];
    int f = Find(pre[x]);
    rela[x] += rela[pre[x]];
    pre[x] = f;
    return pre[x];
&#125;

void merge(int Min, int Max,int num) &#123;
    int fx = Find(Min);
    int fy = Find(Max);
    //合并有两种情况，可以去手推一下面两种情况得出两种情况的合并公式
    //假设进来的Min为5，Max为8
    //第一种情况：pre[8]=0,rela[8]=100,即有信息1 8 100,pre[5]=3,rela[5]=10,即已有信息4 5 10
    //那显然应该让pre[3]=0,那rela[3]应该怎么算呢
    
    //第二种情况：pre[8]=3,pre[5]=0，显然还是应该让pre[3]=0，但rela[3]怎么计算（建议画图理解）
    if (fx != fy) &#123;
        if (fx &lt; fy) &#123;
            pre[fy] = fx;
            rela[fy] = rela[Min] + num - rela[Max];
        &#125;
        else &#123;
            pre[fx] = fy;
            rela[fx] = rela[Max] - num - rela[Min];
        &#125;
    &#125;
&#125;
int n, m, ans;
int main() &#123;
    while (cin &gt;&gt; n &gt;&gt; m)
    &#123;
        ans = 0;
        int a, b, c;
        for (int i = 0; i &lt;= n+1; i++) &#123;
            pre[i] = i;
            rela[i] = 0;
        &#125;
        while (m--) &#123;
            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
            a--;//这里是为了前面说到的那种1 10 100和7 10 28应该推出来[1,6]为72，而不是[1,7]为28,因此假设根节点为x，子节点为y，则rela[y]表示的是(x,y]这段区间的和，即[x+1,y]的和
            if (Find(a) == Find(b)) &#123;//如果两点的祖先相同，那通过两者与根节点距离之差可以推出来两者的距离的，就能拿来与c比较
                if (rela[b] - rela[a] != c) &#123;//与已知信息矛盾，则错误信息数加一
                    ans++;
                    continue;
                &#125;
            &#125;
            else &#123;
                merge(a, b, c);
            &#125;
        &#125;
        cout &lt;&lt; ans &lt;&lt; endl;
    &#125;
    return 0;
&#125;
</code></pre>
<h2 id="POJ1417-–-True-Liars"><a href="#POJ1417-–-True-Liars" class="headerlink" title="POJ1417 – True Liars"></a><a href="http://poj.org/problem?id=1417">POJ1417 – True Liars</a></h2><p>题意为知道好人与坏人的个数为p1，p2，并且有n条信息，每条信息格式为 a 说 b是好人或者坏人，规定好人永远说实话，坏人永远说谎话，则根据n条信息与已知的人数，能否推出哪些人是好人。</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>&#x3D;&#x3D;带权并查集与dp&#x3D;&#x3D;这种n条信息的与并查集的题形式很像，首先要分析出 <strong>a b yes</strong> 的形式出现时，就代表a b是同一阵营的，<strong>a b no</strong> 则代表两者不同阵营（可以去列一下情况看看），利用带权并查集可以将人分成一颗一颗的并查集树。剩下的就是通过这些树看能不能唯一构造出符合条件的人数。</p>
<p>现在我们知道的只是一团一团的人，每一团里有两个阵营，但是并不知道每个团里哪个阵营是好人。</p>
<p>定义<strong>dp[i][j]:&#x3D;前i棵树恰好凑出j个人有多少种情况</strong>，如果最后dp[NumOfTree][p1]&#x3D;&#x3D;1,则说明有解。这道题虽然有dp但其实想到dp之后，dp的转移方程并不难，为dp[i][j]&#x3D;dp[i-1][j-第i棵树中与根同一阵营的人数]+dp[i-1][j-第i棵树与根不同阵营的人数]，从转移方程中也可以看出需要记录每一棵并查集树底下两个阵营的人数，因为要输出哪些人是好人，所以每棵树还需要记录底下哪些人跟自己是同一阵营的，哪些不是。</p>
<p>代码如下</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
using namespace std;

const int maxn = 1e3 + 5;
int pre[maxn];
vector&lt;int&gt; tree[maxn];//粗糙地记录根节点下有哪些节点
vector&lt;int&gt; same[maxn];//same[i]表树第i颗树里，与根节点相同阵营的节点编号
vector&lt;int&gt; differ[maxn];
int rela[maxn];//权数组，0为同一阵营，1为不同阵营
int SameNum[maxn];//SameNum[i]表示第i棵树里与根节点同一阵营的人数
int DifferNum[maxn];
int dp[maxn][maxn];
vector&lt;int&gt;ans;//存最后要输出哪些人
int n, p1, p2;
void init() &#123;
    for (int i = 1; i &lt;= p1 + p2; i++) &#123;
        pre[i] = i;
        same[i].clear();
        differ[i].clear();
        tree[i].clear();
    &#125;
    memset(rela, 0, sizeof(rela));//初始情况每个人与自己同一阵营
    memset(SameNum, 0, sizeof(SameNum));
    memset(DifferNum, 0, sizeof(DifferNum));
    memset(dp, 0, sizeof(dp));
    ans.clear();
&#125;

int Find(int x) &#123;
    if (pre[x] == x) &#123;
        return pre[x];
    &#125;
    int root = Find(pre[x]);
    rela[x] ^= rela[pre[x]];//带权并查集Find的套路操作，在找根的过程中要更新关系
    pre[x] = root;
    return pre[x];
&#125;

void merge(int x, int y, int r) &#123;
    int fx = Find(x);
    int fy = Find(y);
    if (fx != fy) &#123;
        pre[fx] = fy;
        rela[fx] = rela[x] ^ rela[y] ^ r;//带权并查集套路操作，使用^是应为只有0,1两种关系，其它多种关系情况要具体分析
    &#125;
&#125;

int main() &#123;
    ios::sync_with_stdio(false);
    cin.tie(0);
    while (cin &gt;&gt; n &gt;&gt; p1 &gt;&gt; p2) &#123;
        if (n == p1 &amp;&amp; p1 == p2 &amp;&amp; n == 0)
            break;
        init();//记得并查集每次要初始化
        for (int i = 0; i &lt; n; i++) &#123;
            int a, b;
            string s;
            cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;
            if (s == &quot;yes&quot;)
                merge(a, b, 0);
            else
                merge(a, b, 1);
        &#125;
        //好人与坏人一样多，肯定判断不了
        if (p1 == p2) &#123;
            cout &lt;&lt; &quot;no&quot; &lt;&lt; endl;
            continue;
        &#125;
        //将现在的森林第一步粗加工，使每个根节点先知道自己有哪些子孙
        for (int i = 1; i &lt;= p1 + p2; i++) &#123;
            int fa = Find(i);
            tree[fa].push_back(i);
        &#125;
        int cnt = 1;//用来给树编号
        //第二步加工，每棵树编号，并筛出两个阵营的人数与具体哪些人
        for (int i = 1; i &lt;= p1 + p2; i++) &#123;
            if (tree[i].size()) &#123;
                for (int j = 0; j &lt; tree[i].size(); j++) &#123;
                    if (rela[tree[i][j]] == 0) &#123;
                        SameNum[cnt]++;
                        same[cnt].push_back(tree[i][j]);
                    &#125;
                    else &#123;
                        DifferNum[cnt]++;
                        differ[cnt].push_back(tree[i][j]);
                    &#125;
                &#125;
                cnt++;
            &#125;
        &#125;

        dp[0][0] = 1;//dp初始定义，注意init里面已经将dp全置为0了
        //dp[i][j]:==前i棵树组出j个人的方式有多少种
        for (int i = 1; i &lt; cnt; i++) &#123;
            for (int j = 0; j &lt;= p1; j++) &#123;
                if (j &gt;= SameNum[i]) &#123;
                    dp[i][j] += dp[i - 1][j - SameNum[i]];
                &#125;
                if (j &gt;= DifferNum[i]) &#123;
                    dp[i][j] += dp[i - 1][j - DifferNum[i]];
                &#125;
            &#125;
        &#125;

        if (dp[cnt - 1][p1] != 1) &#123;//不唯一，或无解
            cout &lt;&lt; &quot;no&quot; &lt;&lt; endl;
        &#125;
        else &#123;
            for (int i = cnt - 1; i &gt;= 1; i--) &#123;
                //如果最后的结果有唯一解，说明该状态下的前一个状态也一定唯一，因此从后往前推
                if (p1 &gt;= SameNum[i] &amp;&amp; dp[i - 1][p1 - SameNum[i]] == 1) &#123;
                    for (int j = 0; j &lt; same[i].size(); j++) &#123;
                        ans.push_back(same[i][j]);
                    &#125;
                    p1 -= SameNum[i];
                &#125;
                else &#123;
                    for (int j = 0; j &lt; differ[i].size(); j++) &#123;
                        ans.push_back(differ[i][j]);
                    &#125;
                    p1 -= DifferNum[i];
                &#125;
            &#125;
            sort(ans.begin(), ans.end());//升序排列
            for (int i = 0; i &lt; ans.size();i++) &#123;
                cout &lt;&lt; ans[i] &lt;&lt; endl;
            &#125;
            cout &lt;&lt; &quot;end&quot; &lt;&lt; endl;

        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<h4 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h4><p>看到这种类型的信息要想到是不是可能用并查集，之后分析出怎么从给出的信息来确定两个节点的关系，为了方便后面的dp，中间有很多工作都是在去优化结构来使得访问方便，也是数据结构设计为使用方便的一个体现</p>
<h2 id="Connections-in-Galaxy-War-ZOJ-3261"><a href="#Connections-in-Galaxy-War-ZOJ-3261" class="headerlink" title="Connections in Galaxy War - ZOJ 3261"></a><a href="https://zoj.pintia.cn/problem-sets/91827364500/problems/91827368062">Connections in Galaxy War - ZOJ 3261</a></h2><p><em>2021.7.20</em></p>
<p>题目大意为给定点的数量，编号0到n-1，每个点有各自的权值，再给M条信息，哪两个点直接相连。现在有Q个操作，每个操作有两种情况，一种是Query a,查询与a连通的点权值最大编号最小的点，如果最大权值比a小则输出-1，否则输出找到的编号；第二种情况是Destroy a b,表示切断a 与 b直接相连的边。</p>
<!---more--->

<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

const int maxn = 1e4 + 5;

map&lt;pair&lt;int, int&gt;, bool&gt; mp;
struct node &#123;
    int a, b;
    int flag;
&#125;operation[maxn*5];
int pre[maxn];
int power[maxn];
int ans[maxn * 5];
int n, m, q;
void init() &#123;
    for (int i = 0; i &lt; n; i++) &#123;
        pre[i] = i;
    &#125;
&#125;
int Find(int x) &#123;
    return x == pre[x] ? x : (pre[x] = Find(pre[x]));
&#125;
void merge(int x, int y) &#123;
    int fx = Find(x);
    int fy = Find(y);
    if (fx != fy) &#123;
        if (power[fx] &gt; power[fy] || power[fx] == power[fy] &amp;&amp; fx &lt; fy)
            pre[fy] = fx;
        else
            pre[fx] = fy;
    &#125;
&#125;

int main()
&#123;
    ios::sync_with_stdio(0);
    cin.tie(0);
    int tag = 1;
    while (cin &gt;&gt; n) &#123;
        init();
        mp.clear();
        if (tag == 0)
            cout &lt;&lt; endl;
        else
            tag = 0;
        for (int i = 0; i &lt; n; i++)
            cin &gt;&gt; power[i];
        int t;
        cin &gt;&gt; t;
        while (t--) &#123;
            int a, b;
            cin &gt;&gt; a &gt;&gt; b;
            if (a &gt; b)
                swap(a, b);
            mp[&#123;a, b&#125;] = true;
        &#125;
        cin &gt;&gt; q;
        for (int i = 0; i &lt; q; i++) &#123;
            string s;
            int a, b;
            cin &gt;&gt; s;
            if (s == &quot;query&quot;) &#123;
                cin &gt;&gt; a;
                operation[i] = &#123; a,0,1 &#125;;
            &#125;
            else &#123;
                cin &gt;&gt; a &gt;&gt; b;
                if (a &gt; b)
                    swap(a, b);
                operation[i] = &#123; a,b,0 &#125;;
                mp[&#123;a, b&#125;] = false;
                
            &#125;
        &#125;

        for (auto&amp; i : mp) &#123;
            if (i.second) &#123;
                merge(i.first.first, i.first.second);
            &#125;
        &#125;
        int cnt = 0;
        for (int i = q - 1; i &gt;= 0; i--) &#123;
            if (operation[i].flag == 0) &#123;
                merge(operation[i].a, operation[i].b);
            &#125;
            else &#123;
                int tmp = Find(operation[i].a);
                if (power[tmp] &gt; power[operation[i].a] &amp;&amp; tmp != operation[i].a)
                    ans[cnt++] = tmp;
                else
                    ans[cnt++] = -1;
            &#125;
        &#125;
        for (int i = cnt - 1; i &gt;= 0; i--) &#123;
            cout &lt;&lt; ans[i] &lt;&lt; endl;
        &#125;

    &#125;
    return 0;
&#125;
</code></pre>
<h2 id="POJ2492-–-A-Bug’s-Life"><a href="#POJ2492-–-A-Bug’s-Life" class="headerlink" title="POJ2492 – A Bug’s Life "></a><a href="http://poj.org/problem?id=2492">POJ2492 – A Bug’s Life </a></h2><p><em>2021.7.20</em></p>
<p>题意是给定点的数量和关系数目，每个点都有一种性别，总共两种性别，在接下来的信息中表示两个点有互动，即两个点是异性的，判断给出的信息中是否出现了同性互动。</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p><strong>简单带权并查集的应用</strong> ，像这种关系只有两种的并查集可以通过异或来操作，其它情况也有相应的公式，这道题就是一行一行的扫描合并，只不过在合并过程当中如果发现已经连通要判断一下两者关系，如果两者与根节点的关系相同那两者就是同性。</p>
<!---more--->

<pre><code class="cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn = 2005;
int pre[maxn];
int rela[maxn];//关系数组，存的是节点与父亲节点的关系，而不是与根的关系，在Find那里要用到
int n, m;
int Case;
void init()
&#123;
    for (int i = 0; i &lt;= n; i++)
        pre[i] = i;
    //这里初始要将rela设为0表示自己与自己是同性的
    memset(rela, 0, sizeof(rela));
&#125;
int Find(int x) &#123;
    if (x == pre[x])
        return x;
    int root = Find(pre[x]);
    rela[x] ^= rela[pre[x]];//此时的pre[x]还是原来的父亲，由于是递归的，此刻父亲的父亲即pre[pre[x]]已经指向根节点了，而rela[pre[x]]就是此刻父亲节点与根节点的关系，由于要压缩路径需要把x的父亲指向root，因此x与root的关系可以又此刻的父亲pre[x]来搭建，就有了rela[x]^rela[pre[x]],因为这是一个只有01两种情况的并查集才用异或，其它情况就需要分析一下
    pre[x] = root;//关系确定好后改变自己的父亲节点
    //因此每一次调用Find都会更新出x与root的关系
    return root;
&#125;
inline void merge(int x, int y, int flag) &#123;
    int fx = Find(x);
    int fy = Find(y);
    if (fx != fy) &#123;
        pre[fx] = fy;
        rela[fx] = rela[x] ^ rela[y] ^ flag;//套路，可以枚举一下情况看看是不是对的。其实也能理解肯定需要知道x与fx的关系和y与fy的关系，然后通过x与y的关系flag将fx与fy联系起来，只不过这里是恰好用到了异或，其它情况不一定是异或但肯定需要这三个数据
    &#125;
&#125;
int main()
&#123;
    scanf(&quot;%d&quot;, &amp;Case);
    int id = 1;
    while (Case--) &#123;
        printf(&quot;Scenario #%d:\n&quot;, id++);
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        init();
        bool flag = true;
        while (m--) &#123;
            int a, b;
            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
            if (!flag)
                continue;
            if (Find(a) == Find(b) &amp;&amp; rela[a] == rela[b]) &#123;//同祖先，与祖先的关系还相同
                flag = false;
            &#125;
            else &#123;
                merge(a, b, 1);
            &#125;
        &#125;
        if (flag) &#123;
            printf(&quot;No suspicious bugs found!\n\n&quot;);
        &#125;
        else &#123;
            printf(&quot;Suspicious bugs found!\n\n&quot;);
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<h2 id="POJ2912-–-Rochambeau"><a href="#POJ2912-–-Rochambeau" class="headerlink" title="POJ2912 – Rochambeau"></a><a href="http://poj.org/problem?id=2912">POJ2912 – Rochambeau</a></h2><p><em>2021.7.20</em></p>
<p>题意是给定人数和信息数，这些人可以被分成三组，三组的关系就是石头剪刀布的关系，相互克制，一个组的人永远出一个手势，但所有人当中有一个裁判会随便出，在接下来的信息当中能否判断谁是裁判，并输出最少判断出裁判是谁是在第几条信息之后，如果无法判断或者有矛盾的情况分别判断出来。</p>
<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p><strong>枚举加并查集</strong> 首先可以确定的是没有裁判的话就不会有矛盾出现，因为三组人分别只会出自己那组的手势，<strong>也就是说裁判会导致矛盾的出现</strong>，那我们可以去枚举每个编号，第一层for循环用来枚举编号，并且每次都要init并查集，每条信息是以结构体存储的，第二层for枚举所有的边，用与该节点无关的边建立并查集，如果还是出现了矛盾那该节点就肯定不是裁判，记录可能是裁判的个数，最后判断是不是恰好为1,为0就是Impossible,大于1则无法判断。</p>
<p>最后是要判断在第几行可以得出裁判，因为要判断n-1个人都不是裁判，因此最少行应该是判断出n-1个人不是裁判里最长的那个信息，具体参见代码</p>
<pre><code class="cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 505;
int pre[maxn];
int rela[maxn];
struct node &#123;
    int x, y;
    char flag;//本题采用的是离线操作，需要存储每条边的信息
&#125;r[2005];
int n, m;
int Case;
void init()
&#123;
    for (int i = 0; i &lt;= n; i++)
        pre[i] = i;
    memset(rela, 0, sizeof(rela));
&#125;
int Find(int x) &#123;
    if (x == pre[x])
        return x;
    int root = Find(pre[x]);
    rela[x] = (rela[x] + rela[pre[x]]) % 3;//公式得出详见下图
    pre[x] = root;
    return root;
&#125;
inline bool merge(int x, int y,int flag) &#123;
    int fx = Find(x);
    int fy = Find(y);
    if (fx != fy) &#123;
        pre[fx] = fy;
        rela[fx] = (rela[y] + flag - rela[x] + 3) % 3;//公式得出详见下图
        return true;
    &#125;
    else &#123;
        if ((rela[x] - rela[y] + 3) % 3 != flag)
            return false;
    &#125;
&#125;
int main()
&#123;
    while (cin &gt;&gt; n &gt;&gt; m) &#123;

        for (int i = 1; i &lt;= m; i++) &#123;
            int a, b;
            char c;
            cin &gt;&gt; r[i].x &gt;&gt; r[i].flag &gt;&gt; r[i].y;
        &#125;
        int ans = 0;
        int pos, lstline = 0;
        for (int i = 0; i &lt; n; i++) &#123;
            init();
            bool flag = true;
            for (int j = 1; j &lt;=m; j++) &#123;
                if (r[j].x == i || r[j].y == i)
                    continue;
                if (!merge(r[j].x, r[j].y, r[j].flag == &#39;=&#39; ? 0 : (r[j].flag == &#39;&lt;&#39; ? 1 : 2))) &#123;
                    flag = false;
                    lstline = max(j, lstline);//记录每次判断出来哪个编号不是裁判需要的最大边的编号
                    break;
                &#125;
            &#125;
            if (flag) &#123;
                ans++;//记录裁判人数
                pos = i;//记录裁判编号
            &#125;
        &#125;

        if (ans == 0) &#123;
            printf(&quot;Impossible\n&quot;);
        &#125;
        else if (ans == 1) &#123;
            printf(&quot;Player %d can be determined to be the judge after %d lines\n&quot;,pos,lstline);
        &#125;
        else &#123;
            printf(&quot;Can not determine\n&quot;);
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<h2 id="POJ1733-–-Parity-game"><a href="#POJ1733-–-Parity-game" class="headerlink" title="POJ1733 – Parity game"></a><a href="http://poj.org/problem?id=1733">POJ1733 – Parity game</a></h2><p><em>2021.7.23</em></p>
<p>这道题跟how many wrong那道题很像,题意是一个01序列最多能满足到下列第几条信息</p>
<p>每条信息由a b s组成，表示[a,b]这段区间内1的个数为偶数或者奇数个</p>
<h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p><strong>带权并查集处理区间关系与离散化处理数据</strong>。思路也跟那道题很像，只不过那道题的关系更偏向于一种距离。容易发现如果[a,b]这段区间内的1为偶数个，那么</p>
<p>[1,b]与[1,a-1]含有的1的个数奇偶性是相同的，反之则相反，这就能将a,b建立起一种关系了，这个关系就是并查集需要维护的，另外的就是这道题的N开得很大，但实际数字比较少，直接开一个Pre[N]会爆空间，对数据进行一个离散化的处理即可。即假设有数据10 2 8 4 100000000，先用一个数组把这些数据存起来，之后就假设按照升序排序，那就应该是[2,4,8,10,100000000],只需要开一个pre[4]即可，利用一个中间函数Query(int)将数字映射到相应的位置即可，即假设要让100000000的根为2,那实际的操作就是pre[Query(100000000)]&#x3D;pre[Query(2)],即pre[5]&#x3D;pre[1]。最后有可能下面所有信息都能满足，这个地方wa了一次┑(￣Д ￣)┍</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 1e4 + 5;
int pre[maxn];
int pos[maxn];//离散映射数组，pos[i]表示第i大的数字
int rela[maxn];
int n, m;
int cnt = 0;
struct node &#123;
    long long a, b;
    int flag;
&#125;info[maxn];//离线操作,存储信息，一方面是离散化需要得到所有数据，一方面是就算之前能判断出结果还是需要读掉后面的数据。
int num[maxn * 2];//离散操作需要的数组，因为该数组会先存好所有数据，每条信息两个数字，开到maxn*2
//离散化函数
void decret() &#123;
    sort(num, num + m * 2);//先排序
    for (int i = 0; i &lt; m * 2; i++) &#123;
        if (!i || num[i] != num[i - 1]) &#123;//后面这个判断是去掉那些重复的数字，防止[1,2,2,2]这种情况将2多次存到pos里面
            pos[cnt++] = num[i];
        &#125;
    &#125;
&#125;
int Query(long long x) &#123;
    return lower_bound(pos,pos+cnt, x) - pos;//x在pos中的位置就能代表x
&#125;
int Find(int x) &#123;

    if (x == pre[x])
        return pre[x];
    int root = Find(pre[x]);
    rela[x] ^= rela[pre[x]];
    pre[x] = root;
    return pre[x];
&#125;
void merge(int x, int y,int flag) &#123;
    int fx = Find(x);
    int fy = Find(y);
    if (fx != fy) &#123;
        pre[fx] = fy;
        rela[fx] = rela[x] ^ rela[y] ^ flag;
    &#125;
&#125;
int main()
&#123;
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 0; i &lt; m * 2; i++) &#123;
        pre[i] = i;
    &#125;
    int id = 0;
    char s[10];
    
    for (int i = 0; i &lt; m; i++) &#123;
        cin &gt;&gt; info[i].a &gt;&gt; info[i].b &gt;&gt; s;
        if (s[0] == &#39;e&#39;) &#123;
            info[i].flag = 0;//如果是偶数个是不会改变之前的奇偶性的，而异或操作当中与0异或结果不变，所以用0代表是偶数个
        &#125;
        else
            info[i].flag = 1;
        info[i].b++;//跟那道题一样，边界交界处的处理
        num[id++] = info[i].a;
        num[id++] = info[i].b;
    &#125;
    decret();
    int i;
    for ( i = 0; i &lt; m; i++) &#123;
        if (Find(Query(info[i].a)) != Find(Query(info[i].b))) &#123;
            merge(Query(info[i].a),Query(info[i].b), info[i].flag);
        &#125;
        else if (rela[Query(info[i].a)] ^ rela[Query(info[i].b)] != info[i].flag)&#123;
            cout &lt;&lt; i &lt;&lt; endl;
            break;
        &#125;
    &#125;
    if (i == m)//万一人家能全满足呢
        cout &lt;&lt; i &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<h2 id="POJ1984-–-Navigation-Nightmare"><a href="#POJ1984-–-Navigation-Nightmare" class="headerlink" title="POJ1984 – Navigation Nightmare"></a><a href="http://poj.org/problem?id=1984">POJ1984 – Navigation Nightmare</a></h2><p>题意是有N个农场标号1到N，它们分布在一个二维平面上，两个农场之间只能由垂直或者水平的路连接.会给定m条信息 a b c s,表示农场从a往s方向走c的距离就能到达b，比如1 2 10 S表示2在1以南10的距离。需要处理输入a b index表示从前面的index条信息中能否得到a到b的曼哈顿距离,曼哈顿距离就是$|x_1-x_2|+|y_1-y_2|$​.(1,2)与(5,7)的曼哈顿距离就为9</p>
<h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p><strong>多重带权并查集</strong>，如果只有一条线上是很好分析的，就是假设1到2的距离知道，2到3的距离知道那很容易推出1到3的距离，典型的一个带权并查集就够了，现在这道题是在一个二维平面上，但它的连接方式只有水平跟垂直两种，所要求的曼哈顿距离也是水平跟垂直分开求的，所以可以开两个权值数组，用来分别维护水平和竖直两个直线方向上的关系即可求解。另外需要注意一下的是这道题的index是非递减的，之前每次处理一个输入就要清空并查集再重新建立就TE了，我也是看了别人的博客才看到的，之前就一直TE ┑(￣Д ￣)┍</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn = 4e4 + 5;
int n, m, k;
int pre[maxn];
int vertical[maxn];
int horisontal[maxn];
struct node &#123;
    int a, b;
    int h, v;
&#125;info[maxn];//离线操作，存储信息
void init() &#123;
    for (int i = 0; i &lt;= n; i++) &#123;
        pre[i] = i;
        vertical[i] = 0;
        horisontal[i] = 0;
    &#125;
    memset(info, 0, sizeof(0));//这里主要是为了把h与v置为0，但是放在静态区本来也会置为0
&#125;
int Find(int x) &#123;
    if (x == pre[x])
        return pre[x];
    int root = Find(pre[x]);
    //每次维护的时候两个方向的权值数组信息要同时维护
    vertical[x] += vertical[pre[x]];
    horisontal[x] += horisontal[pre[x]];
    pre[x] = root;
    return pre[x];
&#125;
void merge(int x, int y, int ver, int hor) &#123;
    int fx = Find(x);
    int fy = Find(y);
    if (fx ^ fy) &#123;
        pre[fx] = fy;
        //很简单的公式，画一下图就能推出来
        vertical[fx] = vertical[y] + ver - vertical[x];
        horisontal[fx] = horisontal[y] + hor - horisontal[x];
    &#125;
&#125;
int main()
&#123;

    cin &gt;&gt; n &gt;&gt; m;
    init();
    char s[10];
    int tmp;
    for (int i = 1; i &lt;= m; i++)
    &#123;
        cin &gt;&gt; info[i].a &gt;&gt; info[i].b;
        cin &gt;&gt; tmp &gt;&gt; s;
        if (s[0] == &#39;N&#39;) &#123;
            info[i].h = tmp;
        &#125;
        else if (s[0] == &#39;S&#39;) &#123;
            info[i].h = -tmp;//规定好方向
        &#125;
        else if (s[0] == &#39;E&#39;) &#123;
            info[i].v = tmp;
        &#125;
        else &#123;
            info[i].v = -tmp;
        &#125;

    &#125;
    cin &gt;&gt; k;
    int now = 1;
    while (k--) &#123;
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        for (; now &lt;= c; now++) &#123;//由于index非递减才有这个for循环
            merge(info[now].a, info[now].b, info[now].v, info[now].h);
        &#125;
        if (Find(a) != Find(b)) &#123;
            cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;
        &#125;
        else &#123;
            cout &lt;&lt; abs(vertical[a] - vertical[b]) + abs(horisontal[a] - horisontal[b]) &lt;&lt; endl;
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>Pratt-Parse的理解</title>
    <url>/2022/10/01/Pratt-Parse%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>这一小节要处理的问题是运算的优先级问题<br>这里先得出一个显然但是对后面理解很重要的结论:<br><strong>在构建出来的AST中每个节点的优先级一定是以自己为根的这这颗子树里最小的</strong><br>上面这个结论比较显然，但是这是在目前还没有引入()的情况下是正确的</p>
<p>对2*3+4*5来说，下面这样的AST之所以不对就是因为顶端*的优先级大于了+</p>
<pre><code>     *
    / \
   2   +
      / \
     3   *
        / \
       4   5
</code></pre>
<p>如果构建出这样的AST,那它就是对原表达的正确反映</p>
<p>在之前的处理当中,对expr的定义如下：</p>
<pre><code>expression: number
          | expression &#39;*&#39; expression
          | expression &#39;/&#39; expression
          | expression &#39;+&#39; expression
          | expression &#39;-&#39; expression
          ;

number:  T_INTLIT
         ;
</code></pre>
<p>如果修改expr定义如下:</p>
<pre><code>expression: additive_expression
    ;

additive_expression:
      multiplicative_expression
    | additive_expression &#39;+&#39; multiplicative_expression
    | additive_expression &#39;-&#39; multiplicative_expression
    ;

multiplicative_expression:
      number
    | number &#39;*&#39; multiplicative_expression
    | number &#39;/&#39; multiplicative_expression
    ;

number:  T_INTLIT
         ;
</code></pre>
<p>把expr分为了两大类,additive和multive,对于addtive来说它操作的最小单位是multive,而multive操作的最小单位是number,这就使得multive的expr掌握了对number的优先结合权,还是对2*3+4*5,现在它就会会被解析成multive_expr+multive_expr,也就是一个additive_expr,其实不管怎样到了最后整个expr一定是一个additive_expr,</p>
<p>参考文章:blog.huati365.com</p>
]]></content>
      <tags>
        <tag>基于项目acwj的编译器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows编程</title>
    <url>/2022/04/04/Windows%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="键盘与鼠标"><a href="#键盘与鼠标" class="headerlink" title="键盘与鼠标"></a>键盘与鼠标</h4><ul>
<li>WM_KEYDOWN中不区分大小写，字母的虚拟键码分别为’A’~’Z’对应的ascill码，如果要在这里判断是否CTRL，使用GetKeyState(VK_CONTROL)判断其值是否小于0即可，当按下的键可以产生一个可见字符时会发送一个WM_CHAR的消息，所以WM_KEYDOWN是先于WM_CHAR的</li>
<li>WM_CHAR中区分大小写,如果是CTRL+字符发送过来的wParam等于字母对应字母表的位置,CTRL+’A’以及CTRL+’a’为1，以此类推</li>
<li>Ctrl+鼠标左击的判断通过&amp;方式判断,如在WM_LBUTTONDOWN中判断是否按下Ctrl可以通过(wParam &amp; MK_CONTROL)判断</li>
<li>在鼠标移动过程中判断左键是否按下，(wParam &amp; MK_LBUTTON)</li>
</ul>
<h4 id="资源在Windows中的应用"><a href="#资源在Windows中的应用" class="headerlink" title="资源在Windows中的应用"></a>资源在Windows中的应用</h4><blockquote>
<p>由于这篇文章主要供自己在学习过程当中偶尔查阅使用，因此不展开对资源的代码生成，只是简单地记下一些使用方式</p>
</blockquote>
<ul>
<li>菜单资源:<br>1.窗口主菜单<br>2.菜单项(包含加速键标识于热键标识)<br>3.分隔符<br>手动的定义方式如下:</li>
</ul>
<pre><code class="cpp">#include&quot;Menu.h&quot;
My_menu MENU MOVEABLE         //My_menu是资源名字,用于载入菜单资源时使用,MENU是关键字，MOVEALBE是一种模式
｛POPUP &quot;文件（&amp;F）&quot;            //POPUP是说定义一个弹出式菜单 后面就是要显示的文字,&amp;符号后面的文字显示出来会有下划线
 ｛      MENUITEM     &quot;新建（&amp;N）&quot;，    IDM_NEW             MENUITEM     &quot;打开（&amp;O）&quot;，    IDM_OPEN
         MENUITEM     &quot;关闭（&amp;C）&quot;，    IDM_CLOSE
         MENUITEM     &quot;保存（&amp;S）&quot;，    IDM_SAVE
         MENUITEM     &quot;另存为（&amp;A）&quot;，    IDM_SAVEAS
         MENUITEM     SEPARATOR              //分隔符
        MENUITEM    “退出（&amp;X）”，    IDM_EXIT
        //IDM_NEW,IDM_CLOSE,...是在Menu.h里自己定义好的宏，是一个1~65535的整数，用以唯一标识一个菜单项
  ｝
｝
</code></pre>
<p>资源编辑器定义:<br>在VS里面可以点开资源文件，点开.rc文件，找到Menu点开里面的那个文件后就有一个GUI式的编写界面，按照提示编写即可，需要注意的是创建一个新的菜单项时如果想自定义它的ID对应的宏名字，可以点开旁边的属性，然后在ID那里输入想要的名字，VS会自动生成一个相应的宏,但要注意不要与已有的名字冲突</p>
<p><em>菜单的加载</em><br>1.创建窗口时加载</p>
<pre><code class="cpp">HMENU hMenu = LoadMenu(hInstance,MAKEINTERSOURCE(菜单ID))
//MAKEINTERSOURCE的作用跟一个数字转字符串的函数差不多
CreateWindow(...,hMenu,...);
</code></pre>
<p>2.动态加载</p>
<pre><code class="cpp">HMENU hMenu = LoadMenu(...);
SetMenu(hWnd,hMenu);
</code></pre>
<p><strong>与菜单项有关的一些函数</strong></p>
<pre><code class="cpp">//1．禁止或激活菜单项 
BOOL EnableMenuItem
(HMENU hmenu,
 UlNT wIDEnableItem,//被禁止或激活的菜单项标识
 UINT dwEnable
)
/*下面的一些宏是第三个参数*/
// MF_BYCOMMAND以ID值标识菜单项
// MF_ENABLED    激活菜单项
// MF_BYPOSITION    表明以位置标识菜单项
// MF_GRAYED    禁止菜单项并使其变灰显示
// MF_DISABLED    禁止菜单项

//2. 选中
DWORD CheckMenuItem
(
HMENU hmenu,    
UINT wIDCheckItem,    //菜单项标识
UINT dwCheck            //操作标识MF_CHECKED和MF_UNCHECKED
) 

//3.增加菜单项 
//末尾添加
BOOL AppendMenu
( HMENU hmenu,
  UINT dwFlags,        // 新加入的菜单项类型标识
  UINT dwIDNewItem,    // 新加入菜单项的ID
  LPCTSTR lpNewItem    // 新加入的菜单项内容
) 
AppendMenu (hmenu, MF_ENABLED,IDM_ABOUT, &quot;关于(&amp;A)&quot;)
//插入
BOOL InsertMenu
(HMENU hmenu,         //菜单句柄
UINT wPosition,    //指定新菜单项插入的位置
UINT dwFlag,         //新加入的菜单项的信息
UINT dwIDNweItem,    //新加入的菜单项的标识
LPCTSTR lpNewItem    //新插入的菜单项的内容
) 
InsertMenu (hmenu,IDM_EXIT,
MF_BYCOMMAND|MF_ENABLED,
IDM_PRINT,&quot;打印（&amp;P）&quot;);
/*还可以通过位置来插入,第二个参数为位置,第三个参数变为MF_BYPOSITION | MF_ENABLED*/

//4 删除菜单项
 BOOL DeleteMenu
(
HMENU hmenu,
UINT wPosition, //要删除的菜单项的位置
UINT dwFlag      //对wPosition的解释,使用方式与InsertMenu类似,
  )  
</code></pre>
]]></content>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习</title>
    <url>/2022/07/04/git%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>参考：<a href="https://zhuanlan.zhihu.com/p/356166493">https://zhuanlan.zhihu.com/p/356166493</a></p>
<p><strong>Git是一个分布式版本控制器，所以安装之后要配置自己的邮箱和用户名</strong><br><code>git config --global user.name &quot;...&quot;</code><br><code>git config --global user.email &quot;...&quot;</code></p>
<h4 id="三个区：工作区，版本区，暂存区"><a href="#三个区：工作区，版本区，暂存区" class="headerlink" title="三个区：工作区，版本区，暂存区"></a>三个区：工作区，版本区，暂存区</h4><ul>
<li>工作区：简单地理解为当前电脑上看到的情况</li>
<li>暂存区：介于版本与工作之间</li>
<li>版本库：工作区有一个隐藏目录.git，这是版本库</li>
</ul>
<p><code>git add ...</code>把文件放进暂存区<br><code>git commit ...</code>把暂存区内容提交到版本库</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h5><p><code>git init</code>会创建出一个.git文件夹，有默认的一些配置，不要修改<br><code>git add</code>与<code>git commit</code>前面已经说过<br><code>git status</code>查看状态，红色表示在工作区，绿色表示在暂存区，没有表示在版本库<br><em>git commit一定需要一个跟当前版本有关的文本信息才会提交成功,直接git commit会失败，常用的形式:</em><br><code>git commit -m &#39;....&#39;</code>表示将暂存区所有文件提交到版本库，并且附带信息’….’</p>
<h4 id="差异对比"><a href="#差异对比" class="headerlink" title="差异对比"></a>差异对比</h4><p><code>git diff</code> 比较暂存区与工作区<br><code>git diff -cached</code> 版本区与暂存区<br><code>git diff master</code> 版本去与工作区</p>
<h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p><code>git log</code>打印所有日志<br><code>git reflog</code>显示所有提交的id</p>
<h4 id="版本回退与穿梭"><a href="#版本回退与穿梭" class="headerlink" title="版本回退与穿梭"></a>版本回退与穿梭</h4><p><code>git reset --hard HEAD^</code>回退一次提交，两次就打两个^,三次就三个^,…，想要回退1000个版本或指定数量的话用<code>git reset --hard HEAD~1000</code>的形式<br><code>git reset --hard id</code>回退到指定id的版本<br><code>git reset HEAD</code>用版本库文件替换所有暂存区的文件<br><code>git checkout -- x.txt</code>用暂存区的指定文件区替换工作区的文件<br><code>git checkout HEAD x.txt</code>用版本库中的文件去替换暂存和工作区的文件</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>中断</title>
    <url>/2022/10/02/%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>关于中断的一些基础定义在计组里面已经学习过了，这里直接记一些跟操作系统有关的知识</p>
<h4 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h4><ol>
<li>外部中断</li>
</ol>
<p>来自CPU外部的中断，必须是某个硬件，所以又称硬件中断。<br>为了让CPU能跟踪到每一个中断，最直接的方法是每个要发生中断的硬件接一根线到CPU上，但是理论上外设的数量是无限的，且这样CPU的体积也会非常庞大，所以跟总线类似，CPU只有两根线来接收中断一根叫NMI(Non Maskable Interrupt)用于接收“灾难性”中断，一根叫INTR(INTeRrupt)用于接收普通中断。</p>
<ul>
<li>可屏蔽中断</li>
</ul>
<p>这类中断从INTR传入，如硬盘、网卡等发出来的中断，表示CPU可以不理会，因为它们不会让CPU宕机，可以通过设置EFLAGS的IF位来将所有外设的中断给屏蔽掉。另外这些中断是由外面的一个设备代理的，也可以操控这个设备提前对某些中断进行屏蔽。</p>
<ul>
<li>不可屏蔽中断</li>
</ul>
<p>从NMI进入CPU，这类中断表示系统发生了致命错误，一般见于以下三种原因：<br>    1. 内存读写错误<br>    2. 电源掉电<br>    3. 总线奇偶校验错误</p>
<ol start="2">
<li>内部中断</li>
</ol>
<ul>
<li>软中断</li>
</ul>
<p>由软件主动发起的的中断，来自软件所以叫软中断，下面是引起中断的指令。<br>    * int imm8 8位立即数表示256种中断<br>    * int3 调试断点指令,触发3号指令<br>    * into 中断溢出指令，触发4号指令，不过能否触发要看EFLAGS的OF是否为1<br>    * bound imm16&#x2F;imm32 检查数组越界指令,触发5号指令<br>    * ud2 未定义指令，触发6号指令</p>
<ul>
<li>异常</li>
</ul>
<p>是另一种CPU内部中断，由指令执行期间CPU内部错误产生所引起，由于是在运行时产生的所以不受IF位影响，无法向用户隐瞒</p>
<p>并不是所有的异常都很致命,按照轻重分为三种:<br>    1. Fault,故障。属于最轻的一种异常，发生此类异常时CPU将机器状态恢复到异常之前，调用中断处理程序完了依然返回导致fault的指令，比如缺页故障,等申请好物理页后又回来执行<br>    2. Trap,陷阱。表示软件掉进了CPU设下的陷阱导致停了下来，比如int3，为了能在中断处理完之后程序能继续运行，CPU会将中断的返回地址指向导致异常的下一条指令<br>    3. Abort,终止。一旦出现程序将会从进程表中被去除掉。</p>
<h4 id="中断描述符表"><a href="#中断描述符表" class="headerlink" title="中断描述符表"></a>中断描述符表</h4><p>IDT(Interrupt Descriptor Table)是保护模式下用于存储中断处理程序入口的表, 在进入保护模式前这个叫中断向量表(Interrupt Vector Table)。</p>
<p>IDT中不仅仅只有中断描述符，还可以有任务门和陷阱门描述符，这些存放于IDT中的描述符统称为门。<strong>段描述的是一片区域，门描述的是一段代码</strong></p>
<p>所有的描述符都是64位的，在高32位的TYPE字段和S位决定了这个描述符的类型，剩下的一些信息用来限定进入这个门的条件和描述门所通往的地方。</p>
<p>几种描述符的格式及布局如下：<br><img src="https://s2.loli.net/2022/07/20/Q8cxi2FhDOUl6y7.jpg" alt="任务门描述符.jpg"></p>
<p><img src="https://s2.loli.net/2022/07/20/MVWO68ohAl4RfUi.jpg" alt="中断门，陷阱门，调用门描述符.jpg"></p>
<p>简单介绍一下各个门：<br>    * 任务门：任务门和任务状态段(TSS)是Intel在硬件级别上提供的任务切换机制，在任务门中记录的是TSS的选择子。任务门可以存在于GDT，LDT，IDT中。<br>    * 中断门：包含中断处理程序所在段的选择子和段内偏移地址，此方式进入中断后<em>IF位自动置0，避免中断嵌套</em>。<strong>中断门只允许存在于IDT中</strong><br>    * 陷阱门：与中断门非常相似，只不过IF不会自动置0，也只存在于IDT中<br>    * 调用门：提供给用户进程进入特权级0的方式，其DPL为3。只能用jmp和call调用。可以安装在GDT和LDT中</p>
<p>在实模式下的IVT位置固定，在0~0x3ff是它的空间，共1024个字节，每个中断向量用4字节描述，共能存储256个向量，这些就是与IDT的不同，IDT<em>位置不固定，表项占8字节</em></p>
<p>由于位置不固定，所以CPU里有一个寄存器IDTR用以存放其位置，跟之前的GDTR类似。</p>
<h4 id="中断过程及保护"><a href="#中断过程及保护" class="headerlink" title="中断过程及保护"></a>中断过程及保护</h4><p>完整的中断过程分为CPU外和CPU内两部分<br>CPU外：外部设备的中断由中断代理设备接收处理，然后将处理后的信号给CPU<br>CPU内：CPU执行该中断向量号所对应的中断处理程序</p>
<p>CPU内执行中断的过程：</p>
<ol>
<li>处理器根据中断向量号定位中断门描述符</li>
<li>处理器进行特权级检查</li>
</ol>
<p>由于中断是通过中断向量号通知处理器的，而中断向量号只是一个整数，没有RPL，所以不涉及对RPL的检查，中断门的特权检查同调用门类似，CPL必须位于门描述的DPL和目标代码段的DPL之间，这是为了防止用户去调用一些只为内核服务的例程。</p>
<p>如果是int n,int3,into这类由用户程序引发的中断，在数值上CPL&lt;&#x3D;门描述符DPL,CPL&gt;目标代码段DPL,也就是说<strong>除了用户返回指令从高特权级返回，特权级转移只能发生于从低到高的情况</strong></p>
<p>如果是外设引起的中断，直接检查CPL和目标代码段的DPL</p>
<ol start="3">
<li>执行中断处理程序，将门描述符中的选择子加载到CS中，把里面的偏移量加载到EIP中<br>以上过程可概括成如下图片：<br><img src="https://s2.loli.net/2022/07/29/bKgJANBaewpoQih.jpg" alt="中断处理过程.jpg"></li>
</ol>
<p>总结一下执行的过程:首先是用户或硬件产生了一个中断，这个中断在被外部的中断控制器处理后会向CPU发出该中断对应的中断向量号，接着CPU会进行一个特权级的检查，通过之后CPU会从门描述符里得到对应的CS和IP，并将它们加载到对应寄存器</p>
<h4 id="中断发生时的压栈"><a href="#中断发生时的压栈" class="headerlink" title="中断发生时的压栈"></a>中断发生时的压栈</h4><p>发生中断后为了能返回，必须要存储一些必要的信息，这些都是CPU自动进行的。<br>如果在转移过程中发生了特权级的变换，那压栈的顺序如下：<br><img src="https://s2.loli.net/2022/07/29/lLVCQ2PhAWzkdxj.jpg" alt="中断的压栈.jpg"><br>其中的ERROR_CODE视某些中断类型确定是否存在，如果没有发生特权级的变化那就没有前面的SS_old与ESP_old</p>
<h4 id="可编程中断控制器-8259A"><a href="#可编程中断控制器-8259A" class="headerlink" title="可编程中断控制器 8259A"></a>可编程中断控制器 8259A</h4><p>8529A内部有两组寄存器，一组用来初始化(Initial Command Words,ICW)共四个，另一组寄存器是操作寄存器(Operation Command Words,OCW),共3个。</p>
<p>对8259A的编程也分为初始化和控制两个部分。</p>
<ul>
<li>首先是对其的初始化，诸如是否级联，确定起始中断向量号，设置结束模式等。编程的内容就是往这四个寄存器写入一段内容来设定其工作状态，<em>由于后面的某个设置可能会依赖于前面的设置，所以这里的编程往往有一定的先后顺序</em></li>
<li>另一部分是OCW来控制8259A，像屏蔽中断和中断结束都是往OCW写入内容实现的。OCW的发送顺序不固定。</li>
</ul>
<p>具体的一些关于ICW与OCW的内容这里不详述，只说一下用到的：</p>
<ul>
<li>无论8259A是否级联，ICW1与ICW2是必要的且要顺序写入</li>
<li>只有当ICW1中的SNGL为0时表示级联</li>
<li>只有当ICW1中的ICW4为1时才表示需要ICW4，x86系统下必须为1</li>
</ul>
<p>下面是一些代码<br>用纯汇编的风格进行一个中断处理：</p>
<pre><code class="asm">;段代码叫kernel.s，预定义一些由中断处理程序
[bits 32]
;宏定义，用于下面定义中断处理程序
%define ERROR_CODE nop
%define ZERO push 0

extern put_str
section .data
intr_str db &quot;interrupt occur!&quot;,0xa,0
global intr_entry_table
intr_entry_table:
;汇编的宏定义，表示宏VECTOR需要两个参数,这个VECTOR用来生成中断处理程序
%macro VECTOR 2
section .text
intr%1entry:

;当CPU进入到这里的时候已经完成了一部分的压栈工作，也就是前面的自动压栈过程,由于最后一步
;是ERROR_CODE的压栈，有些中断不会压入，为了统一栈的布局，不压ERROR_CODE的中断在这里多执行一步PUSH 0的操作,自动压入的则是一句nop指令，或许有人会疑问如果为了栈的统一布局，
;发生特权级变化和不发生变化压出来的栈是不一样的，这要如何统一,其实这个工作是在iret时
;cpu去做了，如果发现返回地址发生了特权级的变化它就知道该更换栈了，所以我们只需要把返回
;地址之后的布局统一就行了

;参考前面进入中断的过程，有些中断会自动压入一个ERROR_CODE有些不会，这里统一都压入，方便返回的时候都弹出，如果是自动压入的那%2就应该是nop
;在此之前需要手动去构建中断门描述符,使其CS:IP指向intr%1entry,中断发生后CPU会根据IDT找到这里，下面的内容对CPU来说就是中断处理程序
    %2
    ;调用 put_str之前的压栈
    push intr_str
    call put_str
    ;调用者负责清除压栈数据
    add esp,4
    ;向主片和从片发送中断结束信号EOI，即0x20
    mov al,0x20
    out 0xa0,al
    out 0x20,al
    add esp,4;弹出ERROR_CODE
    iret
section .data
    dd intr%1entry
%endmacro
VECTOR 0x00,ZERO
VECTOR 0x01,ZERO
;...
VECTOR 0x1e,ERROR_CODE
;可以看到整段代码有section .text,section .data,intr_entry_table展开后每一个VECTOR都有两个section,书上说这里编译器会把属性相同的section合成一个段，经实际编程也发现确实是这样，也就意味着每个VECTOR的.data段被合并在了一起，这样通过intr_entry_table[i]就能索引到目标入口,这里每个中断程序做的事情都一样打印一个字符串
</code></pre>
<p>在上面的代码中,中断发生后的处理程序核心是call put_str,但是要编写的中断其实有很多,后面可能还要进行增加,而且处理的过程可能也比较复杂，所以用C语言编写中断处理的函数会比较方便，用一个函数数组来装这些函数，进到中断入口后通过中断向量号去调用这个数组里的函数</p>
<p>另外还要注意的是当某个进程正在进行，如果发生了中断，跳到某个对应的int_entry这里时只发生了最基本的一些压栈，即eflagh和返回地址(或者ss和esp也压了),如果直接调用某段程序会破坏当前进程的环境，CPU自动进行的压栈只保证自己将来能回到这里,但我们还想回来之后能接着之前的状态运行,所以需要手动将”当前环境”保护起来，对一个进程来说”当前环境”就是一套寄存器的取值,所以我们把寄存器内容压栈保护就行了，下面是修改的代码:</p>
<pre><code class="asm">extern idt_table
%macro VECTOR 2
section .text
int%1entry:
    %2
    push ds
    push es
    push fs
    push gs
    pushad
    push %1
    call [idt_table + %1*4]
    mov al,0x20
    out 0xa0,al
    out 0x20,al
    jmp intr_exit
section .data
    dd int%1entry
%endmacro
section .text
global intr_exit
intr_exit:
    add esp,4
    popad
    pop gs
    pop fs
    pop es
    pop ds
    add esp,4
    iretd
</code></pre>
<p>还有一点不同的是中断的退出被当成一个函数了，这是为了后面实现用户进程时使用，现在不理解也没关系<br>上面就是kernel.s的主要内容,总结一下就是汇编定义了一系列的中断入口,而这些入口做一些简单的保护工作后通过call的形式去执行真正的中断程序</p>
<p>下面的interrupt.c进行一些跟中断有关的工作,这里我贴的是实现系统调用之后的interrupt.c,跟系统调用有关的内容可以不看，不影响理解,另外中断这里是已经开了三个的情况：键盘，时钟，和硬盘</p>
<pre><code class="c">#include &quot;interrupt.h&quot;
#include &quot;stdint.h&quot;
#include &quot;global.h&quot;
#include &quot;io.h&quot;
#include &quot;print.h&quot;

#define PIC_M_CTRL 0x20           // 这里用的可编程中断控制器是8259A,主片的控制端口是0x20
#define PIC_M_DATA 0x21           // 主片的数据端口是0x21
#define PIC_S_CTRL 0xa0           // 从片的控制端口是0xa0
#define PIC_S_DATA 0xa1           // 从片的数据端口是0xa1

#define IDT_DESC_CNT 0x81     // 目前总共支持的中断数

#define EFLAGS_IF   0x00000200       // eflags寄存器中的if位为1
#define GET_EFLAGS(EFLAG_VAR) asm volatile(&quot;pushfl; popl %0&quot; : &quot;=g&quot; (EFLAG_VAR))


/*中断门描述符结构体*/
struct gate_desc &#123;
   uint16_t    func_offset_low_word;
   uint16_t    selector;
   uint8_t     dcount;   //此项为双字计数字段，是门描述符中的第4字节。此项固定值，不用考虑
   uint8_t     attribute;
   uint16_t    func_offset_high_word;
&#125;;

static struct gate_desc idt[IDT_DESC_CNT];   // idt是中断描述符表,本质上就是个中断门描述符数组,以后IDTR存的地址就是idt的地址

char* intr_name[IDT_DESC_CNT];             // 用于保存异常的名字


/********    定义中断处理程序数组    ********
 * 在kernel.s中定义的intrXXentry只是中断处理程序的入口,
 * 最终调用的是ide_table中的处理程序*/
 //下面这个数组就是用C语言编写的真正来处理中断的函数数组,其实也就是这些函数的地址,用void*存就行

typedef void* intr_handler;
intr_handler idt_table[IDT_DESC_CNT];

/********************************************/
extern intr_handler intr_entry_table[IDT_DESC_CNT];        // 声明引用定义在kernel.s中的中断处理函数入口数组
//系统调用注册函数
extern uint32_t syscall_handler(void);


/* 初始化可编程中断控制器8259A */
static void pic_init(void) &#123;

   /* 初始化主片 */
   outb (PIC_M_CTRL, 0x11);   // ICW1: 边沿触发,级联8259, 需要ICW4.
   outb (PIC_M_DATA, 0x20);   // ICW2: 起始中断向量号为0x20,也就是IR[0-7] 为 0x20 ~ 0x27.
   outb (PIC_M_DATA, 0x04);   // ICW3: IR2接从片. 
   outb (PIC_M_DATA, 0x01);   // ICW4: 8086模式, 正常EOI

   /* 初始化从片 */
   outb (PIC_S_CTRL, 0x11);    // ICW1: 边沿触发,级联8259, 需要ICW4.
   outb (PIC_S_DATA, 0x28);    // ICW2: 起始中断向量号为0x28,也就是IR[8-15] 为 0x28 ~ 0x2F.
   outb (PIC_S_DATA, 0x02);    // ICW3: 设置从片连接到主片的IR2引脚
   outb (PIC_S_DATA, 0x01);    // ICW4: 8086模式, 正常EOI
   
   //打开键盘和时钟以及硬盘中断
   outb (PIC_M_DATA, 0xf8);
   outb (PIC_S_DATA, 0xbf);
   put_str(&quot;   pic_init done\n&quot;);

&#125;

/* 创建中断门描述符 */
static void make_idt_desc(struct gate_desc* p_gdesc, uint8_t attr, intr_handler function) &#123; 
   p_gdesc-&gt;func_offset_low_word = (uint32_t)function &amp; 0x0000FFFF;
   p_gdesc-&gt;selector = SELECTOR_K_CODE;
   p_gdesc-&gt;dcount = 0;
   p_gdesc-&gt;attribute = attr;
   p_gdesc-&gt;func_offset_high_word = ((uint32_t)function &amp; 0xFFFF0000) &gt;&gt; 16;
&#125;

/*初始化中断描述符表*/
static void idt_desc_init(void) &#123;
   int i;
   //中断发生后我们是先让CPU跳转到对应的entry进行简单的保护工作,所以中断门所存储的偏移是intr_entry_table的内容而不是idt_table对应的内容
   for (i = 0; i &lt; IDT_DESC_CNT; i++) &#123;
      make_idt_desc(&amp;idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]); 
   &#125;

/* 单独处理系统调用,系统调用对应的中断门dpl为3,
 * 中断处理程序为单独的syscall_handler */
   make_idt_desc(&amp;idt[IDT_DESC_CNT-1],IDT_DESC_ATTR_DPL3,syscall_handler);
   put_str(&quot;   idt_desc_init done\n&quot;);
&#125;



/* 通用的中断处理函数,一般用在异常出现时的处理 */
static void general_intr_handler(uint8_t vec_nr) &#123;
   if (vec_nr == 0x27 || vec_nr == 0x2f) &#123;    // 0x2f是从片8259A上的最后一个irq引脚，保留
      return;        //IRQ7和IRQ15会产生伪中断(spurious interrupt),无须处理。
   &#125;
   set_cursor(0);                                         //光标设置在0号位
   int cursor_pos = 0;
   while((cursor_pos++) &lt; 320)                //一行80字 4行空格
       put_char(&#39; &#39;);            
   
   set_cursor(0);
   put_str(&quot;!!!!!!            excetion message begin            !!!!!!\n&quot;);
   set_cursor(88);                        //第二行第八个字开始打印
   put_str(intr_name[vec_nr]);                            //打印中断向量号
   //14号中断是Page Fault中断，发生这个中断CPU会自动把错误的地址放到cr2寄存器里面,所以可以打印看一下
   if(vec_nr == 14)
   &#123;
       int page_fault_vaddr = 0;
       asm(&quot;movl %%cr2,%0&quot; : &quot;=r&quot; (page_fault_vaddr));   //把虚拟地址 出错的放到了这个变量里面
    put_str(&quot;\npage fault addr is &quot;);
    put_int(page_fault_vaddr);
    put_str(&quot;\n&quot;);
   &#125;
   put_str(&quot;!!!!!!            excetion message end              !!!!!!\n&quot;);
   
   while(1);                                              //悬停
&#125;

/* 完成一般中断处理函数注册及异常名称注册 */
static void exception_init(void) &#123;                // 完成一般中断处理函数注册及异常名称注册
   int i;
   for (i = 0; i &lt; IDT_DESC_CNT; i++) &#123;

/* idt_table数组中的函数是在进入中断后根据中断向量号调用的,
 * 见kernel/kernel.S的call [idt_table + %1*4] */
      idt_table[i] = general_intr_handler;            // 默认为general_intr_handler。
                                // 以后会由register_handler来注册具体处理函数。
      intr_name[i] = &quot;unknown&quot;;                    // 先统一赋值为unknown 
   &#125;
   intr_name[0] = &quot;#DE Divide Error&quot;;
   intr_name[1] = &quot;#DB Debug Exception&quot;;
   intr_name[2] = &quot;NMI Interrupt&quot;;
   intr_name[3] = &quot;#BP Breakpoint Exception&quot;;
   intr_name[4] = &quot;#OF Overflow Exception&quot;;
   intr_name[5] = &quot;#BR BOUND Range Exceeded Exception&quot;;
   intr_name[6] = &quot;#UD Invalid Opcode Exception&quot;;
   intr_name[7] = &quot;#NM Device Not Available Exception&quot;;
   intr_name[8] = &quot;#DF Double Fault Exception&quot;;
   intr_name[9] = &quot;Coprocessor Segment Overrun&quot;;
   intr_name[10] = &quot;#TS Invalid TSS Exception&quot;;
   intr_name[11] = &quot;#NP Segment Not Present&quot;;
   intr_name[12] = &quot;#SS Stack Fault Exception&quot;;
   intr_name[13] = &quot;#GP General Protection Exception&quot;;
   intr_name[14] = &quot;#PF Page-Fault Exception&quot;;
   // intr_name[15] 第15项是intel保留项，未使用
   intr_name[16] = &quot;#MF x87 FPU Floating-Point Error&quot;;
   intr_name[17] = &quot;#AC Alignment Check Exception&quot;;
   intr_name[18] = &quot;#MC Machine-Check Exception&quot;;
   intr_name[19] = &quot;#XF SIMD Floating-Point Exception&quot;;

&#125;

/*完成有关中断的所有初始化工作*/
void idt_init() &#123;
   put_str(&quot;idt_init start\n&quot;);
   idt_desc_init();       // 初始化中断描述符表
   exception_init();       // 异常名初始化并注册通常的中断处理函数
   pic_init();           // 初始化8259A

   /* 加载idt */
   //注意下面类型转化那里书上写错了，先转成32位数然后转成64位数然后再进行移位操作,虽然书上说是这个意思但是写出来的意思是先32位转换然后移位然后再转64位,这样出来的结果可能会错误
   uint64_t idt_operand = ((sizeof(idt) - 1) | ((uint64_t)(uint32_t)idt &lt;&lt; 16));
   asm volatile(&quot;lidt %0&quot; : : &quot;m&quot; (idt_operand));
   put_str(&quot;idt_init done\n&quot;);
&#125;
//下面一些函数是提供给其它程序使用的,enum instr_status定义在interrupt.h中
void register_handler(uint8_t vec_no,intr_handler function)
&#123;
    //把相关向量号的注册函数指针放进去就行
    idt_table[vec_no] = function;
&#125;


enum intr_status intr_enable()
&#123;
    if(intr_get_status() != INTR_ON)
    &#123;
        asm volatile(&quot;sti&quot;);
        return INTR_OFF;
    &#125;
    return INTR_ON;
&#125;

enum intr_status intr_disable()
&#123;
    if(intr_get_status() != INTR_OFF)
    &#123;
       asm volatile(&quot;cli&quot;);
       return INTR_ON;
    &#125;
    return INTR_OFF;
&#125;

enum intr_status intr_set_status(enum intr_status status)
&#123;
    return (status == INTR_ON) ? intr_enable() : intr_disable();
&#125;

enum intr_status intr_get_status()
&#123;
    uint32_t eflags = 0;
    GET_EFLAGS(eflags);
    return (eflags &amp; EFLAGS_IF) ? INTR_ON : INTR_OFF; 
&#125;
</code></pre>
<p>总结一下C语言版本的中断处理过程:<br>其中用到的3个数组:idt-中断描述符数组,这里面每个元素就是一个中断门,idtr寄存器保存它的物理地址,将来CPU会根据向量号来这里查询对应的中断门</p>
<p>idt_table:中断函数数组,这里放的都是C语言写好的一些函数地址,等CPU根据idt里的中断门进入到某个中断入口后,那个入口后面的代码很可能会调用这里的函数<br>intr_entry_table:中断入口地址数组,中断描述符里的中断门里将CPU引导到中断入口,这个数组就是填的入口的地址,因为入口地址只有在定义中断向量那里才知道,所以这个数组是extern的<br>下面是简单的流程表示:<br>中断发生–&gt;CPU拿到向量号–&gt;CPU从IDTR指向的idt找到对应的中断门–&gt;中断门里有入口地址,CPU第一次跳转–&gt;到了入口地址之后进行了一些保护操作然后call 其它函数处理,CPU第二次跳转–&gt;函数返回–&gt;中断返回</p>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理</title>
    <url>/2022/10/07/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><p>前面是一些基本的Makefile知识，这里不说打算以后单独写一篇关于项目管理工具的博客</p>
<h3 id="ASSERT的实现"><a href="#ASSERT的实现" class="headerlink" title="ASSERT的实现"></a>ASSERT的实现</h3><p>之前的调试基本是靠while(1)的方式打断点实现,便于调试这里实现了ASSERT断言,是一个宏，此方法在很多语言中都有,一般形式是ASSERT(condition),一般情况是ASSERT里面的表达式为假的话就需要退出程序并反馈错误信息,因为断言里判断的错误一般都是严重的错误,需要的知识不多,这里是靠C的宏实现的。</p>
<pre><code class="c">//debug.h
#ifndef _KERNEL_DEBUG_H
#define _KERNEL_DEBUG_H
void panic_spin(char *filename,int line,const char *func,const char *condition);
//__VA_ARGS__是预处理器支持的专用标识符
#define PANIC(...) panic_spin (__FILE__,__LINE__,__func__,__VA_ARGS__)
#ifndef NDEBUG
        #define ASSERT(CONDITION) ((void)0)
#else
        #define ASSERT(CONDITION) if(CONDITION)&#123;&#125;else&#123;PANIC(#CONDITION);&#125;
#endif
#endif
</code></pre>
<p>可以看到这里是为debug模式的开关预留了一个开关的,即NDEBUG,如果想要使用ASSERT断言就要在#include”debug.h”之前#define NDEBUG,再者就是__FILE__,<strong>LINE</strong>,__func__这三个专用标识符也可以认识一下对调试挺有用</p>
<pre><code class="c">#include&quot;debug.h&quot;
#include&quot;print.h&quot;
#include&quot;interrupt.h&quot;
//报错和处理的函数
void panic_spin(char *filename,\
                int line,\
                const char* func,\
                const char* condition)\
&#123;
        intr_disable();
        put_str(&quot;\n\n\n!!!!!error!!!!!\n&quot;);
        put_str(&quot;filename:&quot;);
        put_str(filename);
        put_str(&quot;\n&quot;);
        put_str(&quot;line:0x&quot;);
        put_int(line);
        put_str(&quot;\n&quot;);
        put_str(&quot;function:&quot;);
        put_str((char*)func);
        put_str(&quot;\n&quot;);
        put_str(&quot;condition:&quot;);
        put_str((char*)condition);
        put_str(&quot;\n&quot;);
        while(1);
&#125;
</code></pre>
<h3 id="实现字符串的一些操作函数"><a href="#实现字符串的一些操作函数" class="headerlink" title="实现字符串的一些操作函数"></a>实现字符串的一些操作函数</h3><p>虽然这里是为字符串的一些操作编写代码但是其中的memset与memcpy在其它地方用得很多,至于其具体实现这里都采用的朴素的算法比较简单,不赘述</p>
<pre><code class="c">//string.h
#ifndef _STRING_H
#define _STRING_H
#include&quot;stdint.h&quot;

void memset(void *dst_,uint8_t value,uint32_t size);

void memcpy(void *dst_,const void *src_,uint32_t size);

int memcmp(const void *a_,const void *b_,uint32_t size);

//char在str中首次出现的地址
char *strchr(const char *str,const uint8_t ch);

//从后往前找版本
char *strrchr(const char *str,const uint8_t ch);

char *strcat(char *dst_,const char* src_);

//ch出现次数
uint32_t strchs(const char *str,uint8_t ch);
//长度
uint32_t strlen(const char *str);
uint32_t strcpy(char *dst_,const char*src_);
int8_t strcmp(const char *a,const char*b);
#endif
</code></pre>
<pre><code class="c">//string.c
#include&quot;string.h&quot;
#include&quot;global.h&quot;
#include&quot;debug.h&quot;
#define NULL 0
void memset(void *dst_,uint8_t value,uint32_t size)&#123;
        ASSERT(dst_ != NULL);
        uint8_t *dst = (uint8_t*)dst_;
        while(size-- &gt; 0)
                *dst++ = value;
&#125;

void memcpy(void *dst_,const void *src_,uint32_t size)&#123;
        ASSERT(dst_ != NULL &amp;&amp; src_ != NULL);
        uint8_t *dst = (uint8_t*)dst_;
        const uint8_t *src = src_;
        while(size-- &gt; 0)
                *dst++ = *src++;
&#125;

int memcmp(const void *a_,const void *b_,uint32_t size)&#123;
        const char *a = a_;
        const char *b = b_;
        ASSERT(a != NULL &amp;&amp; b != NULL);
        while(size-- &gt; 0)&#123;
                if(*a!=*b)
                        return *a&gt;*b?1:-1;
                ++a;
                ++b;
        &#125;
        return 0;
&#125;

char *strchr(const char *str,const uint8_t ch)&#123;
        ASSERT(str != NULL);
        while(*str!=0)&#123;
                if (*str == ch)
                        return (char*)str;
        ++str;
        &#125;
        return NULL;
&#125;

char *strrchr(const char *str,const uint8_t ch)&#123;
        ASSERT(str!=NULL);
        const char *last = NULL;
        while(*str!=0)&#123;
                if(*str == ch)
                        last = str;
                ++str;
        &#125;
        return (char*)last;
&#125;

char *strcat(char *dst_,const char* src_)&#123;
        ASSERT(dst != NULL &amp;&amp; src_!=NULL);
        char *str = dst_;
        while(*str++);
        --str;
        while((*str++=*src_++));
        return dst_;

&#125;

uint32_t strchs(const char *str,uint8_t ch)&#123;
        ASSERT(str != NULL);
        uint32_t cnt=0;
        while(*str!=0)&#123;
                if(*str==ch)
                        ++cnt;
                ++str;
        &#125;
        return cnt;
&#125;

uint32_t strlen(const char *str)&#123;
        ASSERT(str != NULL);
        uint32_t len = 0;
        while(*str++)
                ++len;
        return len;
&#125;

uint32_t strcpy(char *dst_,const char*src_)&#123;
        uint32_t len = strlen(src_);
        memcpy(dst_,src_,len);
&#125;

int8_t strcmp(const char *a,const char*b)&#123;
        while(*a&amp;&amp;*b)&#123;
                if(*a!=*b)
                        return *a-*b;
                ++a,++b;
        &#125;
        return *a-*b;
&#125;
</code></pre>
<h3 id="bitmap位图-资源管理结构的实现"><a href="#bitmap位图-资源管理结构的实现" class="headerlink" title="bitmap位图-资源管理结构的实现"></a>bitmap位图-资源管理结构的实现</h3><p>bitmap是一种管理资源的方式,简单地理解就是用一个bit位来map映射某一块资源,至于后面这一个”一块资源”取多大取决于具体问题。<br>比如本章要实现的内存管理,管理的最小单元是一个页,一个bit的状态就对应着一个页的状态,为1表示已经用掉用为0表示还未使用。<br>可能看到这里还是很迷惑这是个什么,可以想象它是一个”数组”,每个元素是一个bit,每个bit对应着一个物理页。至于为什么要使用它来管理看后面的代码比较好理解。<br>下面是对bitmap的定义与实现：</p>
<pre><code class="c">#ifndef __LIB_KERNEL_BITMAP_H
#define __LIB_KERNEL_BITMAP_H
#include&quot;global.h&quot;
#define BITMAP_MASK 1
struct bitmap&#123;
        uint32_t btmp_bytes_len;//表示这个位图的长途
        uint8_t *bits;//位图数组的起始地址
&#125;;
void bitmap_init(struct bitmap *btmp);
//测试第bit_idx位是否为1
int bitmap_scan_test(struct bitmap *btmp,uint32_t bit_idx);
//在位图中连续申请cnt个位，成功返回起始下标，失败返回-1
int bitmap_scan(struct bitmap *btmp,uint32_t cnt);
void bitmap_set(struct bitmap *btmp,uint32_t bit_idx,int8_t value);
#endif
</code></pre>
<p>可以看到这里采用的位图结构就真的是一个数组,但C语言里数组的最小元素是一个字节而非bit，但对于位运算来说又是确确实实能操作到每一个bit的，所以这里可以看作8个bit进行一个分组然后管理。</p>
<pre><code class="c">//bitmap.c
#include&quot;bitmap.h&quot;
#include&quot;stdint.h&quot;
#include&quot;string.h&quot;
#include&quot;print.h&quot;
#include&quot;interrupt.h&quot;
#include&quot;debug.h&quot;

//简单的置零，所有字节置零了那每个比特也肯定置零了
void bitmap_init(struct bitmap *btmp)&#123;
        memset(btmp-&gt;bits,0,btmp-&gt;btmp_bytes_len);
&#125;

//测试第bit_idx个bit是0还是1
int bitmap_scan_test(struct bitmap *btmp,uint32_t bit_idx)&#123;
        uint32_t byte_idx = bit_idx / 8;//是第几组
        uint32_t bit_odd = bit_idx % 8;//组内第几个
        return (btmp-&gt;bits[byte_idx] &amp; (BITMAP_MASK &lt;&lt; bit_odd));
&#125;

//扫描bitmap,看有没有连续的cnt个bit可以使用,有就返回起始地址，否则返回-1
int bitmap_scan(struct bitmap *btmp,uint32_t cnt)&#123;
        uint32_t idx_byte = 0;
        //0xff表示8位全为1不可能有空的
        while((0xff==btmp-&gt;bits[idx_byte])&amp;&amp;(idx_byte &lt; btmp-&gt;btmp_bytes_len))
                ++idx_byte;
        ASSERT(idx_byte &lt; btmp-&gt;btmp_bytes_len);
        if(idx_byte == btmp-&gt;btmp_bytes_len)
                return -1;
        //现在btmp-&gt;bits[idx_byte]里有至少一个空位,开始找这个空位
        int idx_bit=0;
        while((uint8_t)(BITMAP_MASK&lt;&lt;idx_bit) &amp; btmp-&gt;bits[idx_byte])
                ++idx_bit;

        int bit_idx_start = idx_byte*8+idx_bit;
        //只要1位直接返回
        if(cnt == 1)
                return bit_idx_start;
        uint32_t bit_left = (btmp-&gt;btmp_bytes_len*8 - bit_idx_start);
        uint32_t count=1;
        uint32_t next_bit = bit_idx_start+1;
        bit_idx_start = -1;
        while(bit_left-- &gt; 0)&#123;
            //这里要注意的是寻找的是连续的cnt个位,如果有cnt个不连续的空位也返回-1
                if(!(bitmap_scan_test(btmp,next_bit)))
                        ++count;
                else
                        count=0;
                if(count == cnt)&#123;
                        bit_idx_start = next_bit - cnt + 1;
                        break;
                &#125;
                ++next_bit;
        &#125;
        return bit_idx_start;
&#125;

void bitmap_set(struct bitmap *btmp,uint32_t bit_idx,int8_t value)&#123;
        ASSERT((value == 0)||(value == 1));
        uint32_t byte_idx = bit_idx/8;
        uint32_t bit_odd= bit_idx%8;
        ASSERT(value == 0 || value == 1);
        if(value)&#123;
                btmp-&gt;bits[byte_idx] |= (BITMAP_MASK &lt;&lt; bit_odd);
        &#125;else&#123;
                btmp-&gt;bits[byte_idx] &amp;= ~(BITMAP_MASK &lt;&lt; bit_odd);
        &#125;
&#125;
</code></pre>
<h3 id="内存管理系统"><a href="#内存管理系统" class="headerlink" title="内存管理系统"></a>内存管理系统</h3><h4 id="内存池的规划"><a href="#内存池的规划" class="headerlink" title="内存池的规划"></a>内存池的规划</h4><p>其实内存池也是一种管理的手段,这里的内存池其实就是地址池,所谓的”池”其实就是相当于一个存储的地方，当需要用的时候去这里取，不用的时候再把地址丢回来。</p>
<ul>
<li>物理内存池：我们最终要管理的是物理上的这块4GB大小的内存，后面的实现中把剩下的物理地址(因为4GB里有一部分是内核代码，剩下的才是能使用的内存)平分给了内核和用户进程,把内核看作一个特权级非常高的进程，它在运行过程中也可能会申请释放内存，所以为它单独分配了一个内存池来使用，用户内存池则是所有用户进程所共享的内存池</li>
<li>虚拟地址池：因为内核也是一个进程，所以它也有自己虚拟的一个地址空间，由于虚拟地址空间跟物理地址空间是不相干的，所以用一个虚拟的地址池来管理内核的虚拟地址空间，当然这个结构也可以用在后面管理用户进程的虚拟地址空间</li>
</ul>
<pre><code class="c">#ifndef __KERNEL_MEMORY_H
#define __KERNEL_MEMORY_H
#include&quot;stdint.h&quot;
#include&quot;bitmap.h&quot;

//虚拟地址池
struct virtual_addr&#123;
        //虚拟地址用到的位图结构
        struct bitmap vaddr_bitmap;
        uint32_t vaddr_start;
&#125;;
extern struct pool kernel_pool,user_pool;//两个物理地址池,具体定义在memory.c里面

enum pool_flags&#123;
        PF_KERNEL = 1,
        PF_USER = 2
&#125;;
//一些用来组成页表项的宏
#define PG_P_1 1
#define PG_P_0 0
#define PG_RW_R 0
#define PG_RW_W 2
#define PG_US_S 0
#define PG_US_U 4

void mem_init();
void *get_kernel_pages(uint32_t);
#endif
</code></pre>
<p>可以看到其实虚拟地址池就是用了一个位图来管理，位图反应了虚拟地址的使用情况而下面那个vaddr_start则表示管理的这块虚拟地址的起始地址是多少，这样可以使此结构管理任意一个虚拟地址开始的一片空间，否则光有位图就只能表示从0开始的虚拟空间</p>
<pre><code class="c">#define NULL 0
#include&quot;memory.h&quot;
#include&quot;stdint.h&quot;
#include&quot;print.h&quot;
#include&quot;bitmap.h&quot;
#include&quot;string.h&quot;
#include&quot;debug.h&quot;
#define PG_SIZE 4096

#define MEM_BITMAP_BASE 0xc009a000

#define K_HEAP_START 0xc0100000

/*下面两个宏用来提取一个虚拟地址对应在页表的索引
*之前分页的时候说过32位的地址前十位是页目录表的索引，中间10位是页表的索引
*所以PDE_IDX就是看addr这个地址是在页目录表的第几个表项
*PTE_IDX则是在页表中的第几个表项*/
#define PDE_IDX(addr) ((addr &amp; 0xffc00000) &gt;&gt; 22)
#define PTE_IDX(addr) ((addr &amp; 0x003ff000) &gt;&gt; 12)

//跟虚拟池差不多，这是物理池的结构，多了一个池的大小，因为现实中物理内存是有限的
struct pool&#123;
        struct bitmap pool_bitmap;
        uint32_t phy_addr_start;
        uint32_t pool_size;
&#125;;
//定义好内核的物理池和用户物理池
struct pool kernel_pool,user_pool;
//目前只有内核这一个进程使用虚拟地址池
struct virtual_addr kernel_vaddr;

static void mem_pool_init(uint32_t all_mem)&#123;
        //初始化，将all_mem的空间分配给内核和用户内存池
        put_str(&quot;mem_pool_init\n&quot;);
        //页表本身要用掉的空间
        uint32_t page_table_size = PG_SIZE * 256;
        /*256的由来:首先页目录表占一个页表大小，如果页目录表里每一项各异那就应该有1024页表
        *也就是一共有1+1024=1025个页表，但是在前面开启分页的代码那里，把页目录表的第0和第768个目录
        *项指向了同1个页表，第1~767个目录项没用，只有769~1022共254个目录项是分配了值的(因为这是属于内核的，而现在内核就已经有内容了),第1023的*值指向页目录表，不另外占空间
        *所以真正用掉的页表大小就是1+1+254 = 256*/

        /*一个进程要有独立的地址空间，那就肯定有一张属于这个进程的页目录表，当前只有内核一个进程，所以当前这个页目录表就是内核的页目录表，所以低端的3GB内存所对应的页目录项内容是没有的，因为内核只使用高端的1G内存
        *当然这里的什么低端3GB高端1GB是虚拟地址的低端高端，并非实际的物理内存。*/
        //低端1MB和页表属于用掉的的内存
        uint32_t used_mem = page_table_size + 0x100000;
        //下面将空间平分给内核与用户
        uint32_t free_mem = all_mem - used_mem;
        uint16_t all_free_pages = free_mem / PG_SIZE;

        uint16_t kernel_free_pages = all_free_pages / 2;
        uint16_t user_free_pages = all_free_pages - kernel_free_pages;
        //计算内核和用户物理内存池需要用到的位图长度,这里位图的一个bit映射到的是一个物理页
        uint32_t kbm_length = kernel_free_pages / 8;
        uint32_t ubm_length = user_free_pages /8;

        //内核物理内存池紧接着用掉的内存后面，一点不浪费
        uint32_t kp_start = used_mem;
        uint32_t up_start = kp_start + kernel_free_pages * PG_SIZE;
        //下面就是对两个物理内存池结构的一些初始化，比较简单
        kernel_pool.phy_addr_start = kp_start;
        user_pool.phy_addr_start = up_start;

        kernel_pool.pool_size = kernel_free_pages * PG_SIZE;
        user_pool.pool_size = user_free_pages * PG_SIZE;

        kernel_pool.pool_bitmap.btmp_bytes_len = kbm_length;
        user_pool.pool_bitmap.btmp_bytes_len = ubm_length;

        /*写到这里不知道你有没有发现前面的某个计算是有错误的
        *计算用掉的内存那里是算的低端的1MB+当前页表要用掉的内存
        *但是有没有想过内存池这个结构体也是需要一个地方存放的，同时
        *它内部的位图结构有个指针，指向一片区域用来映射管理物理页，
        *但是目前还没有分配地方给它，下面两行代码就是在为这个问题分配空间*/
        kernel_pool.pool_bitmap.bits = (void*)MEM_BITMAP_BASE;
        user_pool.pool_bitmap.bits = (void*)(MEM_BITMAP_BASE+kbm_length);
        /*所谓的分配空间其实就是把指针指到某个地方而已，至于这片区域能不能用是
        *分配者考虑的问题，上面两行代码就是在充当分配者的角色分配空间。
        *MEM_BITMAP_BASE的取值在代码外面解释，这里先用即可*/


        put_str(&quot;kernel_pool_bitmap_start:&quot;);
        put_int((int)(kernel_pool.pool_bitmap.bits));
        put_str(&quot;kernel_pool_phy_addr:&quot;);
        put_int((int)kernel_pool.phy_addr_start);
        put_str(&quot;\n&quot;);

        bitmap_init(&amp;kernel_pool.pool_bitmap);
        bitmap_init(&amp;user_pool.pool_bitmap);
        //下面是对内核进程虚拟地址池的初始化
        kernel_vaddr.vaddr_bitmap.btmp_bytes_len = kbm_length;
        kernel_vaddr.vaddr_bitmap.bits = (void*)(MEM_BITMAP_BASE+kbm_length+ubm_length);
        /*K_HEAP_START的值为0xc0100000,这个好理解,在之前构造页表的时候
        *0xc000 0000是映射到物理地址0的，由于已经用掉了1MB，所以要从0xc010 0000开始
        */
        kernel_vaddr.vaddr_start = K_HEAP_START;
        bitmap_init(&amp;kernel_vaddr.vaddr_bitmap);
        put_str(&quot;mem_pool_init done\n&quot;);
        /*初始化完毕,此后申请内存的过程大致如下：
        *从虚拟池找到空闲的空间-&gt;
        *改变虚拟池的位图对应状态-&gt;
        *将要用到的虚拟地址与空闲的物理地址关联起来(这可能涉及到一些汇编层面的代码)-&gt;
        *改变物理池的位图对应状态-&gt;
        *将虚拟地址提供给内核*/
&#125;

void mem_init()&#123;
        put_str(&quot;mem_init start\n&quot;);
        //在mbr那里扫描过内存的大小，并把这个数值放到了0xb00处
        uint32_t mem_bytes_total = (*(uint32_t*)(0xb00));
        mem_pool_init(mem_bytes_total);
        put_str(&quot;mem_init done\n&quot;);
&#125;
//在pf所标识的内存池内申请pg_cnt个虚拟页，成功则返回起始地址，失败则为NULL
static void *vaddr_get(enum pool_flags pf,uint32_t pg_cnt)&#123;
        int vaddr_start = 0,bit_idx_start = -1;
        uint32_t cnt = 0;
        if(pf == PF_KERNEL)&#123;
                bit_idx_start = bitmap_scan(&amp;kernel_vaddr.vaddr_bitmap,pg_cnt);
                if(bit_idx_start == -1)
                        return NULL;
                while(cnt&lt;pg_cnt)&#123;
                        bitmap_set(&amp;kernel_vaddr.vaddr_bitmap,bit_idx_start+cnt++,1);
                &#125;
                vaddr_start = kernel_vaddr.vaddr_start + bit_idx_start *PG_SIZE;
        &#125;else&#123;
                //目前只有内核的虚拟地址池

        &#125;
        return (void*)vaddr_start;
&#125;
/*上面的函数完成了虚拟池的申请和对应位图的变化
*下面就是要将虚拟地址与实际的物理地址相关联起来
*想想CPU拿到一个虚拟地址，硬件解析(就是通过页目录表之类的)后会跳到另外一个真实的物理地址
*然后这里存的就是这个虚拟地址实际对应的物理地址，现在需要做的就是要在代码里模拟CPU得到了一个
*虚拟地址，我们也要从这个虚拟地址解析出一个物理地址然后把这个虚拟地址想要对应的物理地址写上去。
*/


/*再理一下过程,得到一个虚拟地址addr,根据前20位和页目录表与页表可以查到一个地址，这个地址与addr的后12位相加得到最后要映射成的物理地址
*现在要写一个函数，接收两个参数，addr,paddr,根据addr的前20位查表得到一个地址，将paddr的值写到这里*/


//得到虚拟地址对应的pte指针,访问这个指针能修改页表的内容
uint32_t *pte_ptr(uint32_t vaddr)&#123;
        /*这个函数的目标是返回页表项的物理地址(不是页表项存的物理地址，是页表项本身所在的物理地址)
        *首先要明确的是页表项的物理地址要先从页目录表那里得到页表的地址，然后加上对应的索引值
        *要构建的这个地址高10位应该全为1，这里存的是页目录表自己所在的物理地址
        *CPU拿着这个地址以为是页表的地址，开始取中间10位作为索引查页表项，这个时候只要把这中间10位
        *写成原虚拟地址的高10位，CPU根据这10位得到一个物理地址，准备与剩下的12位相加，但是现在看看
        *CPU拿到的这个物理地址，它是从页目录表里取出来的，页目录表里存的全是页表的位置,所以已经得到页表的位置了
        *剩下的就是把索引与之相加，正好现在CPU差个12位的数与之相加，把原虚拟地址的中间十位左移两位给现在的CPU一加就得到到一个页表项的物理地址了*/
        uint32_t *pte = (uint32_t*)(0xffc00000+\
                        ((vaddr &amp; 0xffc00000) &gt;&gt; 10) + \
                        PTE_IDX(vaddr) * 4);
        return pte;
&#125;

//得到虚拟地址对应的pde指针,访问这个指针能修改页目录表的内容
uint32_t *pde_ptr(uint32_t vaddr)&#123;
        uint32_t *pde = (uint32_t*)((0xfffff000)+PDE_IDX(vaddr)*4);
        return pde;
&#125;
/*上面两个函数可以看到是返回一个指针的，作用就是能根据vaddr生成另外的一个地址，把这个地址给CPU
*CPU会找到vaddr对应的页目录项和页表项的物理地址，这样就能在对应位置填任何我们想要映射的物理地址了*/

//在m_pool指向的内存池分配1个物理页
static void *palloc(struct pool *m_pool)&#123;
        int bit_idx = bitmap_scan(&amp;m_pool-&gt;pool_bitmap,1);
        if(bit_idx == -1)
                return NULL;
        bitmap_set(&amp;m_pool-&gt;pool_bitmap,bit_idx,1);
        uint32_t page_phyaddr = ((bit_idx*PG_SIZE) + m_pool-&gt;phy_addr_start);
        return (void*)page_phyaddr;
&#125;

//向页表中添加虚拟地址_vaddr与物理地址page_phyaddr的映射
static void page_table_add(void *_vaddr,void *_page_phyaddr)&#123;
        uint32_t vaddr = (uint32_t)_vaddr,page_phyaddr = (uint32_t)_page_phyaddr;
        uint32_t *pde = pde_ptr(vaddr);
        uint32_t *pte = pte_ptr(vaddr);
        if(*pde &amp; 0x00000001)&#123;
                ASSERT(!(*pte&amp;0x00000001));
                if(!(*pte &amp; 0x00000001))&#123;
                        *pte = (page_phyaddr | PG_US_U | PG_RW_W |PG_P_1);
                &#125;else&#123;
                        PANIC(&quot;pte repeat&quot;);
                &#125;
        &#125;else&#123;
                uint32_t pde_phyaddr = (uint32_t)palloc(&amp;kernel_pool);
                *pde = (pde_phyaddr | PG_US_U | PG_RW_W | PG_P_1);
                memset((void*)((int)pte &amp; 0xfffff000),0,PG_SIZE);
                ASSERT(!(*pte &amp; 0x00000001));
                *pte = (page_phyaddr | PG_US_U | PG_RW_W |PG_P_1);
        &#125;
&#125;

//分配pg_cnt个页空间
void *malloc_page(enum pool_flags pf,uint32_t pg_cnt)&#123;
        ASSERT(pg_cnt &gt; 0 &amp;&amp; pg_cnt &lt; 3840);

        void *vaddr_start = vaddr_get(pf,pg_cnt);
        if(vaddr_start == NULL)&#123;
                return NULL;
        &#125;
        uint32_t vaddr = (uint32_t)vaddr_start,cnt = pg_cnt;
        struct pool *mem_pool = pf &amp; PF_KERNEL ? &amp;kernel_pool:&amp;user_pool;
        while(cnt-- &gt; 0)&#123;
                void *page_phyaddr = palloc(mem_pool);
                if(page_phyaddr == NULL)&#123;
                        //此处应该有回滚
                        return NULL;
                &#125;
                page_table_add((void*)vaddr,page_phyaddr);
                vaddr += PG_SIZE;
        &#125;
        return vaddr_start;
&#125;


void *get_kernel_pages(uint32_t pg_cnt)&#123;
        void *vaddr = malloc_page(PF_KERNEL,pg_cnt);
        if(vaddr != NULL)&#123;
                memset(vaddr,0,pg_cnt*PG_SIZE);
        &#125;
        return vaddr;
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>大话设计模式</title>
    <url>/2022/04/24/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><blockquote>
<p>这个模式与面向对象相关,通过面向对象的三大特征来使得程序达到可复用,易修改,易扩展的效果</p>
</blockquote>
<p>本模式以写一个计算器功能,要求根据用户的输入输出相应的结果<br>如果没有使用任何模式代码可能如下</p>
<pre><code class="cpp">int main()
&#123;
    try&#123;
        std::cout&lt;&lt;&quot;请输入数字A:\n&quot;;
        double a;
        std::cin&gt;&gt;a;
        std::cout&lt;&lt;&quot;请输入运算符号+,-,*,/:\n&quot;;
        char opt;
        std::cin&gt;&gt;opt;
        //下面再类似地读入B
        switch(opt)
        &#123;
            case &#39;*&#39;:
            //操作
            break;
            case &#39;/&#39;:
            //操作,注意除法需要自己判断除数是否为0,try catch不捕捉除零错误
            break;
            //类似的
        &#125;
    &#125;catch(...)&#123;
        std::cout&lt;&lt;&quot;您的输入有误\n&quot;;
    &#125;
    return 0;
&#125;
</code></pre>
<p>上面的代码想要复用就必须拷贝粘贴代码,如果有多个地方要使用那多个地方就会出现重复的代码,这是在编码时应该避免的。下面通过面向的封装特性将该功能进行封装,使得其<strong>复用性</strong>大大提高</p>
<pre><code class="cpp">class Operation&#123;
    public:
    static double GetResult(double numA,double numB,string operate)&#123;
        double result = 0;
        switch(operate)&#123;
            case:
            //实现相应功能
        &#125;
        return result;
    &#125;
&#125;;
</code></pre>
<p>将计算这个功能给封装起来,数据的读入和检查由客户完成,这样这个代码的复用性就大大提高了,不单是现在这个程序可以用它,只要是需要通过输入得到结果的地方都可以使用</p>
<p>但是如果此时想要给这个功能添加一些新的计算如开根求幂等,就需要去修改switch case的结构,一方面需要将所有运算的源码交给修改人员,这不安全可能会破坏其它的运算,另一方面这样的修改会使得原来已有的运算重新编译,这是不合理的.说白了这里需要解开各个运算之间的编译<strong>耦合</strong><br>下面是利用继承的方式修改的代码</p>
<pre><code class="cpp">class Operation&#123;
    protected:
    double numA_;
    double numB_;
    public:
    void SetA(double val);
    double GetA()const;
    //numB_类似有get与set
    virtual double GetResult()&#123;
        double ans=0;
        return ans;
    &#125;
&#125;;
class OperationAdd:public Operation&#123;
    public:
    virtual double GetResult()&#123;
        return numA_ + numB_;
    &#125;   
&#125;;

class OperationDiv:public Operation&#123;
    public:
    virtual double GetResult()override &#123;
        if(numB_ == 0 )
            throw Error;
        return numA_ / numB_;
    &#125;
&#125;;
//原先其它运算符类似
class OperationSqrt:public Opearation&#123;
    if (numA_ &lt;0)
        throw Error;
    return sqrt(numA_);
&#125;;
</code></pre>
<p>这样既增加了安全性又提高了扩展性,现在的问题就是客户必须要知道自己的运算需要调用什么样的类,但如果程序很大,对客户来说去众多类里面找到自己想要的类是很不方便的,利用<strong>多态的性质</strong>将这个任务交给一个特定的类去完成,这个类即工厂</p>
<pre><code class="cpp">class OperationFactory&#123;
    public:
    static Operation* createOperate(char operate)&#123;
        Operation* opt = nullptr;
        switch(operate)&#123;
            case &#39;*&#39;:
            opt = new OperationMul();
            break;
            case &#39;+&#39;:
            opt = new OperationAdd();
            break;
            //...
        &#125;
        return opt;
    &#125;
&#125;;
//客户端的代码
Operation *opt;
opt = OperationFactory::createOperate(&#39;+&#39;);
opt-&gt;setA(10);
opt-&gt;setB(20);
double result = opt-&gt;GetResult();
</code></pre>
<h3 id="策略模式-Stretagy"><a href="#策略模式-Stretagy" class="headerlink" title="策略模式(Stretagy)"></a>策略模式(Stretagy)</h3><h3 id="单一职责原则-SRP"><a href="#单一职责原则-SRP" class="headerlink" title="单一职责原则(SRP)"></a>单一职责原则(SRP)</h3><blockquote>
<p>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会影响到其它职责的实现，这种耦合会导致脆弱的设计</p>
</blockquote>
<h3 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h3><blockquote>
<p>对修改关闭,对扩展开放</p>
</blockquote>
<h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><blockquote>
<p>抽象不应该依赖底层模块,两个都应该依赖抽象。抽象不应该依赖细节，细节应该依赖于抽象。<br>简单地说就是应该针对接口编程而不是针对实现编程</p>
</blockquote>
<p>假设在做一个大项目时需要访问数据库，常用代码会写成函数库，在上层模块中调用这些函数即可，这里就是上层模块对底层模块的依赖。但如果上层的逻辑没有变化但需要换掉访问的数据库，那就出现问题了，因为上层模块与底层是绑在一起的。</p>
<p>再举一个例子就是主机,CPU，内存，硬盘都是根据接口标准制造的，如果说它们根据主板实现那主板一坏其它部件都不能使用了<br>@startuml<br>(登录论坛)<br>(发帖子) as (tiezi_add)<br>usecase 删帖子 as tiezi_del<br>@enduml</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>数字图像处理-图像增强</title>
    <url>/2022/04/23/%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/</url>
    <content><![CDATA[<h3 id="图像增强"><a href="#图像增强" class="headerlink" title="图像增强"></a>图像增强</h3><h4 id="空间域图像处理"><a href="#空间域图像处理" class="headerlink" title="空间域图像处理"></a>空间域图像处理</h4><pre><code class="python"># 平滑处理
import cv2
import matplotlib.pyplot as plt

</code></pre>
<pre><code class="python"># 边缘处理

</code></pre>
<pre><code class="python">
</code></pre>
<h4 id="图像直方图均衡化处理"><a href="#图像直方图均衡化处理" class="headerlink" title="图像直方图均衡化处理"></a>图像直方图均衡化处理</h4><pre><code class="python">import cv2
import matplotlib.pyplot as plt

im = cv2.imread(&#39;../TestFigs/lenna.jpg&#39;)
b,g,r = cv2.split(im)
#均衡化
eb = cv2.equalizeHist(b)

#计算直方图
hist = cv2.calcHist([b],[0],None,[64],[0,256])
ehist = cv2.calcHist([eb],[0],None,[64],[0,256])
#画图
fig,ax = plt.subplots(2,2)
ax[0,0].set_title(&#39;orignHist&#39;)
ax[0,0].plot(hist)

ax[0,1].set_title(&#39;equalHist&#39;)
ax[0,1].plot(ehist)

ax[1,0].set_title(&#39;orign&#39;)
ax[1,0].imshow(b,&#39;gray&#39;)

ax[1,1].set_title(&#39;equaled&#39;)
ax[1,1].imshow(eb,&#39;gray&#39;)
plt.show()
</code></pre>
<p><img src="https://s2.loli.net/2022/04/07/PApihE4O7eWayzZ.png" alt="图像增强_6_0.png"></p>
<pre><code class="python">
</code></pre>
]]></content>
      <tags>
        <tag>专业学习</tag>
      </tags>
  </entry>
  <entry>
    <title>数字图像处理</title>
    <url>/2022/04/06/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3 id="图像增强"><a href="#图像增强" class="headerlink" title="图像增强"></a>图像增强</h3><h4 id="空间域图像处理"><a href="#空间域图像处理" class="headerlink" title="空间域图像处理"></a>空间域图像处理</h4><pre><code class="python">import cv2
import matplotlib.pyplot as plt

# 边缘处理
im = cv2.imread(&#39;../TestFigs/lenna.jpg&#39;)
#高斯滤波
gim = cv2.GaussianBlur(im,(5,5),0)
#均值滤波
mim = cv2.blur(im,(5,5))
#中值滤波
medim = cv2.medianBlur(im,5)

fig,ax = plt.subplots(2,2)
ax[0,0].set_title(&#39;orign&#39;)
ax[0,0].imshow(im)

ax[0,1].set_title(&#39;GaussianBlur&#39;)
ax[0,1].imshow(gim)

ax[1,0].set_title(&#39;blur&#39;)
ax[1,0].imshow(mim)

ax[1,1].set_title(&#39;medianBlur&#39;)
ax[1,1].imshow(medim)
plt.show()
</code></pre>
<h4 id="图像直方图均衡化处理"><a href="#图像直方图均衡化处理" class="headerlink" title="图像直方图均衡化处理"></a>图像直方图均衡化处理</h4><pre><code class="python">import cv2
import matplotlib.pyplot as plt

im = cv2.imread(&#39;../TestFigs/lenna.jpg&#39;)
b,g,r = cv2.split(im)
#均衡化
eb = cv2.equalizeHist(b)

#计算直方图
hist = cv2.calcHist([b],[0],None,[64],[0,256])
ehist = cv2.calcHist([eb],[0],None,[64],[0,256])
#画图
fig,ax = plt.subplots(2,2)
ax[0,0].set_title(&#39;orignHist&#39;)
ax[0,0].plot(hist)

ax[0,1].set_title(&#39;equalHist&#39;)
ax[0,1].plot(ehist)

ax[1,0].set_title(&#39;orign&#39;)
ax[1,0].imshow(b,&#39;gray&#39;)

ax[1,1].set_title(&#39;equaled&#39;)
ax[1,1].imshow(eb,&#39;gray&#39;)
plt.show()
</code></pre>
<p><img src="https://s2.loli.net/2022/04/07/PApihE4O7eWayzZ.png" alt="图像增强_6_0.png">    </p>
<pre><code class="python">
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>数据与函数</title>
    <url>/2023/07/01/%E6%95%B0%E6%8D%AE%E4%B8%8E%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>第一次读到这里的时候能从文字感觉到作者似乎想要展示什么很不得了的东西,但是那个时候还不能理解<br>这里内容所展示的意义,在学完编译原理再回头来看这个地方的内容确实挺震撼的<br>先来解释一下这段代码的意义:</p>
<pre><code class="scheme">(define (cons x y)
    (lambda (op) (if (= 0 op) x y)))

(define (car a)
    (a 0))

(define (cdr a)
    (a 1))
</code></pre>
<p>上述方式中cons被实现为一个函数,它接受两个参数x 和 y,同时返回一个函数,该函数接收一个参数,以此判定返回x还是y.<br>在之前我们一直把cons当作像1,2,3…这样的基础数据类型来使用,但是当思考这个数据类型的特征时可以发现它其实就是代表一种选择<br>一个二选一的选择,作为上层的使用者,当创建一个cons的的时候就代表创建了一个待定的选择,这个选择会在以后某个时刻决定(使用car表示选择前者,使用cdr表示选择后者),所以完全可以把cons实现为一个函数,该函数可以保存传入的两个参数,并返回一个函数,该函数就是一个选择函数,如果没有car和cdr访问cons就可以用(a 0)和(a 1)的形式来选择元素(所以其实数组也可以这样抽象),car与cdr只是为了统一所定义的接口</p>
<p>从上面这个例子来看,一个抽象的数据类型(cons)完全可以由一组函数(通常分为selector与constructor)所定义,只要这些函数能达到符合的约定,比如这里的cons,只要能保证(car (cons a b))的结果为a,(cdr (cons a b))的结果为b即可,这一节的rational实现也是在说明这个抽象方法.这样做的一个好处就是上层使用者只用关心数据的使用接口,无需关心具体的接口实现,同时也给了下层实现的自由,只要能对上提供约定的接口.</p>
<p>现在来想一下数字的意义,假设只考虑整数和add运算,如果每个数字都是一个函数,假设1由函数one表示,2由于two表示…那么这些函数需要满足这样的约定:</p>
<pre><code class="scheme">
(add (one) (one)) =&gt; (two)
(add (one) (two)) =&gt; (three)
;...
</code></pre>
<p>现在再来想一下数字这个类型它的意义,它的意义可以看作一个记录,一个重复的记录,它要保证对同一操作重复two次的结果和重复2次one的结果是一样的,这可以用可重入函数来表达(只要初始数据和执行次数一定,输出结果就一定)</p>
<pre><code class="scheme">(define zero (lambda (f) (lambda (x) x)))
;zero表示不重复f操作
(define one (lambda (f) (lambda (x) (f x))))
;one表示重复一次f操作
(define two (lambda (f) (lambda (x) (f (f x)))))
;two表示重复两次f操作
(define (add a b)
    (lambda (f) (lambda (x) ((a f) ((b f) x)))))
;这里定义一个简单的可重入函数f
（define (f x) (+ x 1)

;测试
(((add one one) f) 0) =&gt; 2
((two f) 0) =&gt; 2

;即(add one one) == (tow)
</code></pre>
<p>到这里连最基础的数字也已经被函数所定义完成(虽然还很不完善)但是已经足够可以看出数据和函数几乎没有区别,数据即函数,这种抽象让我们去思考很多习以为常的基础数据所代表的意义,这确实是令人震撼的</p>
]]></content>
      <tags>
        <tag>SICP笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>计网-链路层</title>
    <url>/2022/10/15/%E8%AE%A1%E7%BD%91-%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<p>便于表达和理解，下面的例子大多基于连接两台电脑的连接为具体例子</p>
<p><em>物理层把两台电脑(当然可以是多台)通过各种物理线路和硬件设施将它们连接了起来，现在两台电脑能互相发送和接收信号了，但也只是能发送和接收信号而已，对于接收者，通过调制解调器之后也就只能得到一堆01数据串，没有其它信息，无从解析。所以需要两台电脑之间形成一种约定，这个约定规定了每次发送的数据的格式等，有了这样的约定两者才能实现有意义的数据传输，来负责管理这个约定的就是链路层</em></p>
<p>举例来说就像隔得很远的两个人要互相通信，现在给了他们两个人一人一个手电，他们可以通过手电的闪烁来传递信息，手电就是物理层的内容将他们”连接”了起来，但是如果只有手电闪烁两人也无法进行有效的通信，现在两人约定一个人要开始讲话时就让手电常亮5秒，然后中间用摩斯电码或者其它方法传递信息，表示讲话完毕就常亮手电7秒，这样双方才能进行有意义的通信，而”开始讲话时…7秒”的这种规定就是链路层要做的工作</p>
<h4 id="概念辨析"><a href="#概念辨析" class="headerlink" title="概念辨析"></a>概念辨析</h4><p><strong>链路</strong>是物理上的将两台电脑连接起来的一条物理线路，而<strong>数据链路</strong>是在此基础上增加一些通信协议，这些协议具体实现到硬件和软件上，现在物理层和链路层的协议大多实现在网卡(网络适配器)上</p>
<h2 id="点对点信道的数据链路层"><a href="#点对点信道的数据链路层" class="headerlink" title="点对点信道的数据链路层"></a>点对点信道的数据链路层</h2><p><strong>链路层要解决的问题：1.封装成帧 2.透明传输 3.差错检测</strong></p>
<h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>这个问题比较容易想到，如果传递的数据没有边界划分那接收者根本不知道改从何处开始解析，所以很自然地就需要对数据进行一个简单的封装，封装的方法就是在数据部分的首尾加上特殊的数据其实也就是特定的01串，至于用什么样的界定符是标准需要讨论的问题，一个这样加上头部和尾部的01串就是一个*帧(Fram)*。当然头部和尾部还可以加上一些控制信息这些是具体的实现细节。接收端只有看到SOH和EOT时才会认为这是一个完整的帧，否则将丢弃接收的数据</p>
<pre><code>    帧开始符                        帧结束符
        |                               |
     ---------------------------------------
    | SOH |     封装的数据部分      |  EOT   |
     ---------------------------------------
</code></pre>
<h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><p>上面的问题中要规定特殊的界定符，但是无论它取什么，都无法保证后面的数据部分不会有跟其一样的01串出现，如果不采取某种措施那接收端就会错误地将一个帧给切分掉。</p>
<p>这里解释一下透明传输，所谓透明是对使用者来说的，就像这里使用者不用知道界定符选了什么，他只管把自己的数据打包成上面的数据部分，不用担心自己的数据中会出现跟界定符一样的01串，因为当使用者把数据给到链路层的时候链路层会来处理这个问题，所以这个传输问题对使用者来说就像透明的一样，不存在</p>
<p>现在回到链路层，如何解决这个问题，其实思路就跟C语言的字符转义一样，跟界定符重复了那就把它变成不一样的东西，接收者再把它翻译回去即可。具体做法就是发送端的链路层在数据部分出现跟界定符一样的地方的前面再插个特殊的”转义符(ESC)”，接收端看到这个转义符就不会把后面的01串当作界定符，并且在将数据传给自己的上层使用者之前把这个转义符给删掉。这种方法称为<strong>字符填充</strong></p>
<h3 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h3><p>解决上面两个问题可以进行通信了，但现实中通信的链路并不完美，传输过程中可能会出现某些数据位的错误即某些位0变1，1变0，此时需要链路层来检测出这些错误。<br>目前广泛使用的一种方式就是**循环冗余检验(CRC)**，其原理如下：</p>
<ol>
<li>发送端会把数据分组，假设一组数据有n位，在后面添加k位额外的数据用以接收端校验，这多出来的k位就叫<strong>冗余码</strong></li>
<li>k位的冗余码可以这样得出：首先双方商定好一个除数P(位数为k+1位),然后在原始的数据后面加k位个0，用新的数据来对P做模2除(模2运算不会产生进位借位),得到的k位余数就是要加上的k位冗余码(FCS Frame Check Sequence)</li>
<li>接收方剥开帧之后取出数据部分对其同样进行模2除，如果得到的余数R不为0则说明传输过程发生了错误</li>
</ol>
<p>比如传输的数据为M &#x3D; 101001，头尾界定符为10010，选择除数P&#x3D;1101，则这个帧的数据应该为：<br>10010 101001 001 10010<br>后面的001是这样得来的</p>
<pre><code>               110101
            ------------
    1101   |101001000
            1101
            -------------
             1110
             1101
             ---------
             0111
             0000
             ---------
              1110
              1101
              ---------
               0110
               0000
              --------
                1100
                1101
                -----
                 001
</code></pre>
<p>可以看到就是先在101001后面加了3个0然后对1101进行模2除取的余数</p>
<p>当然也有可能出现了差错但是接收端对发生了差错的数据进行模2除得到的余数也为0，但这种概率非常的小，如果仅用CRC检验，链路层只能做到无差错的接受，即只要是接受的帧，就认为没有发生错误，无法提供<strong>可靠传输服务</strong>,因为这里还没有机制解决可能出现的1.帧丢失 2.帧重复 3.帧失序这几种传输差错。<br>这个服务现在一般由上层服务保证，但链路层也可以提供此服务，需要增加一些<em>帧编号，确认，重传等机制</em></p>
<p>下面是具体的一个点对点链路层的协议</p>
<h4 id="PPP-Point-to-Point-Protocol"><a href="#PPP-Point-to-Point-Protocol" class="headerlink" title="PPP(Point to Point Protocol)"></a>PPP(Point to Point Protocol)</h4><p>从这个名字可以看出来，它大概就是用于两台机器连接的协议，书上说的是互联网用户接入ISP时使用的协议，这个协议用于串口线路，所以用一根双绞线直接连接两台电脑是看不到这个协议的，后面我会贴一个用Packet Tracer模拟出PPP协议的实验</p>
<p>作为链路层的协议，它肯定需要解决上面三个基础问题，另外一些其它要求可以参考RFC 1547<br>PPP协议由三个部分组成：</p>
<ul>
<li>一个将IP数据报封装到串行数据链路的方法</li>
<li>一个用来建立，配置和测试数据链路的链路控制协议(LCP Link Control Protocol)</li>
<li>一套网络控制协议(NCP Network Control Protocol)</li>
</ul>
<h5 id="PPP协议的帧格式"><a href="#PPP协议的帧格式" class="headerlink" title="PPP协议的帧格式"></a>PPP协议的帧格式</h5><ol>
<li><p>字段意义<br>首先第一个字节是界定符0x7E,后面一个字节规定为0xff,再后面一个字节规定为0x03,这三个字节目前定死，不用改变。后面两个字节表示数据部分采用什么样的协议，如为0xc021则表示信息字段是LCP的数据，而如果为0x8021则表示NCP的控制数据。后面就是信息字段，长度可变，但不超过1500字节，后面就是两字节的FCS然后再是一字节的界定符0x7E,如图所示:</p>
</li>
<li><p>字节或比特填充<br>当信息段出现跟0x7E一样的比特组合时就需要采取一些措施<br>参考RFC 1662的内容:<br>PPP协议支持同步和异步传输，简单地理解同步传输就是以帧为单位进行传输，异步传输就是以字符为单位进行传输<br>当采用异步传输时，转义字符选为0x7D,使用<strong>字节填充</strong>,当信息字段每出现一个0x7E，0x7D或者一个小于0x20(属于ASCII码的控制字符)的字符，就在这个字符之前添加一个0x7D，然后将这个字符与0x20做异或之后发送。接收方在进行FCS检查之前会将0x7D删除，并将其后面的字符与0x20异或转换.</p>
</li>
</ol>
<p>而当采用同步传输时，数据是一帧一帧的，也就是一长串01串,由于界定符为0x7E表现为0111 1110，也就是说在中间部分不应该出现六个连续的1，这很简单只要发送端在每5个连续的1后面加一个0就行了，接收端每扫到5个连续的1就忽略掉后面的一个0，这样就能翻译回去了。</p>
<h5 id="PPP协议的工作状态"><a href="#PPP协议的工作状态" class="headerlink" title="PPP协议的工作状态"></a>PPP协议的工作状态</h5><p>大致如下：<br>两台电脑无连接-&gt;两台电脑有了物理连接-&gt;LCP链路-&gt;鉴别的LCP链路-&gt;NCP链路<br>双方建立好物理连接后开始发送LCP的数据包开始建立数据的链路和配置，包括链路的最大帧长，使用的鉴别协议等，协商完成后就建立了LCP链路。之后进入鉴别状态,这一状态只允许传输LCP数据包，两种鉴别协议为PAP和CHAP,鉴别完成则建立起一条鉴别的LCP链路.<br>之后网络层发送NCP的数据进行控制，如运行的是IP协议，则使用NCP中的IPCP协议进行控制，包括分配IP等工作</p>
<h2 id="使用广播信道的链路层"><a href="#使用广播信道的链路层" class="headerlink" title="使用广播信道的链路层"></a>使用广播信道的链路层</h2><p>下面是以局域网为例进行的广播信道的讨论</p>
<p>广播信道必须要解决信道共享的问题，在技术上主要有两种方法:</p>
<ol>
<li>静态划分信道，如前面物理层中所提到的频分复用，时分复用，码分复用等方式，用户只要分配到了信道就不会与其他用户产生冲突，但代价较高，不适用于局域网</li>
<li>动态媒体接入，特点是信道并非固定分配给用户，由细分为以下两类:<ul>
<li>随机接入：所有用户可以随机地发送信息，如果有多个用户同时发送信息则产生<strong>碰撞</strong>,这些用户都发送失败，这里就需要一个协议来解决碰撞发生之后的情况或者说解决这种模式下怎么保证信道有效的使用</li>
<li>受控接入：用户发送信息受到控制，不能随意发送，比如只有持有某个“令牌”的用户可以发送，然后此令牌在用户中流转。</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>计网学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言拾遗</title>
    <url>/2024/01/12/C%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h3 id="数组与指针的区别"><a href="#数组与指针的区别" class="headerlink" title="数组与指针的区别"></a>数组与指针的区别</h3><ul>
<li><p>对于编译器来说，一个数组就是一个地址，而一个指针就是一个地址的地址。</p>
</li>
<li><p>C语言把数组下标改写成指针偏移量的根本原因是指针和偏移量是底层硬件使用的模型。</p>
</li>
<li><p>可以等价的情况</p>
<ul>
<li>在表达式里使用，可以选择数组或指针如c&#x3D;a[1]与c&#x3D;*（a+1）等价(或者说对数组下标的引用总是可以写成一个起始地址加上偏移量的形式)</li>
<li>作为函数参数时，可以选择数组或指针如void f(int a[])与void f(int *a)等价</li>
</ul>
</li>
<li><p>不可等价的情况</p>
<ul>
<li>extern申明时，extern char a[]与extern char *a;不等价</li>
<li>定义时，char a[]&#x3D;{“abc”};与char *a&#x3D;”abc”不等价</li>
</ul>
</li>
</ul>
<h3 id="判断整数溢出"><a href="#判断整数溢出" class="headerlink" title="判断整数溢出"></a>判断整数溢出</h3><p>整数溢出是相对于有符号整数来说的，无符号整数不会溢出，而是会回绕。<br><code>if(a+b&lt;0)</code>的使用并不总是可靠的，因为在对溢出行为是未定义的，机器行为无法确定，合理的方式可以是<code>if(a&gt;INT_MAX-b)</code>，INT_MAX是limits.h中定义的最大整数。</p>
]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>HttpNote</title>
    <url>/2024/02/20/HttpNote/</url>
    <content><![CDATA[<h3 id="什么是http协议"><a href="#什么是http协议" class="headerlink" title="什么是http协议"></a>什么是http协议</h3><p>在计算机中两点用来传输超文本数据(图片，文字，音视频等)的协议</p>
<p><strong>常见状态码</strong></p>
<ul>
<li>1xx 提示信息，表示需要后续操作</li>
<li>2xx 成功，报文已被收到并处理(200,204)</li>
<li>3xx 重定向报告,资源位置已发生变动，需要客户端重新发送请求</li>
<li>4xx 客户端错误</li>
<li>5xx 服务器错误</li>
</ul>
<p><strong>常见字段</strong></p>
<ul>
<li>Host字段(Host: <a href="http://www.a.com/">www.A.com</a>)</li>
<li>Content-Length 表示服务器返回的数据长度，与http协议中的回车+换行解决使用TCP协议的粘包问题</li>
<li>Connection (Connection: Keep-Alive)客户端要求保持长连接，以便其它请求复用该连接(此处的连接指本次通信所建立的TCP连接)与TCP的Keep-Alive有区别</li>
<li>Content-Type&#x2F;Accept 回应与接受的数据格式</li>
<li>Content-Encoding&#x2F;Accept-Encoding 回应与接受的数据压缩方法</li>
</ul>
<p><strong>GET与POST区别</strong></p>
<ul>
<li>GET语义从服务器获取指定资源，请求参数一般写在URL中，URL只能支持ASCLL所以GET只允许ASCLL字符，浏览器对URL长度有限制所以GET请求会因为这个原因无法请求过长数据,例子如下：<pre><code>GET /index.html HTTP/1.1
Host: www.baidu.com
</code></pre>
</li>
<li>POST则是根据报文body对指定的资源做出处理,请求携带的数据一般写在body当中</li>
</ul>
<p><em>安全指请求方法不会破坏服务器资源</em><br><em>幂等指多次执行相同操作结果都相同</em></p>
<p>GET方法是安全且幂等的,因为都是只读操作，所以对GET请求数据可以做缓存<br>POST方法是新增或提交数据，可能会修改服务器资源，所以不是安全的且多次提交可能创建多个资源，也不是幂等的</p>
<h3 id="HTTP缓存技术"><a href="#HTTP缓存技术" class="headerlink" title="HTTP缓存技术"></a>HTTP缓存技术</h3><p><strong>强制缓存</strong><br>浏览器判断缓存没有过期，直接使用浏览器本地缓存，由浏览器决定</p>
<p><strong>协商缓存</strong><br>服务端告知客户端是否可以使用缓存的方式，相关响应码304</p>
<h3 id="HTTP特性"><a href="#HTTP特性" class="headerlink" title="HTTP特性"></a>HTTP特性</h3><p><strong>优点</strong></p>
<ol>
<li>简单，格式简单，易于理解</li>
<li>灵活易扩展，各类请求方法等没有固定死，允许自定义和扩充</li>
<li>应用广泛，跨平台</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>无状态，减轻了服务器负担但是完成关联性操作会非常麻烦<br>一般会用Cookie技术解决这个问题</li>
</ol>
<p>2.明文传输，不安全 </p>
<h3 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h3><p>HTTPS在HTTP层与TCP层加入SSL&#x2F;TLS协议，使得</p>
<ol>
<li>信息加密，交互信息无法窃取(混合加密)</li>
<li>校验机制，无法篡改通信内容(摘要算法+数字签名)</li>
<li>身份证书(公钥证书)</li>
</ol>
<ul>
<li>混合加密<br>在建立通信前用非对称加密算法交换对称加密算法的密钥，之后的通信都用对称加密算法</li>
<li>摘要算法+数字签名<br>非对称加密中有两种流程，公钥加密私钥解密，私钥加密公钥解密，前者用于加密通信内容，后者用于数字签名<br>私钥对内容的哈希值进行加密，公钥对哈希值进行解密，如果解密后的哈希值与内容的哈希值一致则说明内容没有被篡改</li>
<li>数字证书<br>数字证书是由CA机构颁发的，用于证明服务器身份的，包含了服务器的公钥，服务器的信息，CA的公钥被浏览器内置，保证公钥不是被伪造的</li>
</ul>
]]></content>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Guide_to_Uinix</title>
    <url>/2024/02/20/Guide-to-Uinix/</url>
    <content><![CDATA[<p>原文链接: <a href="https://www.harley.com/unix-book/book/chapters/chapter-list.html">Guide to Unix</a></p>
<h2 id="Unix-FileSystem"><a href="#Unix-FileSystem" class="headerlink" title="Unix FileSystem"></a>Unix FileSystem</h2><p>Unix文件分为三种类型：普通文件，目录文件，特殊文件</p>
<ul>
<li>普通文件：存储数据</li>
<li>目录文件：存储文件名和指向文件的指针</li>
<li>特殊文件：设备文件，包括字符设备和块设备</li>
</ul>
<p><strong>设备文件</strong><br>在dev目录下，包括字符设备和块设备</p>
<ul>
<li>tty: 终端设备,键入tty命令可以查看当前终端<code>cp /etc/passwd /dev/tty1</code>会将passwd文件输出到tty1终端</li>
<li>pts: 伪终端设备,用于远程登录</li>
<li>null与zero: 向二者写入数据会被丢弃，读取会返回EOF与0，<code>dd if=/dev/zero of=temp bs=100 count=1</code>会建立一块清零的文件</li>
<li>random与urandom: 产生随机数，random会等待系统产生随机数，urandom会直接产生随机数</li>
</ul>
<p><strong>命名管道</strong><br><code>mkfifo</code>命令可以创建命名管道，命名管道是一种特殊的文件，用于进程间通信，<code>mkfifo pipe</code>会创建一个名为pipe的命名管道，<code>echo &quot;hello&quot; &gt; pipe</code>会将hello写入pipe管道，<code>cat pipe</code>会读取pipe管道的数据，用于IPC</p>
<h2 id="Process-and-Job-Control"><a href="#Process-and-Job-Control" class="headerlink" title="Process and Job Control"></a>Process and Job Control</h2><p>unix中所有进程都有一个父进程，最主要的管理进程的系统调用就是fork,exec,wait</p>
<ul>
<li>fork: 创建一个新的进程，新进程是调用进程的副本，新进程的PID是唯一的，但是其他的属性都是一样的</li>
<li>exec: 用于执行一个新的程序，exec函数会将当前进程的内存空间替换为新程序的内存空间，但是PID不会改变</li>
<li>wait: 用于等待子进程的结束，如果子进程已经结束，wait会立即返回，否则会阻塞</li>
</ul>
<p>unix启动过程中会手动构建一个idle进程，然后fork出一个init进程，init进程是所有进程的祖先进程<br>如果一个子进程在运行时父进程被终止，子进程就成了孤儿进程，init进程会接管孤儿进程，保证孤儿进程不会成为僵尸进程<br>如果一个父进程在子进程结束后没有调用wait函数，子进程就会成为僵尸进程，僵尸进程会占用系统资源，僵尸进程不占用内存，但是会占用进程表项，所以应该避免产生僵尸进程</p>
<p>*<strong>job与process的区别</strong><br>job是一个或多个进程的集合，一个job可以包含多个进程，一个进程只能属于一个job,job是属于shell的管理单元，一个shell可以包含多个job</p>
<p><code>who | cut -c 1-8 | sort | uniq -c</code>这个命令包含了四个进程，但是只有一个job</p>
<p><strong>Job Control</strong></p>
<ul>
<li><code>&amp;</code>后台运行一个job</li>
<li><code>ctrl+z</code>将当前job挂起</li>
<li><code>bg</code>将一个挂起的job放到后台运行,比如一个job被ctrl+z挂起后，可以用bg命令让它继续运行</li>
<li><code>fg</code>将一个job放到前台运行</li>
<li><code>jobs</code>查看当前job</li>
<li><code>kill</code>终止一个job</li>
<li><code>suspend</code>挂起当前shell,可以用于切换用户</li>
</ul>
<p><strong>Process Control</strong></p>
<ul>
<li><code>ps</code>查看当前进程<br>由于历史原因，ps同时支持BSD与AT&amp;T两种风格的参数，BSD风格的参数是<code>ps aux</code>，AT&amp;T风格的参数是<code>ps -ef</code><br>使用ps命令时主要从三个方面考虑:要展示哪些进程，展示进程的哪些内容，如何展示<br>展示哪些进程:<br>AT&amp;T风格: -e(evrything) 显示所有进程包括守护进程,-a显示与当前usrid和当前终端有关的进程 -p pid显示指定进程 -u user显示指定用户的进程<br>BSD风格: a 显示与当前usrid和终端有关的进程，ax显示所有进程包括守护进程，p pid显示指定进程，U user显示指定用户的进程</li>
</ul>
<p>展示进程的哪些内容:<br>AT&amp;T风格: -f显示全格式，-l显示长格式<br>BSD风格: l,u,v</p>
<p>常用组合:<br>AT&amp;T风格: <code>ps -ef</code>显示所有进程，<code>ps -ef | grep ssh</code>显示所有包含ssh的进程<br>BSD风格: <code>ps aux</code>显示所有进程，<code>ps aux | grep ssh</code>显示所有包含ssh的进程</p>
<p>BSD的States字段(AT&amp;T风格的S字段):</p>
<ul>
<li>R: running,正在运行或在运行队列中等待</li>
<li>S: sleeping,休眠状态，等待某个条件的发生</li>
<li>I: idle,空闲状态</li>
<li>Z: zombie,僵尸进程</li>
<li>T: stopped,停止状态,被挂起或者正被追踪</li>
</ul>
<p>ps查看的是某一时刻的静态内容，top命令可以查看动态的进程信息<br><code>top [-d delay] [-n iterations] [-p pid[,pid]...]</code>可以设置top的刷新间隔和刷新次数,可以在系统变慢时用top查看哪个进程占用了过多的资源</p>
<p>pstree命令可以查看进程的树状结构，理清进程之间的关系<br>-p 参数可以显示进程的PID<br>-n 按进程的PID排序而非进程名<br>-a 显示进程的命令行参数<br>-u 显示进程的所有者</p>
]]></content>
      <tags>
        <tag>Unix命令</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题</title>
    <url>/2024/01/19/%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<h4 id="数字范围与"><a href="#数字范围与" class="headerlink" title="数字范围与"></a>数字范围与</h4><p><em>Brian Kernighan 算法</em><br>n&amp;(n-1) 会将n的二进制表示中的最低位为1的改为0<br>(题目描述)[!<a href="https://leetcode.cn/problems/bitwise-and-of-numbers-range/description/?envType=study-plan-v2&amp;envId=top-interview-150%5D">https://leetcode.cn/problems/bitwise-and-of-numbers-range/description/?envType=study-plan-v2&amp;envId=top-interview-150]</a>: 给定两个整数，计算在范围[m,n]内所有数字的按位与，包括m和n</p>
<p>本质就是计算n和m的二进制表示的公共前缀,利用上面的算法,每次将n的最低位为1的改为0,直到n &lt; m此时n就是公共前缀</p>
<pre><code class="c++">int rangeBitwiseAnd(int m, int n) &#123;
    while(m&lt;n)&#123;
        n&amp;=(n-1);
    &#125;
    return n;
&#125;
</code></pre>
<p>或者同时右移,直到m&#x3D;&#x3D;n</p>
<pre><code class="c++">int rangeBitwiseAnd(int m, int n) &#123;
    int shift = 0;
    while (m &lt; n) &#123;
        m &gt;&gt;= 1;
        n &gt;&gt;= 1;
        ++shift;
    &#125;
    return m &lt;&lt; shift;
&#125;
</code></pre>
<h4 id="跳跃游戏II"><a href="#跳跃游戏II" class="headerlink" title="跳跃游戏II"></a>跳跃游戏II</h4><p>(题目描述)[!<a href="https://leetcode-cn.com/problems/jump-game-ii/]">https://leetcode-cn.com/problems/jump-game-ii/]</a>: 给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p>题目保证可以到达最后一个位置，贪心选择可以跳跃得最远的位置进行跳跃<br>这题的关键是在一次遍历中根据已有信息维护得到当前能跳到的最远位置</p>
<pre><code class="c++">class Solution &#123;
public:
    int jump(vector&lt;int&gt;&amp; nums) &#123;
        int maxpos = 0;//当前能跳到的最远位置
        int end = 0;//上一次跳跃的边界
        int step = 0;
        for(int i = 0;i&lt;nums.size()-1;i++)&#123;
            maxpos = max(maxpos,i+nums[i]);//更新最远边界
            if(i == end)&#123; //到达上次最远边界
                end = maxpos;
                step++;
            &#125;
        &#125;
        return step;
    &#125;
&#125;;
</code></pre>
<h4 id="H指数"><a href="#H指数" class="headerlink" title="H指数"></a>H指数</h4><p>(题目描述)[!<a href="https://leetcode-cn.com/problems/h-index/]">https://leetcode-cn.com/problems/h-index/]</a>: 给定一位研究者的论文被引用次数数组（被引用次数是非负整数），编写一个方法计算出研究者的 h 指数。h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）至多有 h 篇论文分别被引用了至少 h 次。”</p>
<p>排序的方法就不写了，这里主要记录一下二分查找答案的思路<br>由于要找的h是一个0-n的整数，可以二分查找这个值，得到一个mid之后去验证是否满足条件</p>
<pre><code class="c++">class Solution &#123;
public:
    int hIndex(vector&lt;int&gt;&amp; citations) &#123;
        int n = citations.size();
        int l = 0,r = n;
        while(l&lt;r)&#123;
            int mid = l+(r-l)/2;
            if(check(citations,mid))&#123;
                l = mid+1;
            &#125;else&#123;
                r = mid;
            &#125;
        &#125;
        return l-1;
    &#125;
    bool check(vector&lt;int&gt;&amp; citations,int h)&#123;
        int cnt = 0;
        for(int i = 0;i&lt;citations.size();i++)&#123;
            if(citations[i]&gt;=h) cnt++;
            if(cnt&gt;=h) return true;
        &#125;
        return cnt&gt;=h;
    &#125;
&#125;;
</code></pre>
<h3 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h3><p>(题目描述)[!<a href="https://leetcode-cn.com/problems/gas-station/]">https://leetcode-cn.com/problems/gas-station/]</a>: 一条环路上有N个加油站，其中第i个加油站有gas[i]升汽油。你有一辆油箱容量无限的的汽车，从第i个加油站开往第i+1个加油站需要消耗汽油cost[i]升。你从其中的一个加油站出发，开始时油箱为空。如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p>
<p>题目保证答案唯一，假设从i出发最远能到j，则i到j之间的任意一个加油站都不可能到达j，因为如果i最远能到j那i能到达i与j之间的任意一个加油站k，而到达时油箱剩余的油量肯定大于等于0，相当于从k出发再自带大于等于0的油量也只能到j，所以i到j之间的任意一个加油站都不可能到达j</p>
<pre><code class="c++">class Solution &#123;
public:
    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;
        int n = gas.size();
        int sum = 0;
        int sum2 = 0;
        int start = 0;
        for(int i = 0;i&lt;n;i++)&#123;
            sum += gas[i]-cost[i];
            sum2 += gas[i]-cost[i];
            if(sum2&lt;0)&#123;
                start = i+1;
                sum2 = 0;
            &#125;
        &#125;
        return sum&lt;0?-1:start%n;
    &#125;
&#125;;
</code></pre>
<h3 id="分糖果"><a href="#分糖果" class="headerlink" title="分糖果"></a>分糖果</h3><p>(题目描述)[!<a href="https://leetcode-cn.com/problems/candy/]">https://leetcode-cn.com/problems/candy/]</a>: 老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。你需要按照以下要求，帮助老师给这些孩子分发糖果：每个孩子至少分配到 1 个糖果。相邻的孩子中，评分高的孩子必顶得多的糖果。那么这样下来，老师至少需要准备多少颗糖果呢？</p>
<p><strong>两边遍历思想</strong>，先只看左边，再只看右边，取两次遍历的最大值</p>
<pre><code class="c">int candy(int* ratings, int ratingsSize) &#123;
    int *left = malloc(ratingsSize*sizeof(int));
    for(int i=0;i&lt;ratingsSize;i++)&#123;
        if(i&gt;0&amp;&amp;ratings[i]&gt;ratings[i-1])&#123;
            left[i] = left[i-1]+1;
        &#125;else&#123;
            left[i] = 1;
        &#125;
    &#125;
    int re = 0;
    int right = 1;
    for(int i=ratingsSize-1;i&gt;=0;i--)&#123;
        if(i&lt;=ratingsSize-2&amp;&amp;ratings[i]&gt;ratings[i+1])&#123;
            right = right+1;
        &#125;else&#123;
            right = 1;
        &#125;
        re += fmax(right,left[i]);
    &#125;
    return re;
&#125;
</code></pre>
<h3 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h3><p>(题目描述)[!<a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/]">https://leetcode-cn.com/problems/minimum-size-subarray-sum/]</a>: 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的连续子数组，返回 0。</p>
<p>滑动窗口比较容易想到，这里记录一下<strong>利用前缀和+二分查找的思想</strong><br>由于所给数组都是正数，所以前缀和是一个递增序列，从0开始遍历下标，确定下标后二分查找target+pre[i]的位置，这个位置就是最小的j使得pre[j]-pre[i]&gt;&#x3D;target</p>
<pre><code class="c">
int lowerbound(int arr[],int low,int high,int target)&#123;
    while(low&lt;high)&#123;
        int mid = low+(high-low)/2;
        if(arr[mid]&lt;target)&#123;
            low = mid+1;
        &#125;else&#123;
            high = mid;
        &#125;
    &#125;
    return arr[low]&gt;=target?low:-1;
&#125;

int minSubArrayLen(int target, int* nums, int numsSize)&#123;
    int *pre = malloc((numsSize+1)*sizeof(int));
    pre[0] = 0;
    for(int i = 1;i&lt;=numsSize;i++)&#123;
        pre[i] = pre[i-1]+nums[i-1];
    &#125;
    int re = INT_MAX;
    for(int i = 0;i&lt;numsSize;i++)&#123;
        int j = lowerbound(pre,i,numsSize,target+pre[i]);
        if(j!=-1)&#123;
            re = fmin(re,j-i);
        &#125;
    &#125;
    return re==INT_MAX?0:re;
&#125;
</code></pre>
<h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><p>(题目描述)[!<a href="https://leetcode-cn.com/problems/symmetric-tree/]">https://leetcode-cn.com/problems/symmetric-tree/]</a>: 给定一个二叉树，检查它是否是镜像对称的。<br>这个题一个比较有意思的地方在于写出比较两颗树是否镜像对称的函数之后，然后判断自身是否与自身镜像对称即可</p>
<pre><code class="c">bool isSymmetric2(struct TreeNode* root1,struct TreeNode* root2)&#123;
    if(root1&amp;&amp;root2)&#123;
        if(root1-&gt;val!=root2-&gt;val)
            return false;
        return isSymmetric2(root1-&gt;left,root2-&gt;right) &amp;&amp; isSymmetric2(root1-&gt;right,root2-&gt;left);
    &#125;
    if(!root1&amp;&amp;!root2)
        return true;
    return false;
&#125;

bool isSymmetric(struct TreeNode* root)&#123;
    return isSymmetric2(root,root);
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>算法刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习-基础</title>
    <url>/2024/01/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="核心观点"><a href="#核心观点" class="headerlink" title="核心观点"></a>核心观点</h2><ol>
<li>机器学习的学习就是寻找更好的数据表示，使得数据的表示更加有用，更加易于处理。从数学上来看就是找到一个函数，将原始数据映射到一个更加有用的表示空间中。但是它寻找的过程没有创造性，只是在已有的表示空间中寻找更好的表示，比如线性投影，平移等。</li>
<li>深度学习是机器学习的一个分支，它的核心思想就是通过组合简单的模块来表达复杂的函数，这些模块被称为神经网络层，这些层可以将输入数据映射到更加有用的表示空间中，通过层来将数据“逐渐”变为更加有用的表示，这个过程就是深度学习的学习过程。</li>
<li>早期机器学习的方案-SVM,决策树，随机森林。其中SVM需要手工提取特征(这一步又叫特征工程)这是与深度学习一个比较大的区别，深度学习将特征的学习自动化了</li>
<li>训练主要围绕4个方面<em>层(模型)</em>,<em>输入数据和目标</em>,<em>损失函数</em>,<em>优化器</em></li>
<li></li>
</ol>
<h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><ol>
<li>广播<br>没有歧义的话小张量会自动被扩展匹配较大张量以实现逐元素计算，这个扩展过程被称为广播</li>
<li>随机梯度下降(SGD)<br>一般情况下参数的调整是取一小批数据组成一个张量送入网络然后调整参数而不是直接将所有数据传入，随机是指每次抽取的批量数据是随机的。理论上可以通过解析法直接求得梯度(将网络看作一个带有N个变量的多项式，其中N是网络的参数个数，比如当N&#x3D;2就是求二元函数偏导)但往往N非常之大，此方法难以应用，因此实际中采用了一种叫反向传播的算法。</li>
<li>反向传播的过程<br>首先会有一个损失函数，这个损失函数根据任务不同而不同如二分类问题常选择binary_crossentropy,这个损失函数以网络的输出和真实值为输入，输出一个标量，这个标量就是损失函数的值，反向传播的过程首先是根据该损失值调整最后一层参数，接着根据当前层的变化继续往下一层调整</li>
<li>K折验证<br>在数据集较小时可以将数据集划分为K个分区，然后实例化K个相同模型，将每个模型在K-1个分区上进行训练然后在剩下的一个分区上进行验证，取平均值作为验证分数</li>
</ol>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>不同任务需要选择的对应激活函数与优化器，损失函数</li>
<li>为什么要数据向量化与标签向量化，什么是one-hot编码</li>
</ol>
]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库学习笔记</title>
    <url>/2024/01/29/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li><p>什么是索引，索引的作用是什么？</p>
</li>
<li><p>什么是辅助索引，桶是什么，什么是倒排索引?</p>
<h3 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h3></li>
<li><p>索引是一种特殊的文件，它包含的主要内容就是对数据项的指针(这里的指针表示可以通过它直接找到数据)，因而它的大小一般比较小，同样的块可以包含更多的索引项，这样就提高了存取效率，可以类比os中的索引节点。</p>
</li>
<li><p>辅助索引是指在数据文件之外，与主索引文件分开存储的索引文件，所以它必须是稠密索引。<br><img src="https://s2.loli.net/2024/01/29/bhmM5N9zeStfHV7.png"><br>桶是为了减少索引项的查找，将具有相同索引值的索引项存放在一起的索引结构，这样就可以减少查找次数，提高查找效率。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习-视觉</title>
    <url>/2024/01/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E8%A7%86%E8%A7%89/</url>
    <content><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li>密集层与卷积层的区别</li>
<li>为什么卷积层的深度可以随意设置,以及卷积层的输出深度为什么是一个参数</li>
<li>池化层的作用</li>
<li>预训练模型怎么起作用的</li>
<li>一些卷积神经网络的可视化方法</li>
</ol>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ol>
<li>两者区别<br><strong>密集层学到的是全局特征，卷积层学到的是局部特征，卷积层的参数共享，密集层的参数不共享</strong><br>上面所谓的全局特征指密集层的每个神经单元都会受到上一层所有神经单元的影响，而局部特征指则是卷积层每个神经元由一个卷积核决定，一般为3x3或5x5,这样一个核所能感受到的视野就是有限的。这样的好处就是一个是可以学习到局部特征，比如一张猫的图片，卷积层可以学到猫的眼睛，鼻子，嘴巴等局部特征(这里只是帮助理解实际学习中不一定真的是学到这些特征)，这样得到的得到的特征具有平移不变性，在左下角学到猫的眼睛跟在右上角学到猫的眼睛是一样的。第二个好处就是可以学习到模式的空间层次，比如第一层学习到了猫的的眼睛，鼻子等局部特征，这些局部特征又可以组合成更高层次的特征如猫的脸。</li>
<li>为什么卷积层的深度可以随意设置,以及卷积层的输出深度为什么是一个参数<br>另外就是卷积层的参数共享，即一个卷积核对一张图片所有位置都是一样的，这样可以大大减少参数量，比如一张图片是224x224x3，卷积核是3x3x3，那么一层卷积层的参数量就是3x3x3x3x3x3&#x3D;729，如果是密集层的话，一层的参数量就是224x224x3x3x3&#x3D;13668736，这样就大大减少了参数量，这也是为什么卷积层的深度可以随意设置的原因，因为卷积层的参数量不会随着深度的增加而增加，而密集层的参数量会随着深度的增加而增加，这样就会导致过拟合。<br>在keras中设置Conv2D时手动选择输出深度，这个深度就是卷积核的个数，设定好后keras会自动生成对应数量的卷积核，这些卷积核的初始参数是随机的，在训练过程中自动调整，所以可以控制卷积层的输出深度。</li>
</ol>
<p>比如现在有一张(28,28,1)的单通道图片，可以用32个(3,3,1)的卷积核对其进行卷积，得到32个(26,26,1)的响应图,组合起来就是一个(26,26,1,32)的特征图。</p>
<ol start="3">
<li>池化层的作用<br>池化层的计算可以看作对刚刚得到的特征图再进行一次卷积，只不过这次卷积的卷积核是(2,2,1)的，步长为2，这样就可以将特征图的尺寸减半(当然可以设置其它尺寸和步长)。主要的作用有两个，其一是扩大感受视野，比如上面得到的(26,26,1,32)的特征图，经过池化层后就变成了(13,13,1,32)的特征图，这样再次卷积时就可以感受更大的视野，因为现在的一个点代表了原来的4个点，其二就是减少参数量，显然上面经过池化层后的参数比以前小得多，这样可以减少过拟合，同时还可以减少计算量。</li>
<li>使用预训练网络的两种方法：<strong>特征提取和微调模型</strong><ol>
<li><em>特征提取</em>，在一个大数据集上训练的卷积网络会有很多已经训练好的卷积层与池化层，这些部分叫卷积基，由于图像的特征是靠各种训练好的卷积核提取的所以卷积基可以重用，来提取图像特征，而后面的密集层则需要重新训练。整个卷积基中越底部的卷积层提取的特征越通用，越靠近顶部的层则一般提取的更抽象的概念，所以多用大模型的前基层来提取特征而不是整个卷积基，另外在训练时<strong>需要冻结一些层，否则反向传播的过程将会非常长且效果提升不大</strong></li>
<li><em>微调模型微</em>，微调模型通过解冻预训练模型的高层，略微调整了模型中的高层抽象表示，让这些表示可以与欲解决的问题更相关</li>
</ol>
</li>
<li>可视化卷积神经网络的方法：1.可视化中间输出 2.可视化过滤器 3.可视化激活的热力图<ol>
<li>*可视化中间输出 *，展示卷积层和池化层的特征图(层输出通常称为该层的激活)</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>深度学习 计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>TCPNote</title>
    <url>/2024/02/21/TCPNote/</url>
    <content><![CDATA[<h3 id="TCP协议是什么"><a href="#TCP协议是什么" class="headerlink" title="TCP协议是什么"></a>TCP协议是什么</h3><p>TCP协议是<em>面向连接的、可靠的、基于字节流的</em>的传输层协议，工作在不可靠的IP协议之上，确保接收端的数据与发送端的数据一致</p>
<h3 id="TCP与UDP的一些区别"><a href="#TCP与UDP的一些区别" class="headerlink" title="TCP与UDP的一些区别"></a>TCP与UDP的一些区别</h3><ul>
<li>连接<br>TCP需要建立连接传输数据，UDP不需要，即刻传输</li>
<li>可靠性<br>TCP保证数据的可靠性，保证数据不丢失，无差错，不重复，UDP不保证但可以基于UDP实现一个可靠传输如QUIC协议</li>
<li>拥塞控制与流量控制<br>TCP有拥塞控制与流量控制，UDP没有，网络拥堵不影响UDP的发送速率</li>
<li>传输方式<br>TCP是面向字节流的没有边界，UDP是面向报文的有边界，因而TCP有一个<em>粘包问题</em>，需要用户程序解决，常见的解决方法是在报文头部加入报文长度</li>
</ul>
<p>但TCP与UDP可以同时绑定到一个端口，并不会引起冲突，对应的包会被分别发送到TCP与UDP的处理程序中</p>
<h3 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h3><ul>
<li><p>服务器进入LISTEN状态，等待客户端连接，客户端随机选择一个初始序列号ISN(Initial Sequence Number)并发送SYN报文给服务器，进入SYN-SENT状态<br>如果此报文丢失，客户端会重发SYN报文，服务器收到后会重新发送SYN+ACK报文</p>
</li>
<li><p>服务器收到SYN报文后，返回SYN+ACK报文给客户端，将ISN+1填入确认序列字段，进入SYN-RECEIVED状态<br>如果此报文丢失，服务器会重发SYN+ACK报文，同时客户端会以为SYN报文丢失，重发SYN报文</p>
<h4 id="SYN攻击与防范"><a href="#SYN攻击与防范" class="headerlink" title="SYN攻击与防范"></a>SYN攻击与防范</h4><p>攻击者发送大量的SYN报文给服务器，服务器会为每一个SYN报文分配一个资源，当资源耗尽后服务器无法再接受新的连接，造成客户端的SYN报文会被丢弃无法建立连接，这种攻击叫做SYN攻击<br>防范方法:</p>
</li>
</ul>
<ol>
<li>增大半连接队列长度与全连接队列长度</li>
<li>启用SYN Cookie，服务器不会为每一个SYN报文分配资源，而是根据SYN报文计算一个cookie，客户端收到SYN+ACK报文后会将cookie发送给服务器，服务器根据cookie计算出ISN，然后建立连接</li>
<li>减少SYN+ACK的重传次数，避免被攻击者的SYN报文占用资源</li>
</ol>
<h4 id="TCP连接在内核表现为结构体"><a href="#TCP连接在内核表现为结构体" class="headerlink" title="TCP连接在内核表现为结构体"></a>TCP连接在内核表现为结构体</h4><p>TCP连接在linux内核中表现为一个socket结构体，包含了TCP的状态信息，即使拔掉网线内核也不会更改该结构体的内容，TCP状态不会改变，拔出网线短时间内插回大概率可以继续使用该连接，如果长期不插回网线则可能触发对方的保活机制导致连接断开，如果双方都没有开启保活机制，但有数据传输则会触发过多重传导致断开TCP连接</p>
<ul>
<li>客户端回应最后一个ACK包，将server_isn+1填入确认序列字段，进入ESTABLISHED状态，服务器收到后也进入ESTABLISHED状态<br>客户端不会重发ACK报文，因为当客户端接收到SYN+ACK后客户端已经建立了连接，但服务端会重传SYN+ACK报文，客户端会产生新的ACK报文发送</li>
</ul>
<p>前两次握手不携带数据，第三次握手携带数据，客户端可以在发送第三次握手报文后马上发送数据报文，这两个报文的确认序列字段都是ISN+1，所以握手报文丢失后如果数据报文抵达也会建立连接</p>
<p><em>三次握手的主要目的是为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误</em><br>如果只用两次握手，可能会造成资源的浪费与错误，下面是一种情形:<br>客户端发送请求报文后宕机然后重启重新发送新的的请求报文，第一个SYN报文比新的SYN报文先抵达服务器，如果只有两次握手，服务器收到SYN后就进入ESTABLISHED状态，发送数据，而这个连接已经失效了，白白发送了数据</p>
<p>总结:<em>第三次握手给客户端一个确认机会，防止历史连接的报文段突然又传送到了服务端建立无效连接</em></p>
<h4 id="为什么TCP初始化序列号是随机的"><a href="#为什么TCP初始化序列号是随机的" class="headerlink" title="为什么TCP初始化序列号是随机的"></a>为什么TCP初始化序列号是随机的</h4><ul>
<li>防止历史报文被下一个连接重用(一个TCP可以由源地址+源端口+目的地址+目的端口唯一确定)<br>如果序列号固定，那么历史连接的序列号可能会被下一个连接重用，导致数据错乱</li>
<li>安全性，防止黑客通过猜测序列号来伪造TCP报文<h4 id="利用RST报文关闭TCP连接"><a href="#利用RST报文关闭TCP连接" class="headerlink" title="利用RST报文关闭TCP连接"></a>利用RST报文关闭TCP连接</h4>主机可以利用killcx工具发送RST报文给服务器，服务器收到RST报文后会立即关闭连接，这样可以避免等待TIME-WAIT状态的时间<br>killcx工具的原理是向服务器发送一个SYN报文，服务器会根据Seq判断出这个连接不是之前的连接，发送正确的确认序列回来，killcx根据此报文伪造一个RST报文发送给服务器，服务器收到RST报文后会立即关闭连接</li>
</ul>
<h4 id="为什么TCP要有MSS，不使用IP层的MTU"><a href="#为什么TCP要有MSS，不使用IP层的MTU" class="headerlink" title="为什么TCP要有MSS，不使用IP层的MTU"></a>为什么TCP要有MSS，不使用IP层的MTU</h4><p>如果TCP将整个报文交给IP层，当传输的报文很大被IP层分片时，如果其中一个分片丢失，那么整个报文都要重传，这样会造成很大的浪费</p>
<h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><p>双方都可以主动断开连接，下面以客户端主动断开连接为例</p>
<ul>
<li><p>客户端发送FIN报文给服务器，进入FIN-WAIT-1状态<br>此报文丢失客户端会重传，超过最大重传次数则会直接进入CLOSED状态<br>如果是进程崩溃内核可以感知并主动发送FIN报文，如果是主机崩溃则只能等服务端的保活机制或重传机制来断开连接</p>
</li>
<li><p>服务器收到FIN报文后，发送ACK报文给客户端，进入CLOSE-WAIT状态，客户端收到ACK报文后进入FIN-WAIT-2状态<br>由于ACK报文不会重传，所以客户端会一直重传FIN报文，服务器再生成新的ACK报文发送给客户端，客户端发起FIN报文给到服务器的信息是客户端关闭了发送数据的通道，但是服务器还可以发送数据给客户端接收</p>
</li>
<li><p>服务器发送FIN报文给客户端，进入LAST-ACK状态<br>此报文丢失服务器会重传，超过最大重传次数则会直接进入CLOSED状态，同时客户端长时间收不到FIN报文也会自动进入CLOSED状态</p>
</li>
<li><p>客户端收到FIN报文后，发送ACK报文给服务器，进入TIME-WAIT状态，等待2MSL(Max Segment Lifttime)后进入CLOSED状态，服务器收到ACK报文后进入CLOSED状态<br>当客户端发送ACK报文后开始计时，如果服务器没有收到ACK报文，服务器会重传FIN报文，客户端收到FIN报文后会重新发送ACK报文重新计时<br>进入TIME-WAIT状态的主要两个目的:</p>
</li>
</ul>
<ol>
<li><p>防止主动方历史数据被后面相同四元组的连接重用，如果没有TIME-WAIT，马上相同的四元组又建立了一个新连接，之前连接的包的序列如果恰好在接收窗口中就会引起数据错乱。所以TIME-WAIT的作用就是等待足够长时间处理历史数据确保不会与新连接的数据混淆</p>
</li>
<li><p>保证被动连接的一方能被正确关闭，如果ACK报文丢失，服务器会重传FIN报文，客户端收到FIN报文后会重新发送ACK报文帮助服务器正确关闭连接</p>
</li>
</ol>
<h4 id="TIME-WAIT状态的优化"><a href="#TIME-WAIT状态的优化" class="headerlink" title="TIME-WAIT状态的优化"></a>TIME-WAIT状态的优化</h4><ol>
<li>复用TIME-WAIT状态的连接并引入时间戳</li>
<li>设定TIME-WAIT连接数目，超过数目则将后面的连接直接关闭</li>
<li>设置socket选项，调用close后立即关闭连接，不进入TIME-WAIT状态</li>
</ol>
<h4 id="服务器出现大量TIME-WAIT状态连接的原因"><a href="#服务器出现大量TIME-WAIT状态连接的原因" class="headerlink" title="服务器出现大量TIME-WAIT状态连接的原因"></a>服务器出现大量TIME-WAIT状态连接的原因</h4><ol>
<li>HTTP没有使用长连接，服务器每处理一个请求就关闭连接</li>
<li>HTTP长连接超时，服务器主动关闭连接</li>
<li>HTTP长连接请求数量过多，一些服务器后端在一个长连接的请求参数过多时会关闭这个连接</li>
</ol>
<h3 id="TCP重传机制"><a href="#TCP重传机制" class="headerlink" title="TCP重传机制"></a>TCP重传机制</h3><ol>
<li>超时重传，由时间驱动，发送数据时启动一个定时器，超过时间没有收到ACK报文则重传报文，这里涉及一个RTO的计算</li>
<li>快速重传，由数据驱动，假设发送方发送了1-6共6个数据，其中1到达之后3-5比2先到达，接收方就会连续发送3个2的ack报文，此时重传报文2<br>此方式解决了超时时间的但无法确定重传时需要重传哪些报文</li>
<li>SACK，选择性重传，在TCP头部加入一个SACK段，将已接收的信息发送给发送方，使发送方只重传丢失的数据</li>
<li>D-SACK，使用SACK告诉发送方哪些数据重复接收了，可以解决ACK包丢失和网络延迟，让发送方知道数据包是丢失了还是延迟</li>
</ol>
<h3 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h3><p>为了保证效率，TCP引入了滑动窗口机制，窗口大小即是无需等待ACK报文而可以继续发送的数据最大值，窗口大小由接收方通告给发送方(TCP头部当中的window字段)，发送方根据接收方的通告调整窗口大小，窗口大小的调整可以根据网络拥塞情况调整，这样可以保证网络的稳定性。</p>
<h4 id="TCP窗口关闭"><a href="#TCP窗口关闭" class="headerlink" title="TCP窗口关闭"></a>TCP窗口关闭</h4><p>当接收方的缓冲区满之后就会发送一个0窗口通知给发送方，此时发送方会停止发送数据，等待接收方的缓冲区有空间后再发送数据，但发送方发送的新的窗口的报文如果丢失接收方则会一直陷入等待状态，所以TCP引入了一个持久定时器，当发送方发送了一个0窗口通知后，发送方会启动一个持久定时器，超过时间后发送一个窗口探测报文给接收方，接收方收到后会回复一个窗口大小，发送方收到后会重新发送数据，若仍然为0则重设定时器。</p>
<h4 id="糊涂窗口综合症"><a href="#糊涂窗口综合症" class="headerlink" title="糊涂窗口综合症"></a>糊涂窗口综合症</h4><p>如果接收方太忙来不及读取窗口接收数据就会导致发送方的发送窗口越来越小，最后接收方腾出几个字节空间发送方就会马上发送几个字节数据给接收方，而一个TCP报文的头部大小加上IP就有40字节，会使得传输效率极低</p>
<p>导致该问题的两个原因:</p>
<ul>
<li>接收方通知小窗口</li>
<li>发送方发送小数据<br>解决方法:</li>
<li>当接收方的窗口小于某个值时直接发送一个0窗口通知，阻止发送方发送小数据</li>
<li>发送方使用<em>Nagle算法</em>，将小数据合并成一个大数据发送<br>但有些情况下Nagle算法会导致延迟，所以可以使用TCP_NODELAY选项关闭Nagle算法，比如telnet协议就需要频繁的发送小数据</li>
</ul>
<h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>流量控制是发送方与接收方的协调，拥塞控制是发送方与网络的协调，防止发送方的数据填满整个网络<br>为了实现拥塞控制，TCP引入了拥塞窗口，该窗口根据网络拥塞情况变化，最终的发送窗口大小是拥塞窗口和接收窗口的最小值</p>
<h4 id="拥塞控制的四个算法"><a href="#拥塞控制的四个算法" class="headerlink" title="拥塞控制的四个算法"></a>拥塞控制的四个算法</h4><ol>
<li>慢启动<br>每当发送方收到一个ACK报文就会将拥塞窗口大小加倍，直到达到一个阈值，然后进入拥塞避免状态</li>
<li>拥塞避免<br>将拥塞窗口大小线性增长，直到网络拥塞触发超时重传，进入拥塞发送状态</li>
<li>拥塞发生</li>
</ol>
<ul>
<li>超时重传<br>将sstresh设置为cwnd&#x2F;2，cwnd设置为1(初始值)，然后进入慢启动状态</li>
<li>快速重传<br>触发快速重传TCP认为网络的拥堵不是非常严重，只是丢失了部分数据，将cwnd设置为cwnd&#x2F;2，ssthresh设置为cwnd，进入快速恢复状态</li>
</ul>
<ol start="4">
<li>快速恢复<br>将cwnd设置为ssthresh+3,表示收到了三个重复的ACK报文，然后每收到一个重复的ACK报文cwnd加1(这里增加cwns是为了快速得到新的确认解决根本问题)，如果收到新的ACK报文则将cwnd设置为ssthresh，进入拥塞避免状态</li>
</ol>
]]></content>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title>More Effective C++</title>
    <url>/2021/07/20/MoreEffectiveC++/</url>
    <content><![CDATA[<h3 id="条款8-各种意义下的new与delete"><a href="#条款8-各种意义下的new与delete" class="headerlink" title="条款8:各种意义下的new与delete"></a>条款8:各种意义下的new与delete</h3><blockquote>
<p>1.new operator 与 operator new的区别是new operator 是在外面使用的new,是语言内建的无法改变其意义：申请一块空间并在改空间上构建对象。而这两件事它都通过调用两个函数完成，第一件申请空间就是调用operator new，这个操作符可以被重载，且第一个参数永远是size_t，它负责申请空间并返回指向这块空间的地址，当然可以重载也就意味着你可以自己设计空间申请的方式</p>
</blockquote>
<blockquote>
<p>2.如果存在一块可用空间，想直接在上面构建对象则可以将operator new重载为void *operator new(size_t,void *)的形式，这个版本的operator new就叫placement new，对应的new操作也变成了new(pointerTobuffer)Type</p>
</blockquote>
<pre><code class="cpp">class Widget&#123;
    public:
    Widget()&#123;&#125;
    void *operator new(size_t size)&#123;
        return malloc(size);
    &#125;
    void *operator new(size_t size,void *buffer)&#123;
        return buffer;
    &#125;
&#125;;
int main()&#123;
    Widget *p = new Widget;
    /*伪码
    void*memeroy = Widget::operator new(sizeof(Widget));
    Widget::Widget();
    Widget*p = static_cast&lt;Widget*&gt;(memory);
    */
    //其中构造函数那里是在申请的地方构造
&#125;
</code></pre>
<blockquote>
<p>delete的行为则是调用析构函数然后调用operator delete，而如果是通过placement new创建的对象，要析构时需要手动调用析构函数，因为那块内存不是由operator new申请得到的，无权去释放，应该交给申请那块地方的人处理</p>
</blockquote>
<pre><code class="cpp">void *mallocShared(size_t size);
void freeShared(void* memory);

Wiget* constructWidgetInBuffer(void *buffer)&#123;
    return new(buffer) Widget;
&#125;
void *p = mallocShared(sizeof(Widget));
Widget*p2 = constructInBuffer(p);
delete p;//error!
p2-&gt;~Widget();//OK
freeShared(p);//OK
</code></pre>
<h3 id="条款26：限制某个类所能产生的对象数量"><a href="#条款26：限制某个类所能产生的对象数量" class="headerlink" title="条款26：限制某个类所能产生的对象数量"></a>条款26：限制某个类所能产生的对象数量</h3><h4 id="允许0个或1个对象产生"><a href="#允许0个或1个对象产生" class="headerlink" title="允许0个或1个对象产生"></a>允许0个或1个对象产生</h4><blockquote>
<p>由于一个对象在产生时构造函数一定会被调用,想要阻止某个class产生对象将其constructors声明为private是最简单的</p>
</blockquote>
<pre><code class="cpp">class NunStricted&#123;
    private:
    NunStricted();
    NunStricted(const NunStricted&amp;);
&#125;;
//如果想只存在一个对象可这样声明和设计

class PrintJob;
class Printer&#123;
    public:
    void submit(const PrintJob&amp;);
    void reset();
    ...
    friend Printer&amp; thePrinter();
    private:
    Printer();
    Printer(const Printer&amp;);
&#125;;

Printer&amp; thePrinter()&#123;
    static Printer p;
    return p;
&#125;
//系统需要的操作都在函数的返回值上进行
thePrinter().reset();
thePrinter().submit(...);
</code></pre>
<p>当然这里这个thePrinter函数可以放进Printer类中,成一个静态函数这样可以让它们离得更近也省去了friend声明的必要</p>
<pre><code class="cpp">class Printer&#123;
    public:
    static Printer&amp; thePrinter();
&#125;;
Printer&amp; thePrinter()&#123;
    static Printer p;
    return p;
&#125;

//调用就会类似下面这样
Printer::thePrinter().reset();

//也可以将thePrinter放入一个PrintStuff的namespace当中
namespace PrintStuff&#123;
    class Printer&#123;
        ...
        friend Printer&amp; thePrinter();
    &#125;
    Printer&amp; thePrinter();
&#125;;
//上面两种方法都是为了将thePrinter函数从全局域放到特定的域当中
</code></pre>
<p>在这个版本的实现当中有两个点需要注意一下:</p>
<ol>
<li>形成的唯一一个Printer对象的,是函数中的static对象而不是class的static对象。<strong>class拥有一个static对象的意思是即使它从未被用到也会被构造析构,而在函数中拥有一个static对象只有在第一次调用时才会构造,也就是说如果函数没有被调用那这个对象也不会被构造,因此这里使用的是静态函数而非静态变量的原因,另外还有一个原因就是使用静态变量无法控制其初始化顺序</strong></li>
<li>这个static函数只有两行,很容易想到把它写成inline函数,早期或者说某些编译器这样会产生一些问题,即使现在最好也不要将一个内含static member的函数写成inline</li>
</ol>
<p>另外一种设计思路就是在类里面设置一个数来记录已经生成的对象数量,当外界申请数量超过某个上限时就在constructors里抛出一个exception</p>
<pre><code class="cpp">class Printer&#123;
    public:
    class TooManyObjects&#123;&#125;;
    Printer();
    ~Printer();
    private:
    static size_t numObjects;
    Printer(const Printer&amp;); //不允许复制行为
&#125;;
size_t Priner::numObjects = 0;
Printer::Printer()&#123;
    if (numObjects&gt;=1)
    throw TooManyObject;
    ...
    ++numObject;
&#125;

Printer::~Printer()&#123;
    ...
    --numObjects;
&#125;
</code></pre>
<p>这样可以通过设定numObjects来限制特定数量的对象产生,但仍有一些问题</p>
<h4 id="不同的对象构造状态"><a href="#不同的对象构造状态" class="headerlink" title="不同的对象构造状态"></a>不同的对象构造状态</h4><p>假设上面的打印机类写好了,现在要写一个升级版的打印机,它直接继承上面的打印机类</p>
<pre><code class="cpp">class ColorPrinter:public Printer&#123;

&#125;;
//现在安装一台普通打印机和彩色打印机
Printer p;
ColorPrinter cp;
</code></pre>
<p>上述代码会因为cp在调用基类的constructor时抛出一个TooManyObjects的exception,但这并不是我们想要的<br>究其原因是Printer这个成分出现在了ColorPrinter内部，而上面的Printer严格限制只有一个Printer成分存在,一个Printer成分有三种可能的方式存在:</p>
<ol>
<li>作为它本身的对象</li>
<li>作为base class</li>
<li>作为对象成员</li>
</ol>
<p>通常是要限制对象个数而非成分的个数,如果采用第一种策略能保证正确,因为私有constructors会禁止掉派生行为.但</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫实战入门</title>
    <url>/2024/02/27/python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>这篇文章主要介绍怎么快速爬取网站数据，具体原理和网络只是作为TODO，后续会补充。</p>
<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="爬虫原理"><a href="#爬虫原理" class="headerlink" title="爬虫原理"></a>爬虫原理</h4><p>最简单的爬虫原理就是通过HTTP请求获得网页内容，然后从获取的网页内容当中解析想要的数据，所以核心分为网络请求和数据解析两部分。<del>TODO:介绍复杂的请求情况与多样的解析手段</del></p>
<h4 id="爬虫工具"><a href="#爬虫工具" class="headerlink" title="爬虫工具"></a>爬虫工具</h4><p>上面提到爬虫主要分为网络请求和数据解析两个部分，第一部分的工具可以使用requests库，第二部分的工具可以使用beautifulsoup库。<del>TODO:介绍其他工具的使用场景</del></p>
<h4 id="网页结构"><a href="#网页结构" class="headerlink" title="网页结构"></a>网页结构</h4><p>网页结构主要分为HTML、CSS、JS三部分，其中HTML是网页的骨架，CSS是网页的样式，JS是网页的交互。其中的HTML是要关注的主要部分，因为网页内容信息基本都在HTML当中<del>TODO:介绍HTML的基本结构</del></p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h4 id="爬取网页"><a href="#爬取网页" class="headerlink" title="爬取网页"></a>爬取网页</h4><pre><code class="python">import requests
from bs4 import BeautifulSoup

#以爬取百度首页为例
url = &#39;https://www.baidu.com&#39;

#获取HTML内容
def get_html(url):
    #这一步精简了很多过程，包括网络请求、状态码判断、编码处理等，直接假设网络请求成功
    response = requests.get(url)
    return response.text

def get_data(html):
    #解析HTML内容
    soup = BeautifulSoup(html, &#39;html.parser&#39;)

    #假设要获取整个页面的所有链接
    #需要实际查看网页源码，找到链接所在的标签和属性，基础的可以按f12打开浏览器开发者工具，然后用左上角的选择器找到对应的标签，然后右键复制选择器
    
    #比如看到链接都在href属性的a标签当中
    links = soup.find_all(&#39;a&#39;)
    links = [link.get(&#39;href&#39;) for link in links]

    #或者直接用CSS选择器
    links = soup.select(&#39;a&#39;)
    links = [link.get(&#39;href&#39;) for link in links]

    #也可以用lxlm的xpath
    from lxml import etree
    html = etree.HTML(html)
    links = html.xpath(&#39;//a/@href&#39;)
    #上述的方法定位需要进入浏览器开发者工具查看源码，然后找到对应的标签和属性，然后用对应的方法提取

    #或者直接用正则表达式，因为提取之后的内容是字符串，所以可以用正则表达式
    import re
    links = re.findall(r&#39;&lt;a.*?href=&quot;(.*?)&quot;.*?&gt;&#39;, html)
</code></pre>
]]></content>
      <tags>
        <tag>python 爬虫</tag>
      </tags>
  </entry>
</search>
