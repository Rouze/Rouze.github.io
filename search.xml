<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言里函数返回结构体的汇编分析</title>
    <url>/2022/09/25/C%E8%AF%AD%E8%A8%80%E9%87%8C%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>在之前写操作系统内核的过程中经常需要接触到汇编和C语言,发现一个函数的返回值通常是由寄存器-eax存储的,但是在C语言里是能返回一个结构体的,如果结构体很大那寄存器肯定放不下,所以就好奇编译查看了一下,下面是测试的代码:</p>
<pre><code class="c">//test.c
struct A&#123;
        int a;
        int b;
        int c;
&#125;;

struct A f()&#123;
        struct A b;
        b.a =0;
        b.b=2;
        b.c=4;
        return b;
&#125;
int main()&#123;
        struct A a;
        a.a=31;
        a = f();
        a.b = 64;
        return 0;
&#125;
</code></pre>
<p>下面是通过gcc test.c -m32 -S产生的test.s的部分结果</p>
<p><img src="/image/C%E8%AF%AD%E8%A8%80%E9%87%8C%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90/1664069235498.png" alt="1664069235498"><br>可以看到在call f之前有一个类似将eax寄存器的值入栈的操作,即<code>movl %eax,(%esp)</code>,查看前面eax已经被赋值成ebp-12了(<code>leal -12(%ebp),%eax</code>),这个值就是变量a的地址(一个int这里是4字节,一个struct A占12个字节)进入f函数后前面几步是常规地在自己的栈内构建变量然后赋值,(如果对函数内构建变量不是很清楚的话建议先去翻翻CSAPP里汇编那一部分的内容)但是从13行开始后面几条命令是将刚构建好的结构体拷贝到另一个地方,拷贝的目的地是以eax里面的值为基址的,往前看可以看到eax被赋成了ebp+8处的内容(<code>movl 8(%ebp),%eax</code>),常规进入函数之后一般ebp+0处是主调函数的栈底,用来恢复主调函数的栈(即函数开头push %ebp的作用),ebp+4处是主调函数的返回地址,这是call指令自动压入的,再往上就是函数的参数,由于在main函数里call f之前最后一次压栈操作是<code>movl %eax,(%esp)</code>,所以现在f内的ebp+8就是main里那个eax的内容即a的地址,所以f内构建出来的变量b就直接拷贝到a那里去了,另外比较特别的是可以看到函数返回时有一个ret $4的操作,表示的就是从栈里取出ip后再弹出4个字节的值,而在ip(也就是主调函数的返回地址)后面的4个字节内容就是刚刚说的那个eax的内容即某个变量的地址。</p>
<p>这里猜测和总结一下：<br>f函数本身没有函数参数,但在编译出来的汇编代码中会传入一个地址一样的值,f函数内部会将自己构建好的结构体拷贝到该地址去。<br>猜测:函数f本身不知道什么时候该拷贝什么时候不该拷贝,上面的代码中是a&#x3D;f();是需要拷贝的情况,但也存在单独调用的情况如f();所以可能的一个策略就是f不管该不该拷贝,反正它是一定会进行复制操作,也一定会拷到eax指定那个地方,至于这个eax指定哪由调用自己的那个地方决定。所以如果在main里调用f而不使用它的返回值那main里应该会有一个”腾出一个struct A”大小的操作,让f拷但又不去破坏到其它的变量。下面是进行测试的代码</p>
<pre><code class="c">struct A&#123;
        int a;
        int b;
        int c;
&#125;;

struct A f()&#123;
        struct A a;
        a.a =0;
        a.b=2;
        a.c=4;
        return a;
&#125;
int main()&#123;
        struct A a;
        a.a=31;
        f();
        a.b = 64;
        return 0;
&#125;
</code></pre>
<p>同样使用gcc test.c -m32 -S产生test.s的部分结果:<br><img src="/image/C%E8%AF%AD%E8%A8%80%E9%87%8C%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90/1664072223777.png" alt="1664072223777"><br>可以看到这次是ebp-40传给了eax而不是ebp-12,所以符合上面的猜想</p>
]]></content>
      <tags>
        <tag>C语言,汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective_STL</title>
    <url>/2022/04/28/Effective-STL/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>C++学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++</title>
    <url>/2021/07/20/EffectiveC++/</url>
    <content><![CDATA[<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ol>
<li><p>defalut构造函数一般定义成explicit，防止编译器做一些预期外的转换</p>
<pre><code class="cpp">class B&#123;
    public:
        explicit B(int x=0,bool b=true);
&#125;;
void doSomething(class B);
B b1;
doSomething(b1);
B b2(28);
doSomething(28);//此处如果没有将构造函数声明为explicit,那编译器将用这个28去构造一个B传给doSomething,这就是预期之外的，由于声明了explicit此处就会报错。
</code></pre>
</li>
</ol>
<h4 id="条款1：尽量以const-enum-inline替换-define"><a href="#条款1：尽量以const-enum-inline替换-define" class="headerlink" title="条款1：尽量以const,enum,inline替换#define"></a>条款1：尽量以const,enum,inline替换#define</h4><blockquote>
<p>因为#define不被视为语言的一部分，也许在某些情况下编译器从来不会见到#define 后面的东西</p>
</blockquote>
<ol>
<li>尽量用常量去替换#defines.</li>
</ol>
<ul>
<li><p>一个例子是常量指针，如#define name “rouze”可以替换为 const char* const name &#x3D; “rouze”;或者用STL的const string name(“rouze”);</p>
</li>
<li><p>再者就是<strong>class的专属常量</strong>，其实#define是无法定义一个class的专属常量的，因为#define出来的东西对该条语句后面的所有语句有效，无法提供私有性。要想使它专属那就要放在private里面，要想只留一份就要static，如果是常量还要加const,类似</p>
<pre><code class="cpp">class obj&#123;
    private:
    static const int num=5;
&#125;;
</code></pre>
<p>上面这种份代码是一份声明，放在头文件当中，但即使是static成员在旧编译器也是不允许的，因此需要在实现文件里赋值const obj::num&#x3D;5;</p>
</li>
<li><p>“enum hack”–enum类型在定义出来后可以当作一个整型常量</p>
<pre><code class="cpp">class Player&#123;
    private:
    static const int NumTurns=10;
    int score[NumTurns];
&#125;;
//如果编译器不支持类中初始化上述定义会报错，但又实在需要NumTurns为一个确定的大小才能通过编译使用enum如下
class Player&#123;
    private:
    enum &#123;NumTurns=10&#125;;
    int score[NumTurns];
&#125;;
//上述定义就能通过编译
</code></pre>
<p>综上所述，<strong>尽量用const或者enum替换掉#defines</strong>，<strong>尽量用inline替换形似函数的宏</strong></p>
</li>
</ul>
<h4 id="条款2-尽可能用const"><a href="#条款2-尽可能用const" class="headerlink" title="条款2: 尽可能用const"></a>条款2: 尽可能用const</h4><blockquote>
<p>const的作用是允许指定一个“约束”，编译器会强制实施这个约束，const 在不同场景有着不同的作用，主要讲一下在member funciton 的</p>
</blockquote>
<pre><code class="cpp">class TextBlock&#123;
    public:
    const char&amp; operator[]const&#123;&#125;
    char&amp; operator[]&#123;&#125;
  
&#125;;
//注意上面函数中两个const 各自的意义
</code></pre>
<p><strong>编译器强制实施的是bitwise-constness</strong>，但在编程过程当中可以通过与const对应的mutable实现<strong>conceptual constness</strong></p>
<p><strong>当const和non-const版本的实现等价只有返回不同时应在non-const版本里调用const版本来避免代码重复</strong></p>
<h4 id="条款3：确定初始化"><a href="#条款3：确定初始化" class="headerlink" title="条款3：确定初始化"></a>条款3：确定初始化</h4><h4 id="条款4：如果不想编译器自动生成函数，应该把相应的成员函数声明为private并且不予实现"><a href="#条款4：如果不想编译器自动生成函数，应该把相应的成员函数声明为private并且不予实现" class="headerlink" title="条款4：如果不想编译器自动生成函数，应该把相应的成员函数声明为private并且不予实现"></a>条款4：如果不想编译器自动生成函数，应该把相应的成员函数声明为private并且不予实现</h4><ul>
<li><p>默认生成的copy assignment运算会自动调用所有成员对象的copy assignment运算完成复制</p>
</li>
<li><p>默认的析构函数会自动调用所有的non-static成员的析构函数进行析构</p>
<pre><code class="cpp">//版本一
class BankAcount&#123;
  private:
    int num;
    BankAcount&amp; operator=(const BankAcount&amp;);
    BankAcount(BankAcount&amp;);
&#125;;
//当复制操作被外部调用时编译会发生错误表示不可调用，当内部函数或者friend函数调用复制操作时会发生链接错误，因为没有函数的实现

//版本二通过继承一个不可复制的类来阻止复制操作
class Uncopyable&#123;
    public:
  Uncopyable()&#123;&#125;
  ~Uncopyable()&#123;&#125;
    private:
  Uncopyable&amp; operator=(const Uncopyable&amp;);
  Uncopyable(const Uncopyable);
&#125;;
class BankAcount:private Uncopyable&#123;
    ...
&#125;;
//相比版本一好处就是错误会被放到编译时期来，因为当BankAcount对象在进行复制行为时势必会调用Uncopyable的复制函数(除非你写的BankAcount是错误的在copy操作没有考虑基类成员，这有悖于条款11)
</code></pre>
</li>
</ul>
<h4 id="条款5：带多态性质的基类应该声明一个virtual析构函数，如果一个类设计出来不是为了作为base-class-那就不应该声明virtual析构，因为virtual的声明会增大类的空间"><a href="#条款5：带多态性质的基类应该声明一个virtual析构函数，如果一个类设计出来不是为了作为base-class-那就不应该声明virtual析构，因为virtual的声明会增大类的空间" class="headerlink" title="条款5：带多态性质的基类应该声明一个virtual析构函数，如果一个类设计出来不是为了作为base class,那就不应该声明virtual析构，因为virtual的声明会增大类的空间"></a>条款5：带多态性质的基类应该声明一个virtual析构函数，如果一个类设计出来不是为了作为base class,那就不应该声明virtual析构，因为virtual的声明会增大类的空间</h4><h4 id="条款6：析构函数不要吐出异常"><a href="#条款6：析构函数不要吐出异常" class="headerlink" title="条款6：析构函数不要吐出异常"></a>条款6：析构函数不要吐出异常</h4><p>如果析构函数吐出异常可能导致其后需要的析构无法进行</p>
<h4 id="条款10-operator-x3D-应该返回一个reference-to-this"><a href="#条款10-operator-x3D-应该返回一个reference-to-this" class="headerlink" title="条款10: operator&#x3D;应该返回一个reference to *this"></a>条款10: operator&#x3D;应该返回一个reference to *this</h4><h4 id="条款11：operator-x3D-应该处理好自我赋值安全与异常安全"><a href="#条款11：operator-x3D-应该处理好自我赋值安全与异常安全" class="headerlink" title="条款11：operator&#x3D;应该处理好自我赋值安全与异常安全"></a>条款11：operator&#x3D;应该处理好自我赋值安全与异常安全</h4><pre><code class="cpp">//通过精心安排的语句能避免一些自我赋值与异常处理
class Widget&#123;
    private:
    Bitmap *pb;
    public:
    ...
&#125;;
//错误版本一,如果pb等于rhs.pb即自我赋值的情况，delete pb之后rhs.pb将指向一块删除的地方，这样就会产生错误
Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123;
    delete pb;
    pb = new Bitmap(*rhs.pb);
    return *this;
&#125;
//版本二，解决了自我赋值，但在new 操作错误时pb将指向错误的地方
Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123;
    if(pb == rhs.pb)
        return *this;
    delete pb;
    pb = new Bitmap(*rhs.pb);
    return *this;
&#125;
//正确版本
Widget&amp; Widget::operator=(const Widget&amp; rhs)
&#123;
    //主要思想就是在复制好原本的资源之前不要delete掉那个指针
    Bitmap * pOrig=pb;
    pb = new Bitmap(*rhs.pb);
    delete pOrig;
    return *this
&#125;
</code></pre>
<h4 id="条款12：copying操作要记得copy处理好每一个成员变量以及“base-class”成分"><a href="#条款12：copying操作要记得copy处理好每一个成员变量以及“base-class”成分" class="headerlink" title="条款12：copying操作要记得copy处理好每一个成员变量以及“base class”成分"></a>条款12：copying操作要记得copy处理好每一个成员变量以及“base class”成分</h4><pre><code class="cpp">class Base&#123;
    private:
    int base;
    public:
    Base&amp; operator=(const Base&amp;rhs);
&#125;;
class Derived:public Base&#123;
    private:
    int derive;
    public:
    Derived&amp; operator=(const Derived&amp;rhs)&#123;
        derive = rhs.derive;
        return *this;
    &#125;
&#125;;
//Base部分的成员变量没有被copy
//正确版本
Derived&amp; Derived::operator=(const Derived&amp;rhs)&#123;
    derive = rhs.derive;
    Base::operator=(rhs);
    return *this;
&#125;
</code></pre>
<pre><code>**另外copy构造函数与copy assignment函数可能代码很大部分一样，但不要在一个copying 函数里面去调用另一个copying函数来实现自己，好的方法是把共同的代码单独写成一个函数供两者调用**
</code></pre>
<h1 id="x3D-x3D-资源管理-x3D-x3D"><a href="#x3D-x3D-资源管理-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;资源管理&#x3D;&#x3D;"></a>&#x3D;&#x3D;资源管理&#x3D;&#x3D;</h1><h4 id="条款13：用对象管理资源"><a href="#条款13：用对象管理资源" class="headerlink" title="条款13：用对象管理资源"></a>条款13：用对象管理资源</h4><ul>
<li>为了防止资源泄露，最好使用RALL对象来管理资源，这样可以通过C++对象的析构函数去自动释放资源</li>
<li>常见的RALL class有auto_ptr(其复制行为有点诡异，当赋值发生时被赋值的对象拥有资源的管理权，而另一个将被置为null),tr1::shared_ptr通过持续的追踪有多少对象指向某笔资源来确定是否释放该资源，因此赋值正常</li>
<li>这两个对象在释放资源时都是进行的delete行为而非delete[]，因此不要将数组指针交给这两个对象管理</li>
</ul>
<h4 id="条款14：在资源管理类中小心处理copying行为"><a href="#条款14：在资源管理类中小心处理copying行为" class="headerlink" title="条款14：在资源管理类中小心处理copying行为"></a>条款14：在资源管理类中小心处理copying行为</h4><ul>
<li><p>如果想要禁止copying行为可以参考条款6将copying函数声明为私有并且不予实现</p>
</li>
<li><p>如果想表现出RCSP的特性可以将底层的资源用tr1::shared_ptr控制，并且其可以指定指定删除行为，缺省时表现为释放资源*std::tr1::shared_ptr<code>&lt;typename&gt;</code> obj(typename,function)*，其中的function就是自己定义的函数</p>
<pre><code class="cpp">class Lock&#123;
    public:
    explicit Lock(Mutex* pm):
    mutexPtr(pm,unlock)&#123;
        lock(mutexPtr.get());
    &#125;
    private:
    std::tr1::shared_ptr&lt;Mutex&gt; mutexPtr;
&#125;;
//将普通的Mutex换成shared_ptr管理，可以表现出RCSP的特性，注意没有写析构函数是因为默认的析构函数会调用non-static的析构函数，而shared_ptr的析构会去执行deleter的行为即指定的unl
</code></pre>
</li>
</ul>
<h4 id="条款15：资源管理类要提供好对原始资源的访问"><a href="#条款15：资源管理类要提供好对原始资源的访问" class="headerlink" title="条款15：资源管理类要提供好对原始资源的访问"></a>条款15：资源管理类要提供好对原始资源的访问</h4><blockquote>
<p>资源管理类并不是为了封装而存在，它只是为了确保“资源释放”这个特殊行为会发生而存在，因此它做的是隐藏客户不需要看的部分，但要备足客户需要的所有东</p>
</blockquote>
<pre><code class="cpp">//当把一个指针交给一个资源管理对象如auto_ptr时，很多函数接口需要的还是原始的指针类型，如果直接将auto_ptr传给函数会发生编译错误，因此资源管理对象就需要提供相应的类型转换

//方法一显示转换
class Manage&#123;
    private:
    Something s;
    public:
    explicit Manage(Something x):
    s(x)
    &#123;
        ...
    &#125;
    ~Manage()&#123;
        ...
    &#125;
    Something get()const&#123;
        return s;
    &#125;
&#125;;//通过Manage对象调用get()返回内部资源
//方法二隐式转换
class Manage&#123;
    public:
    ...
    operator Something()const&#123;
        return s;
    &#125;
&#125;;//在需要类型转换时编译器会自动调用转换函数，这样对客户来说比较轻松，但这样可能就会隐藏危险
</code></pre>
<h4 id="条款17：用独立的语句将new对象置入智能指针"><a href="#条款17：用独立的语句将new对象置入智能指针" class="headerlink" title="条款17：用独立的语句将new对象置入智能指针"></a>条款17：用独立的语句将new对象置入智能指针</h4><p>考虑下面这样的代码</p>
<pre><code class="cpp">int priority();
void process(std::auto_ptr&lt;Widget&gt; pw,pty);

//以下方式调用process函数
process(new Widget,priority());
//首先会报错，因为智能指针的初始化是显式的
process(std::auto_ptr&lt;Widget&gt;(new Widget),priority());

//乍看没问题，但可能造成资源泄露，在调用process之前编译器知道要先做下面几件事
/*1.执行new Widget
2.执行 priority()
3. 执行auto_ptr的构造函数*/
//但只能确定new Widget在auto_ptr之前发生，priority()的执行是无法确定的，如果恰好是按上述顺序，那在priority()出错时new出来的对象将无法放到智能指针里面去
//正确形式
std::auto_ptr&lt;Widget&gt; pw(new Widget);
process(pw,priority());
</code></pre>
<h1 id="x3D-x3D-声明与设计-x3D-x3D"><a href="#x3D-x3D-声明与设计-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;声明与设计&#x3D;&#x3D;"></a>&#x3D;&#x3D;声明与设计&#x3D;&#x3D;</h1><h4 id="条款25：当需要自己写一个swap函数时先确定其不要抛出异常，同时提供一个non-member的版本调用该swap函数，此non-member可以放在class的同一命名空间内，最后可以对std-swap进行全特化但不能往std内加入全新的东西"><a href="#条款25：当需要自己写一个swap函数时先确定其不要抛出异常，同时提供一个non-member的版本调用该swap函数，此non-member可以放在class的同一命名空间内，最后可以对std-swap进行全特化但不能往std内加入全新的东西" class="headerlink" title="条款25：当需要自己写一个swap函数时先确定其不要抛出异常，同时提供一个non-member的版本调用该swap函数，此non-member可以放在class的同一命名空间内，最后可以对std::swap进行全特化但不能往std内加入全新的东西"></a>条款25：当需要自己写一个swap函数时先确定其不要抛出异常，同时提供一个non-member的版本调用该swap函数，此non-member可以放在class的同一命名空间内，最后可以对std::swap进行全特化但不能往std内加入全新的东西</h4><pre><code class="cpp">//假设有一个类，它只管理一个对象指针，定义如下
class WidgetImpl&#123;
    public:
    ...
    private:
    std::vector&lt;int&gt; v;
    ...
&#125;;
class Widget&#123;
    public:
    ...
    Widget&amp;operator=(const Widget&amp;rhs)&#123;
        ...
        *pImpl = *(rhs.pImpl);//这里是通过WidgetImpl对象的operator=完成一个深拷贝而不是直接pImpl=rhs.pImpl
        ...
    &#125;
    private:
    WidgetImpl* pImpl;
&#125;;
//如果直接交换两个,std::swap只是最简单的交换
namespace std&#123;
    template&lt;typename T&gt;
    void swap(T&amp;a,T&amp;b)&#123;
        T temp(a);
        a = b;
        b = tmp;
    &#125;
&#125;
//如果调用std::swap交换那swap会调用最底层的WidgetImpl的operator=,会有ector拷贝的操作，而实际中我们只需要交换两个Widget管理的指针即可，所以有了特化的std::swap
namespace std&#123;
    template&lt;&gt;
    void swap&lt;Widget&gt;(Wiget&amp;lhs,Widget&amp;rhs)&#123;
        //由于成员是private，所以应该定义一个swap成员函数来对指针进行操作，而这里只是进行一个调用
        lhs.swap(rhs);
    &#125;
&#125;
//这样在使用std::swap时编译器会自动找到该版本进行相应的特化操作
/*后面还有如果类是一个模板类需要注意的地方，以后再写吧-_-*/
</code></pre>
<h1 id="x3D-x3D-实现-x3D-x3D"><a href="#x3D-x3D-实现-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;实现&#x3D;&#x3D;"></a>&#x3D;&#x3D;实现&#x3D;&#x3D;</h1><h4 id="条款26：尽量延后变量定义的出现时间，以增加程序清晰度和改善效率"><a href="#条款26：尽量延后变量定义的出现时间，以增加程序清晰度和改善效率" class="headerlink" title="条款26：尽量延后变量定义的出现时间，以增加程序清晰度和改善效率"></a>条款26：尽量延后变量定义的出现时间，以增加程序清晰度和改善效率</h4><p>最好就是在得到能够初始化这个变量的数据出现时定义该变量，一方面可读性较高另一方面也能减少一些初始化引起的问题</p>
<h4 id="条款27：尽量少做转型动作"><a href="#条款27：尽量少做转型动作" class="headerlink" title="条款27：尽量少做转型动作"></a>条款27：尽量少做转型动作</h4><blockquote>
<p>C++提供的四种新转型方式</p>
<p>const_cast<code>&lt;T&gt;</code>(expression)–&gt;用来移除常量性，也是唯一有这个能力的转型操作符</p>
<p>dynamic_cast<code>&lt;T&gt;</code>(expression)</p>
<p>reinterpret_cast<code>&lt;T&gt;</code>(expression)</p>
<p>static_cast<code>&lt;T&gt;</code>(expression)</p>
</blockquote>
<p><strong>类型转换并不是简单的一个类似声明一样的东西，任何一个类型转换往往令编译器编译出运行期执行的代码</strong></p>
<pre><code class="cpp">class Base1&#123;...&#125;;
class Base2&#123;...&#125;;
class Derived:public Base1,public Base2&#123;...&#125;;

Derived d;
Base1* p1 = &amp;d;
Base2* p2 = &amp;d;
Derived* p3 = &amp;d;
//将d的地址转型成Base1的指针，只有编译器知道在继承过程当中属于Base1的那个部分在d的哪里也就是有一个偏移量需要调整，因此p1,p2,p3很可能不同，这就是转型d
</code></pre>
<h4 id="条款29-尽量避免返回对象的handles"><a href="#条款29-尽量避免返回对象的handles" class="headerlink" title="条款29: 尽量避免返回对象的handles"></a>条款29: 尽量避免返回对象的handles</h4><blockquote>
<p>当对象成员的handles(reference,pointer,迭代器等)被成员函数返回，这会破坏封装性，即使返回的是const reference,当对象内部的成员被销毁时，这个留在外面的handle就会成为一个空掉着的handle。但并不代表这是一定不行的，像string的operator[]就需要返回内部字符的reference，以及各种迭代器都需要这样。</p>
</blockquote>
<h4 id="条款30：inling的里里外外"><a href="#条款30：inling的里里外外" class="headerlink" title="条款30：inling的里里外外"></a>条款30：inling的里里外外</h4><blockquote>
<p>inline函数除了能免除函数调用的成本，简单的inlined函数还有可能被编译器优化成更短的目标码，这样有较高的指令高速缓存装置击中率。</p>
<p>但是，如果对一个程序库来说，一个inline 函数f,如果设计者改变了f，那么客户中所有使用了f函数的地方都要重新编译，而如果没有inline只需要重新连接一下，另外不是说某些看起来很简单的代码就一定可以inline，例子如下</p>
</blockquote>
<pre><code class="cpp">class Base&#123;
    public:
    ...
    private:
    std::string b1,b2; 
&#125;;
class Derived :public Base&#123;
    public:
    Derived()&#123;&#125;
    private:
    std::string d1,d2;
&#125;;
//看上去默认构造函数是一个绝佳的inline对象，但在实际的编译之后为了保证程序的正常运行，编译器会添加一些代码，其可能的样子如下
Derived()&#123;
    Base::Base();
    try&#123;d1.std::string::string();&#125;
    catch(...)&#123;
        Base::~Base();
        throw;
    &#125;
    try&#123;d2.std::string::string()&#125;
    catch(...)&#123;
        Base::~Base();
        throw;
    &#125;
    ...
&#125;
//Derive函数先构造好继承的成分，之后再尝试构造自己的成员，如果出现异常就释放已经构造的资源

//上述代码只是简单的描述了一下编译器可能的操作，实际可能更加精致复杂，如果说将所有的构造函数都inlined，那Derive函数将有四份string构造函数的代码（Base成分那里两个再加上自己的两个），如果情况再稍微复杂一些构造函数的代码就可能非常巨大，不再适合inline
</code></pre>
<h4 id="条款31：将文件间的编译依存将至最低"><a href="#条款31：将文件间的编译依存将至最低" class="headerlink" title="条款31：将文件间的编译依存将至最低"></a>条款31：将文件间的编译依存将至最低</h4><blockquote>
<p>C++并没有把“接口从实现中分离”这件事做得很好，Class的定义式不仅描述了接口，还有实现细节，如下面代码所示</p>
</blockquote>
<pre><code class="cpp">class Person&#123;
    //各种接口
    public:
    Person(const std::string&amp;,const Date&amp;,const Address&amp;);
    std::string name()const;
    std::string birthDate()const;
    std::string Address()const;
    private:
    //下面就是所说的实现细节
    std::string theName;
    Date theBirthDate;
    Address theAddress;
&#125;;
</code></pre>
<p>首先上面的代码是无法通过编译的，因为Date和Address是为定义的类型，所以前面常会有include&quot;date.h”这样的东西，其次Person的定义文件和每一个含入了Person class的文件就形成了一种编译依存关系，任何一个头文件的改变都将引起其它文件的的重新编译</p>
<p><strong>解决方案:</strong></p>
<ol>
<li>使用Pimpl技法，将Person分割成为两个classes,一个只提供接口，另一个负责实现接口,Person的定义将如下:</li>
</ol>
<pre><code class="cpp">#include&lt;string&gt;
#include&lt;memory&gt;//shared_ptr所在库
//实现接口的类
class PersonImpl;
//将Date与Address作为前置声明而非直接#include相应头文件这样可以减少由于#include引进的依存

//因为现在的Person只提供接口，需要知道的只是Date与Address这两种类型而非细节，即在Person的定义中Date与Address要么是函数返回类型用到要么是函数参数类型用到,这两种情况下编译都是可以通过的

//但这里无法去实现Person的成员函数
class Date;
class Address;
class Person&#123;
    //各种接口
    public:
    Person(const std::string&amp;,const Date&amp;,const Address&amp;);
    std::string name()const;
    std::string birthDate()const;
    std::string Address()const;
    private:
    //下面是一个指向实物的指针而非具体细节
    std::tr1::shared_ptr&lt;PersonImpl&gt; PImpl;
&#125;;
</code></pre>
<p>现在来看，Person的使用者就完全不需要知道Person的实现细节了，那些关于Person实现的任何修改也不再需要Person的使用者重新编译了，因为从头到尾Person的使用者只是在通过一个指针来进行各种操作，并不能写出依赖于Person细节实现的代码，也就没有了这层编译依赖</p>
<h4 id="条款33：避免遮掩继承来的名字"><a href="#条款33：避免遮掩继承来的名字" class="headerlink" title="条款33：避免遮掩继承来的名字"></a>条款33：避免遮掩继承来的名字</h4><blockquote>
<p>“名称遮掩规则”在类的继承中仍然起作用，想要改变可以使用using</p>
</blockquote>
<pre><code class="cpp">class Base&#123;
    private:
    int x;
    public:
    virtual void mf1()=0;
    virtual void mf1(int);
    void mf3();
    void mf3(int);
&#125;;
class Derived :public Base&#123;
    public:
    virtual void mf1();
    void mf3();
    void mf4();
&#125;;

Derived d;
d.mf1();//right
d.mf1(1);//wrong
d.mf3();//right
d.mf3(1);//wrong
//继承中的名字会覆盖掉所有继承而来的同名函数就像内部的同名变量会掩盖外部的同名变量,本质的原因是*作用域的嵌套*
class Derived :public Base&#123;
    public:
    using Base::mf1;
    using Base::mf3;
    virtual void mf1();
    void mf3();
    void mf4();
&#125;;
//用using解决该问题
</code></pre>
<h4 id="条款37：绝不重新定义继承来的non-virtual函数"><a href="#条款37：绝不重新定义继承来的non-virtual函数" class="headerlink" title="条款37：绝不重新定义继承来的non-virtual函数"></a>条款37：绝不重新定义继承来的non-virtual函数</h4><blockquote>
<p>继承而来的non-virtual函数指定了接口继承以及一份强制性实现，因此non-virtual函数不应该被重写，如果想要表现特异性凌驾于其不变性之上，那该函数就应该声明为virtual</p>
</blockquote>
<h4 id="条款38：绝不重新定义继承而来的缺省参数值"><a href="#条款38：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款38：绝不重新定义继承而来的缺省参数值"></a>条款38：绝不重新定义继承而来的缺省参数值</h4><blockquote>
<p>首先能重新定义的是virtual函数，因此本条款是针对于virtual函数的</p>
</blockquote>
<pre><code class="cpp">class Shape&#123;
    public:
    enum ShapeColor&#123;Red,Black,Green&#125;;
    virtual void draw(ShapeColor color=Red);
&#125;;
class Circle:public Shape&#123;
    public:
    virtual void draw(ShapeColor color=Green);
&#125;;
Shape *pc = new Circle;
pc-&gt;draw();
//上面代码中pc的静态类型是Shape*,不管pc指向什么pc的静态类型都是Shape*,但此刻pc的动态类型为Circle*,由于draw函数是动态调用的，所以会调用Circle的draw，但缺省的参数值是静态绑定的，使用的是Shape类的Red,最终结果就会是这样:
pc-&gt;Circle::draw(Shape::Red);//这是诡异的状态
</code></pre>
<h4 id="条款42-了解typename的双重意义"><a href="#条款42-了解typename的双重意义" class="headerlink" title="条款42:了解typename的双重意义"></a>条款42:了解typename的双重意义</h4><blockquote>
<p>typename与class在作为template参数时对于C++的意义是完全一样的</p>
</blockquote>
<ul>
<li>在模板当中出现的名称如果依赖于模板参数，则这个名称被称为依赖名称(dependent names)</li>
</ul>
<pre><code class="cpp">template&lt;typename T&gt;
void f(const T&amp; container)&#123;
    T::iterator iter(container.begin());
    //typename T::iterator iter(container.begin());
    int x;
&#125;
//iter这个名称的定义需要依赖于模板参数T，因为编译器不知道T::iterator是一个什么，如果T::iterator是一个静态变量那结果就会跟我们想的完全不同，因此需要在这一行加上typename告诉编译器iterator是一个类型，即typename还能用来修饰从属性名称,但这种修饰不能在继承列表和初始化列表出现
</code></pre>
<ul>
<li>以下是通过传入的迭代器来备份某个对象的函数</li>
</ul>
<pre><code class="cpp">template&lt;typename iterT&gt;
void CopyWithIter(iterT iter)&#123;
    typename std::iterator_traits&lt;iterT&gt;::value_type tmp(*iter);
&#125;
//std::iterator_traits&lt;iterT&gt;::value_type,这句话是库通过iterT找到它所指向的对象，value_type就是这个对象类型,去翻stl的源码会发现每个容器的定义前面总会有一堆typedefs，其中就有一个value_type,这是STL的Traits技术，或者说一种规范,更详细的内容可参考条款47)
</code></pre>
<h3 id="条款49-了解new-handler的行为"><a href="#条款49-了解new-handler的行为" class="headerlink" title="条款49:了解new-handler的行为"></a>条款49:了解new-handler的行为</h3><blockquote>
<p>当operator new抛出异常之前，会先调用一个客户指定的错误处理函数，叫new_handler(是一个typedef,typedef void (*new_handler)())直到内存够用或返回一个null使得operator new 抛出异常</p>
</blockquote>
<pre><code class="cpp">void outOfmem()&#123;
    //如果在处理函数中又有new操作且失败那又会反复调用该函数，形成无限递归一样的效果
    std::cerr&lt;&lt;&quot;Unable to new&quot;&lt;&lt;&#39;\n&#39;;
    std::abort();
&#125;

int main()
&#123;
    std::set_new_handler(outOfmem);//set_new_handler使用户指定自己的错误处理函数
    new int[100000000000000000];
  
&#125;
</code></pre>
<p>一个设计良好的new_handler应该可以做到以下条件中的一些:</p>
<ol>
<li>让更多的内存可以被使用，如果系统的operator new失败,但new_handler可以分配出更多内存那下一次new可能就成功了，做法之一就是先申请一块大内存，当new_handler被调用时将它们一点一点归还给系统</li>
<li>安装另一个new_handler。如果当前的new_handler无法获取更多内存但它知道某个new_handler有这个能力那当前的new_handler可以调用set_new_handler替换自己，那下次调用就是最新的new_handler。</li>
<li>卸除new_handler,将null指针传给set_new_handler,这样operator new会抛出异常</li>
<li>抛出bad_alloc异常，这样的异常不会被operator new捕获，因此会传至内存申请处。</li>
<li>直接调用abort或exit</li>
</ol>
<p>如果想为一个class制定特殊的set_new_handler则其部分声明应该如下</p>
<pre><code class="cpp">class Widget&#123;
    public:
    static std::set_new_handler(std::new_handler p)throw();
    static void* operator new(std::size_t size)throw(std::bad_alloc);
    private:
    std::new_handler currentHandler;
&#125;;

Widget::set_new_handler(std::new_handler p)throw()&#123;
    std::new_handler oldHandler = currentHandler;
    currentHandler = p;
    return oldHandler;
&#125;
</code></pre>
<p>但是为了确保global handler总是能被安装回去(因为Widget类在调用set_new_handler时会用自己的handler去替换掉之前的global handler,而如果替换后操作失败就无法再将之前的global handler安装回去了)使用资源管理对象管理global handler</p>
<pre><code class="cpp">class NewHandlerHolder&#123;
    public:
    explicit NewHandlerHolder (std::new_handler nh):handler(nh)&#123;&#125;//这个nh就是被管理的global handler
    ~NewHandlerHolder()&#123;std::set_new_handler(hanlder);&#125;//保证之前的global handler能被安装回去
    private:
    std::new_handler handler;
    NewHandlerHolder(const NewHandlerHolder&amp;);
    NewHandlerHolder&amp; operator=(const NewHandlerHolder&amp;);
&#125;;
//下面客户Widget会这样定义其operator new

void * Widget::operator new(std::size_t size)&#123;
    NewHanlderHolder h(std::set_new_handler(currentHandler));//先将自己的处理函数currentHandler装上去
    return ::operator new(size);//如果这里失败h会被析构之前的global handler会自动装回去
&#125;;

//Widget的客户会这样使用new_handling

void outOfMem();

Widget::set_new_handler(outOfMem); //用户将自己定义的处理函数作为Widget对象分配失败的处理函数
Widget* pw1 = new Widget; //如果失败将调用outOfMem
std::string *ps = new std::string;//如果分配失败会调用global handler(如果有的话)

Widget::set_new_handler(0); //设定Widget 的专属new_handling
Widget* pw2 = new Widget; //分配失败直接报错
</code></pre>
<p>上述方案的实现不会因为类的不同而不同,于是一个将这部分功能单独抽离出来作为一个基类的想法就出现了，先上代码</p>
<pre><code class="cpp">template&lt;typename T&gt;
class NewHandlerSupport&#123;
    public:
    static std::new_handler set_new_handler(std::new_handler p)throw();
    static void*operator new(std::size_t size)(throw std::bad_alloc);

    private:
    static std::new_handler currentHandler;
&#125;;
template&lt;typename T&gt;
std::new_handler
NewHandlerSupport&lt;T&gt;::set_new_handler(std::new_handler p)throw()
&#123;
    std:new_hanlder oldHandler = currentHandler;
    currentHandler = p;
    return oldHandler;
&#125;
template&lt;typename T&gt;
void * operator new(std::size_t size)throw(std::bad_alloc)&#123;
    NewHanlderHolder h(std::set_new_handler(currentHandler));
    return ::operator new(size);
&#125; 
//将每一个currentHandler初始化为null
template&lt;typename T&gt;
std::new_handler NewHandlerSupport&lt;T&gt;::currentHandler = 0;

//现在Widget只需要继承即可
class Widget : public NewHandlerSupport&lt;Widget&gt;&#123;
    
&#125;;
</code></pre>
<p>有两个点说一下,首先为什么这里要使用模板,因为在NewHandlerSupport这个类中其实没有用到T的地方。<br>原因就是这个类是为了让不同的类继承并拥有各自的new_handler,因为currentHandler是一个静态的变量,<br>如果不适用模板那所有子类拥有的是同一份currentHandler。使用模板后不同的类就会产生一个不同的模板,使得它们拥有实体互异的currentHandler<br>其次就是这里提到的minxin风格,简而言之就是一种通过模板来达到多重继承效果的手法,下面是一个简单的例子</p>
<pre><code class="cpp">//这种风格的base class一般是这样的写法
template&lt;typename T&gt;
class A:public T&#123;
    
&#125;;

//假设有一个struct,它管理一个数据,其实可以写成一个template，这里为了简单直接设定为一个int
struct Number&#123;
    int x;
    typedef int value_type;
    void set(int n)&#123;
        x = n;
    &#125;
    int get()const&#123;
        return x;
    &#125;
&#125;;
//在此基础上实现一个可以撤回一次操作的数
template&lt;typename BASE,typename T=BASE::value_type&gt;
struct Undoable:public BASE&#123;
    typedef T value_type;
    T before;
    void set(int n)&#123;
        before = BASE::get();
        BASE::set(n);
    &#125;
    void undo()&#123;
        BASE::set(before);
    &#125;
&#125;;
//在此基础上实现一个可以再做一次的操作的数据
template&lt;typename BASE,typename T=BASE::value_type&gt;
struct Redoable:public BASE&#123;
    typedef T value_type;
    T after;
    void set(int n)&#123;
        after = BASE::get();
        BASE::set(n);
    &#125;
    void redo()&#123;
        BASE::set(after);
    &#125;
&#125;;
//现在如果想要实现一个既可以撤回又可以重做一次的数就可以通过模板组合的方式实现
typedef Redoable&lt;Undoable&lt;Number&gt;&gt; Mynum;
int main()&#123;
    Mynum num1;
    num1.set(10);
    num1.set(29);
    num1.undo();
    cout&lt;&lt;num1.get();
    return 0;
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>C++学习</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/04/23/ExceptionC++_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h3 id="区分几大内存区域"><a href="#区分几大内存区域" class="headerlink" title="区分几大内存区域"></a>区分几大内存区域</h3><table>
<thead>
<tr>
<th>内存区域</th>
<th>特性和对象的生存期</th>
</tr>
</thead>
<tbody><tr>
<td>常量数据</td>
<td>常用于存储字符串和一些编译时就知道的常量。程序的整个生存期内数据都有效且只读,因为编译器可能会<br>对这个区域的数据进行一些特殊的存储优化,擅自修改可能会出现一些未定义的行为</td>
</tr>
<tr>
<td>栈</td>
<td>存自动变量。自动变量在定义时被立即构造,并在其作用域结束时被立即销毁。<br>栈内存的分配通常比动态内存快很多,因为每次栈的分配只涉及到栈指针的自增操作</td>
</tr>
<tr>
<td>自由存储</td>
<td>两种动态内存区域之一,<em>通过new&#x2F;delete来分配&#x2F;释放</em> 。<br>对象的生存周期可能小于所分配的的存储空间的生存期,因为这里的的对象不要求分配内存时立即进行初始化,销毁对象时也不要求立即归还空间</td>
</tr>
<tr>
<td>堆</td>
<td>另一种动态内存区域,<em>通过malloc&#x2F;free函数进行分配和释放</em>。堆还是不同于自由存储的,尽管可能有些地方默认的new和delete会调用malloc和free实现。但堆中的内存不能在自由内存中安全释放,反之亦然。也就是说new出来的内存不能用free安全释放。</td>
</tr>
<tr>
<td>全局&#x2F;静态</td>
<td>程序启动时,全局和静态变量就已经分配了内存,但只有程序执行时才会进行初始化。<br>对于跨域多个编译单元的全局变量,它们的初始化顺序是未定义的,因此在管理时要特别小心它们之间的依赖性</td>
</tr>
</tbody></table>
<h3 id="实现自己特定的内存管理"><a href="#实现自己特定的内存管理" class="headerlink" title="实现自己特定的内存管理"></a>实现自己特定的内存管理</h3><blockquote>
<p>如果要重载operator new与operator delete,记得显示的将它们声明为static,虽然会默认它们是static但这样可以增加可读性,因为一个对象是由它的类创建的,而不是一个对象去创建的,所以operator new函数一定是早于对象它不可能是一个非静态的成员函数</p>
</blockquote>
<p>在此之前应该先了解一些placement new相关的知识,该方面的内容在Effective C++和More EffectiveC++中有详细描述</p>
]]></content>
  </entry>
  <entry>
    <title>Exceptional C++</title>
    <url>/2021/07/20/ExceptionalC++/</url>
    <content><![CDATA[<h4 id="条款2-3-大小写不敏感的字符串"><a href="#条款2-3-大小写不敏感的字符串" class="headerlink" title="条款2-3:大小写不敏感的字符串"></a>条款2-3:大小写不敏感的字符串</h4><blockquote>
<p>要求实现一个大小写不敏感的string类<br><strong>这里主要利用traits技术</strong></p>
</blockquote>
<ol>
<li><p>从STL的源码当中可以看到string是一个模板生成的类型</p>
<pre><code class="cpp">typedef basic_string&lt;char&gt; string;
//进一步看basic_string的声明如下
template&lt;class charT,class traits=char_traits&lt;charT&gt;,class Allocator = allocator&lt;charT&gt;&gt;
class basic_string;
</code></pre>
<p><del>关于traits技术还不是很理解，后面学了在补上</del><br>basic_string提供了一些判断字符串大于小于等于的函数，这些函数建立在traits上，如果希望改变比较多的行为可以通过提供自定义的traits来实现<br>&#96;&#96;&#96;cpp<br>&#x2F;&#x2F;通过继承去改变那些需要替换的函数,其安全性后面讨论<br>struct my_char_traits:public char_traits<char>{<br> static bool eq(char c1,char c2){<br> return toupper(c1)&#x3D;&#x3D;toupper(c2);<br> }</char></p>
<p> static bool lt(char c1,char c2){<br> return toupper(c1)&lt;toupper(c2);<br> }</p>
<p> static int compare(const char* s1,const char* s2,size_t n){<br> for(size_t i&#x3D;0;i&lt;n;++i){<br>     if(toupper(*s1)!&#x3D;toupper(*s2))<br>     return i;<br> ++s1,++s2;<br> }<br> }</p>
<p> static const char* find(const char* s,int n,char c){<br> while(n– &gt; 0&amp;&amp;toupper(*s)&#x3D;&#x3D;toupper(c)){<br>     ++s;<br> }<br> return n&gt;&#x3D;0?s:0;<br> }</p>
</li>
</ol>
<p>};<br>&#x2F;&#x2F;现在只需像string一样产生一个类型即可<br>typedef basic_string&lt;char,my_char_traits&gt; Mystring;</p>
<pre><code>

#### 条款4-5:可用性最高的泛型容器
* 模板构造函数不是构造函数，因此即使在类里面定义了模板构造函数，编译器仍会生成对应的隐式构造函数，但就算是模板拷贝函数也会阻止编译器对默认构造函数的生成，

#### 条款26- :编译防火墙和Pimpl技法
&gt; 习惯性地#include一些不必要的头文件会严重降低编译的效率和依赖性,尤其是这些头文件又包含了其它的头文件


~~简单地理解就是在你给客户看的头文件里能少用#include就少用#include,能不包含定义就不包含定义~~

*这里插一段可以帮助理解但不一定正确的描述：在设计一个东西的时候，就假设一个类，你要把接口的这些声明放在头文件里，而具体的实现是放在.c文件里，因为这里面有你的&quot;核心&quot;算法之类的东西，然后你编译好后这个.c文件就成了一个.o文件(这里很有可能不对，但可以先暂时这样理解-_-)，类的使用者也就是客户#include你给的头文件然后编译的时候去链接这个.o文件就行了,因此客户能了解到的这个类的所有信息都来自你的头文件*

```cpp
//本章将优化下面的代码
//下面的内容是x.h最初的内容,也即客户可以看到的代码
#include&lt;iostream&gt;
#include&lt;ostream&gt;
#include&lt;list&gt;

//A,B,C,D,E都不是模板
//只有A和C定义了虚函数

#include&quot;a.h&quot;
#include&quot;b.h&quot;
#include&quot;c.h&quot;
#include&quot;d.h&quot;
#include&quot;e.h&quot;
//包含的头文件里有相关类的声明与定义

class X:public A,private B&#123;
    public:
    X(const C&amp;);
    B f(int,char*);
    C f(int,C);
    C&amp; g(B);
    E h(E);
    virtual std::ostream&amp; print(std::ostream&amp; )const;
    private:
    std::list&lt;C&gt; clist_;
    D d_;
&#125;;

inline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os,const X&amp; x)&#123;

    return x.print(os);

&#125;
</code></pre>
<p><strong>只需要声明就不要#include其定义</strong><br>比较明显的,E的定义在此头文件内是不需要的,<strong>函数返回类型，参数类型，引用类型，指针类型这些都不需要看到类的定义，只要有一个声明即可</strong>#include”e.h”可以改成Class E;<br>另外应该也清楚&lt;iostream&gt;里面是包含&lt;ostream&gt;的，所以#include&lt;ostream&gt;也是可以删除的.但是,<iostream>里面包含了ostream的声明跟定义,在这个头文件里,用到的只是ostream&amp;这个引用类型,所以有没有一个头文件只包含了ostream的声明但不含其定义呢,有,&lt;iosfwd&gt;(ios forward declare),这个头文件包含了输入输出流的各个组件的声明式,而这些组件的定义则分布在各个不同的头文件,客户根据需要包含相应的头文件.这样就达到了”尽量少包含定义”的要求,因为输入输出流的组件是非常多的,但客户不一定都会使用到它们,根据需要只包含需要的定义即可,这跟Effective的条款31那里是符合的</iostream></p>
<pre><code class="cpp">//下面的代码会报错,说fstream这个类型是不完整的,因为fstream的定义在&lt;fstream&gt;里面
#include&lt;iostream&gt;
int main()
&#123;
    std::fstream out;
    //&lt;iostream&gt;里肯定有一个#include&lt;iosfwd&gt;,而&lt;iosfwd&gt;里面有fstream这个组件的声明,所以不会报no declaration的错误而是incomplete type的错误
    return 0;
&#125;
</code></pre>
<p>所以经过初步优化，代码是这样的</p>
<pre><code class="cpp">#include&lt;iosfwd&gt;
#include&lt;list&gt;

#include&quot;a.h&quot;
#include&quot;b.h&quot;
#include&quot;c.h&quot;
#include&quot;d.h&quot;
Class E;
class X:public A,private B&#123;
    public:
    X(const C&amp;);
    B f(int,char*);
    C f(int,C);
    C&amp; g(B);
    E h(E);
    virtual std::ostream&amp; print(std::ostream&amp; )const;
    private:
    std::list&lt;C&gt; clist_;
    D d_;
&#125;;

inline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os,const X&amp; x)&#123;

    return x.print(os);

&#125;
</code></pre>
<p>现在的代码达到了只要X的基类和公有接口不变,即使对X的结构做一些修改(比如加了一个private变量),使用了X的用户代码也不会受影响,只需要重新编译一下的地步,下面看能不能继续删除一些#include</p>
<ol>
<li>首先a.h和b.h现在不能删除的原因是X继承于A跟B,因此在此头文件内必须看到A与B的定义才能知道X的大小及其它一些必要信息如虚函数等</li>
<li>list,c.h和d.h现在不能删除的原因是list<C>和D是X的私有数据成员(因为作者写这本书是很久之前了,其实作为模板参数的C现在也不需要看到其定义了,因为在这个头文件里这里的list<C>其实也只是一个”声明”类似的东西,模板还没有真正实例化的,这个模板的实例化应该在X对象的实例化那里,所以其实这里的#include”c.h”也可以用Class C代替)必须要知道其定义才能确定X的大小</C></C></li>
</ol>
<ul>
<li>Pimpl(Pointer to implemention)出现<br>先上代码<pre><code class="cpp">#include&lt;iosfwd&gt;
#include&quot;a.h&quot;
#include&quot;b.h&quot;
class C;
class E;
class X:public A,private B&#123;
  public:
  //内容不变
  private:
  struct Ximpl;
  Ximpl* pimpl_;
&#125;;
</code></pre>
跟前面的代码相比,又少了三个#include分别是c,d跟list的头文件,然后private部分变成了一个指针,再看下现在x.cpp里的内容<br>&#96;&#96;&#96;cpp<br>#include”x.h”<br>#include”c.h”<br>#include”d.h”<br>#include<list><br>&#x2F;*<br>public接口的实现细目</list></li>
</ul>
<p>*&#x2F;<br>&#x2F;&#x2F;对X::Ximpl的定义<br>struct X::Ximpl{<br>    std::list<C> clist_;<br>    D d;<br>};</C></p>
<pre><code>可以看到删掉的三个#include被搬到x.cpp文件里来了,以及在X里的那个Ximpl的定义,其实就是把以前的private数据成员捆成了一个struct,然后让原来的类里面只有一个指针来访问这些成员

看完了变化现在再来说原因
&gt; cpp设置private是为了防止客户进行一些未授权的访问

举个例子,假设你写了一个表示圆的类,它现在用的是xy垂直坐标系,然后你定义它的数据成员是一个圆心的坐标和半径,你也设计了供客户使用的计算面积的函数Square。在你提供给客户的头文件内,客户是可以看到你通过一个坐标和半径来定义一个圆,然后如果没有private,也就是说客户可以直接访问这两个数据成员,那这个时候有的客户就觉得自己很牛,要自己写一个函数计算面积,反正他可以直接访问这些成员的,然后他就写好了计算面积的函数,并且用得很开心,但是有一天你说你觉得用xy垂直坐标不好,想用极坐标来表示一个圆,然后你更改了圆这个类的定义当然之前那些数据成员也肯定改了,而客户的那个计算面积的函数是严重依赖这些内部&quot;细节&quot;的,你用垂直坐标的方法计算极坐标肯定是错的,也就导致客代码中所有依赖直接访问数据成员的地方全部需要重写,这肯定是一个噩梦

上面的例子使用private就很好解决,将数据成员变成private,客户就算能看到细节也只能乖乖用提供的Square函数去,也就避免了客户写出一些依赖于这些细节的代码。

而上面优化后的头文件,直接把private的内容也封装起来了,直接让客户看都看不到实现细节,更进一步地解决了这个依赖问题,同时在这个头文件里不需要看到D跟list,这里是声明都不需要看到,D被替换成class D;是因为前面有个函数使用了D类型。现在随便你怎么改X的私有成员,客户代码甚至连编译都不需要重新编译了(必须感叹一下这个方法很牛(⌐■_■))但这个方法也有一些不足的地方,放到最后再讨论,下面再再看下能不能优化

上面不能优化的第二点已经被Pimpl给解决掉了,现在就剩a和b这两个头文件了
注意到B是私有继承,且B没有虚函数,这就有机会了
一般情况下,私有继承是能通过复合对象的方式给替换掉的,偏偏要使用私有继承一般都是为了能访问基类的protected成员和*重写其虚函数*

又举个例子,假设你要设计一个青蛙类,这个类的对象要每秒调用一次自己的GuaGua函数,这个时候你翻到了一个写好的定时器类,定义如下
```cpp
class Timer&#123;
    public:
    explicit Timer(int tickFrequency);//它有一个自己频率
    virtual void onTick()const; //依据频率,每多少秒就调用一次该函数
&#125;
//似乎可以这样定义Frog
class Frog:public Timer&#123;
    private:
    virtual void ontick()const&#123;
        GuaGua();
    &#125;
&#125;;
//首先这个ontick一定要变成private,如果变成public会让用户认为他们可以调用它,而对于一个青蛙来说它不应该有一个tick接口,其次采用继承的方式可以去重写那个onTick函数
</code></pre>
<p>上面的代码就说明了一种偏偏要使用私有继承的情况,但这种方式也绝非必要,仍然可以通过一些方式来达到相同的效果,如下:</p>
<pre><code class="cpp">class Frog&#123;
    private:
    class WidgetTimer:public Timer&#123;
        public:
        virtual void onTick()const;
    &#125;;
    WigetTimer timer_;
&#125;;
</code></pre>
<p>现在回归正题,B这个类并没有虚函数,如果我们再假设B没有保护成员,那私有继承这种关系就太”强”了我们用不到这么”强”的关系,将其作为私有成员即可,这样就能把B纳入struct XImpl_中了<br>下面是最终的x.h文件</p>
<pre><code class="cpp">#include&lt;iosfwd&gt;
#include&quot;a.h&quot;
class B;
class C;
class E;
class X:public A
&#123;
    public:
    X(const C&amp;);
    B f(int,char*);
    C f(int,C);
    C&amp; g(B);
    E h(E);
    virtual std::ostream&amp; print(std::ostream&amp; os,const X&amp; x)const;
    private:
    struct XImpl_;
    XImpl_ * pimpl_;
&#125;;
inline std::operator&lt;&lt;(std::ostream&amp; os,const X&amp; x)&#123;
    return x.print(os);
&#125;
</code></pre>
<p>现在这个头文件只有两个#include了!比起最初的代码真是非常大的改进( ⓛ ω ⓛ *)<br>但相应的还有一些代价问题需要讨论</p>
<ol>
<li>哪些部分应该放入XImpl？</li>
<li>在XImpl中是否应该加入一个指向X的回指指针？</li>
</ol>
<p>第一个问题的常见做法有两种</p>
<ol>
<li>将所有的私有成员放进XImpl中,但要注意不能将虚函数放到这里面来。因为如果派生类需要对基类的虚函数进行覆盖(这里提一下子类就算不能访问基类的private函数但能覆盖private函数),那这个虚函数就必须出现在实际的派生类当中,当然如果你不想一个函数被覆盖,把这个函数放进XImpl就起到了一个类似final的效果</li>
<li>将XImpl写成与原来的X完全一样的形式,X的作用就是去调用XImpl对应的接口,这种方法实现的X在继承时没什么大用,因为什么东西都在XImpl中,子类没法去覆盖相应的函数</li>
</ol>
<p>现在考虑第二个问题,首先想一想为什么要加一个回指指针,因为有些private函数操作会去调用public函数,如果没有这个回指指针XImpl就调用不了相应的函数在上面的方法一中有一个折中的方法就是把只有私有函数才会调用的非私有函数放到XImpl中这样就不需要一个回指指针了,这样的被调用的函数不一起放在XImpl的原因就是要给派生类覆盖.同理,方式2直接把所有的资源都放XImpl了更不需要回指指针了</p>
<p>现在考虑一下Pimpl的性能问题<br>1.最明显的就是内存分配需要的时间</p>
<pre><code class="cpp">//下面是可能的客户代码y.h与y.cpp
//1
#include&quot;x.h&quot;
class Y&#123;
    X x_;
&#125;;
Y::Y()&#123;&#125;
//上面要求X是明确可见的,所以有下面这种代码
//2,y.h
class X;
class Y&#123;
    X *px_;
&#125;;
//y.cpp
#include&quot;x.h&quot;
Y::Y():px_(new X)&#123;&#125;
Y::~Y()&#123;delete px_;px_=0;&#125;
//第2种方法很好地隐藏了X但如果程序里大量使用Y那动态分配内存可能降低程序的性能
</code></pre>
<p>2.其次是由于资源的由一个指针访问多了至少一层间接操作,同时空间上的开销也至少多了一个指针的开销,如果考虑到对齐多出来的空间是大于等于一个指针的大小的</p>
<h4 id="条款43-正确地使用const"><a href="#条款43-正确地使用const" class="headerlink" title="条款43:正确地使用const"></a>条款43:正确地使用const</h4><ul>
<li>void f(int x)与void f(const int x)对编译器来说是同一个函数，但后者在定义体当中仍不可修改x,如果同时定义上述两个函数编译会报错</li>
<li>但void f(int&amp;)与void f(const int&amp;)对编译器来说不一样</li>
<li>对于非内置类型的返回类型，一般加一个const修饰，以帮助客户检查出类似A+B&#x3D;C(实际想要操作A+B&#x3D;&#x3D;C)的错误</li>
</ul>
<h4 id="条款44-类型转换"><a href="#条款44-类型转换" class="headerlink" title="条款44:类型转换"></a>条款44:类型转换</h4><blockquote>
<ul>
<li>新形式的类型转化中,只有dynamic_cast与C语言不等价</li>
<li>如果没有虚函数,那dynamic_cast的操作都是错误的</li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>C++学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Kuangbin-并查集</title>
    <url>/2021/07/20/Kuangbin-%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="HDU3038"><a href="#HDU3038" class="headerlink" title="HDU3038"></a><a href="https://acm.dingbacode.com/showproblem.php?pid=3038">HDU3038</a></h2><p><em>2021.7.22</em></p>
<p>题意是假设有一段序列a，长度为n,接下来有m条信息 ，l r x表示a[l]+…+a[r]的这段区间之和为x,问这m条信息中哪些是错误的。比如1 100 10–1 10 1–11 100 2,很明显11 100 2是错误的，因为1 100 10 与 1 10 1可以推出11 100为9</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>带权并查集的应用</strong>首先从题的例子来观察，如果[1,10]的和为100，[7,10]的和为28，那就能推出来[1,6]为72，注意这里不是[1,7]，因为a[7]是在[7,10]这段序列里的，现在我们建立一个带权并查集，rela[x]表示x到自己根节点的距离，1 10 100就可以表示为pre[10]&#x3D;1,rela[10]&#x3D;100。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 200005;
int pre[maxn];
int rela[maxn];
int Find(int x) &#123;
    if (x == pre[x])
        return pre[x];
    int f = Find(pre[x]);
    rela[x] += rela[pre[x]];
    pre[x] = f;
    return pre[x];
&#125;

void merge(int Min, int Max,int num) &#123;
    int fx = Find(Min);
    int fy = Find(Max);
    //合并有两种情况，可以去手推一下面两种情况得出两种情况的合并公式
    //假设进来的Min为5，Max为8
    //第一种情况：pre[8]=0,rela[8]=100,即有信息1 8 100,pre[5]=3,rela[5]=10,即已有信息4 5 10
    //那显然应该让pre[3]=0,那rela[3]应该怎么算呢
    
    //第二种情况：pre[8]=3,pre[5]=0，显然还是应该让pre[3]=0，但rela[3]怎么计算（建议画图理解）
    if (fx != fy) &#123;
        if (fx &lt; fy) &#123;
            pre[fy] = fx;
            rela[fy] = rela[Min] + num - rela[Max];
        &#125;
        else &#123;
            pre[fx] = fy;
            rela[fx] = rela[Max] - num - rela[Min];
        &#125;
    &#125;
&#125;
int n, m, ans;
int main() &#123;
    while (cin &gt;&gt; n &gt;&gt; m)
    &#123;
        ans = 0;
        int a, b, c;
        for (int i = 0; i &lt;= n+1; i++) &#123;
            pre[i] = i;
            rela[i] = 0;
        &#125;
        while (m--) &#123;
            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
            a--;//这里是为了前面说到的那种1 10 100和7 10 28应该推出来[1,6]为72，而不是[1,7]为28,因此假设根节点为x，子节点为y，则rela[y]表示的是(x,y]这段区间的和，即[x+1,y]的和
            if (Find(a) == Find(b)) &#123;//如果两点的祖先相同，那通过两者与根节点距离之差可以推出来两者的距离的，就能拿来与c比较
                if (rela[b] - rela[a] != c) &#123;//与已知信息矛盾，则错误信息数加一
                    ans++;
                    continue;
                &#125;
            &#125;
            else &#123;
                merge(a, b, c);
            &#125;
        &#125;
        cout &lt;&lt; ans &lt;&lt; endl;
    &#125;
    return 0;
&#125;
</code></pre>
<h2 id="POJ1417-–-True-Liars"><a href="#POJ1417-–-True-Liars" class="headerlink" title="POJ1417 – True Liars"></a><a href="http://poj.org/problem?id=1417">POJ1417 – True Liars</a></h2><p>题意为知道好人与坏人的个数为p1，p2，并且有n条信息，每条信息格式为 a 说 b是好人或者坏人，规定好人永远说实话，坏人永远说谎话，则根据n条信息与已知的人数，能否推出哪些人是好人。</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>&#x3D;&#x3D;带权并查集与dp&#x3D;&#x3D;这种n条信息的与并查集的题形式很像，首先要分析出 <strong>a b yes</strong> 的形式出现时，就代表a b是同一阵营的，<strong>a b no</strong> 则代表两者不同阵营（可以去列一下情况看看），利用带权并查集可以将人分成一颗一颗的并查集树。剩下的就是通过这些树看能不能唯一构造出符合条件的人数。</p>
<p>现在我们知道的只是一团一团的人，每一团里有两个阵营，但是并不知道每个团里哪个阵营是好人。</p>
<p>定义<strong>dp[i][j]:&#x3D;前i棵树恰好凑出j个人有多少种情况</strong>，如果最后dp[NumOfTree][p1]&#x3D;&#x3D;1,则说明有解。这道题虽然有dp但其实想到dp之后，dp的转移方程并不难，为dp[i][j]&#x3D;dp[i-1][j-第i棵树中与根同一阵营的人数]+dp[i-1][j-第i棵树与根不同阵营的人数]，从转移方程中也可以看出需要记录每一棵并查集树底下两个阵营的人数，因为要输出哪些人是好人，所以每棵树还需要记录底下哪些人跟自己是同一阵营的，哪些不是。</p>
<p>代码如下</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
using namespace std;

const int maxn = 1e3 + 5;
int pre[maxn];
vector&lt;int&gt; tree[maxn];//粗糙地记录根节点下有哪些节点
vector&lt;int&gt; same[maxn];//same[i]表树第i颗树里，与根节点相同阵营的节点编号
vector&lt;int&gt; differ[maxn];
int rela[maxn];//权数组，0为同一阵营，1为不同阵营
int SameNum[maxn];//SameNum[i]表示第i棵树里与根节点同一阵营的人数
int DifferNum[maxn];
int dp[maxn][maxn];
vector&lt;int&gt;ans;//存最后要输出哪些人
int n, p1, p2;
void init() &#123;
    for (int i = 1; i &lt;= p1 + p2; i++) &#123;
        pre[i] = i;
        same[i].clear();
        differ[i].clear();
        tree[i].clear();
    &#125;
    memset(rela, 0, sizeof(rela));//初始情况每个人与自己同一阵营
    memset(SameNum, 0, sizeof(SameNum));
    memset(DifferNum, 0, sizeof(DifferNum));
    memset(dp, 0, sizeof(dp));
    ans.clear();
&#125;

int Find(int x) &#123;
    if (pre[x] == x) &#123;
        return pre[x];
    &#125;
    int root = Find(pre[x]);
    rela[x] ^= rela[pre[x]];//带权并查集Find的套路操作，在找根的过程中要更新关系
    pre[x] = root;
    return pre[x];
&#125;

void merge(int x, int y, int r) &#123;
    int fx = Find(x);
    int fy = Find(y);
    if (fx != fy) &#123;
        pre[fx] = fy;
        rela[fx] = rela[x] ^ rela[y] ^ r;//带权并查集套路操作，使用^是应为只有0,1两种关系，其它多种关系情况要具体分析
    &#125;
&#125;

int main() &#123;
    ios::sync_with_stdio(false);
    cin.tie(0);
    while (cin &gt;&gt; n &gt;&gt; p1 &gt;&gt; p2) &#123;
        if (n == p1 &amp;&amp; p1 == p2 &amp;&amp; n == 0)
            break;
        init();//记得并查集每次要初始化
        for (int i = 0; i &lt; n; i++) &#123;
            int a, b;
            string s;
            cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;
            if (s == &quot;yes&quot;)
                merge(a, b, 0);
            else
                merge(a, b, 1);
        &#125;
        //好人与坏人一样多，肯定判断不了
        if (p1 == p2) &#123;
            cout &lt;&lt; &quot;no&quot; &lt;&lt; endl;
            continue;
        &#125;
        //将现在的森林第一步粗加工，使每个根节点先知道自己有哪些子孙
        for (int i = 1; i &lt;= p1 + p2; i++) &#123;
            int fa = Find(i);
            tree[fa].push_back(i);
        &#125;
        int cnt = 1;//用来给树编号
        //第二步加工，每棵树编号，并筛出两个阵营的人数与具体哪些人
        for (int i = 1; i &lt;= p1 + p2; i++) &#123;
            if (tree[i].size()) &#123;
                for (int j = 0; j &lt; tree[i].size(); j++) &#123;
                    if (rela[tree[i][j]] == 0) &#123;
                        SameNum[cnt]++;
                        same[cnt].push_back(tree[i][j]);
                    &#125;
                    else &#123;
                        DifferNum[cnt]++;
                        differ[cnt].push_back(tree[i][j]);
                    &#125;
                &#125;
                cnt++;
            &#125;
        &#125;

        dp[0][0] = 1;//dp初始定义，注意init里面已经将dp全置为0了
        //dp[i][j]:==前i棵树组出j个人的方式有多少种
        for (int i = 1; i &lt; cnt; i++) &#123;
            for (int j = 0; j &lt;= p1; j++) &#123;
                if (j &gt;= SameNum[i]) &#123;
                    dp[i][j] += dp[i - 1][j - SameNum[i]];
                &#125;
                if (j &gt;= DifferNum[i]) &#123;
                    dp[i][j] += dp[i - 1][j - DifferNum[i]];
                &#125;
            &#125;
        &#125;

        if (dp[cnt - 1][p1] != 1) &#123;//不唯一，或无解
            cout &lt;&lt; &quot;no&quot; &lt;&lt; endl;
        &#125;
        else &#123;
            for (int i = cnt - 1; i &gt;= 1; i--) &#123;
                //如果最后的结果有唯一解，说明该状态下的前一个状态也一定唯一，因此从后往前推
                if (p1 &gt;= SameNum[i] &amp;&amp; dp[i - 1][p1 - SameNum[i]] == 1) &#123;
                    for (int j = 0; j &lt; same[i].size(); j++) &#123;
                        ans.push_back(same[i][j]);
                    &#125;
                    p1 -= SameNum[i];
                &#125;
                else &#123;
                    for (int j = 0; j &lt; differ[i].size(); j++) &#123;
                        ans.push_back(differ[i][j]);
                    &#125;
                    p1 -= DifferNum[i];
                &#125;
            &#125;
            sort(ans.begin(), ans.end());//升序排列
            for (int i = 0; i &lt; ans.size();i++) &#123;
                cout &lt;&lt; ans[i] &lt;&lt; endl;
            &#125;
            cout &lt;&lt; &quot;end&quot; &lt;&lt; endl;

        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<h4 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h4><p>看到这种类型的信息要想到是不是可能用并查集，之后分析出怎么从给出的信息来确定两个节点的关系，为了方便后面的dp，中间有很多工作都是在去优化结构来使得访问方便，也是数据结构设计为使用方便的一个体现</p>
<h2 id="Connections-in-Galaxy-War-ZOJ-3261"><a href="#Connections-in-Galaxy-War-ZOJ-3261" class="headerlink" title="Connections in Galaxy War - ZOJ 3261"></a><a href="https://zoj.pintia.cn/problem-sets/91827364500/problems/91827368062">Connections in Galaxy War - ZOJ 3261</a></h2><p><em>2021.7.20</em></p>
<p>题目大意为给定点的数量，编号0到n-1，每个点有各自的权值，再给M条信息，哪两个点直接相连。现在有Q个操作，每个操作有两种情况，一种是Query a,查询与a连通的点权值最大编号最小的点，如果最大权值比a小则输出-1，否则输出找到的编号；第二种情况是Destroy a b,表示切断a 与 b直接相连的边。</p>
<!---more--->

<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

const int maxn = 1e4 + 5;

map&lt;pair&lt;int, int&gt;, bool&gt; mp;
struct node &#123;
    int a, b;
    int flag;
&#125;operation[maxn*5];
int pre[maxn];
int power[maxn];
int ans[maxn * 5];
int n, m, q;
void init() &#123;
    for (int i = 0; i &lt; n; i++) &#123;
        pre[i] = i;
    &#125;
&#125;
int Find(int x) &#123;
    return x == pre[x] ? x : (pre[x] = Find(pre[x]));
&#125;
void merge(int x, int y) &#123;
    int fx = Find(x);
    int fy = Find(y);
    if (fx != fy) &#123;
        if (power[fx] &gt; power[fy] || power[fx] == power[fy] &amp;&amp; fx &lt; fy)
            pre[fy] = fx;
        else
            pre[fx] = fy;
    &#125;
&#125;

int main()
&#123;
    ios::sync_with_stdio(0);
    cin.tie(0);
    int tag = 1;
    while (cin &gt;&gt; n) &#123;
        init();
        mp.clear();
        if (tag == 0)
            cout &lt;&lt; endl;
        else
            tag = 0;
        for (int i = 0; i &lt; n; i++)
            cin &gt;&gt; power[i];
        int t;
        cin &gt;&gt; t;
        while (t--) &#123;
            int a, b;
            cin &gt;&gt; a &gt;&gt; b;
            if (a &gt; b)
                swap(a, b);
            mp[&#123;a, b&#125;] = true;
        &#125;
        cin &gt;&gt; q;
        for (int i = 0; i &lt; q; i++) &#123;
            string s;
            int a, b;
            cin &gt;&gt; s;
            if (s == &quot;query&quot;) &#123;
                cin &gt;&gt; a;
                operation[i] = &#123; a,0,1 &#125;;
            &#125;
            else &#123;
                cin &gt;&gt; a &gt;&gt; b;
                if (a &gt; b)
                    swap(a, b);
                operation[i] = &#123; a,b,0 &#125;;
                mp[&#123;a, b&#125;] = false;
                
            &#125;
        &#125;

        for (auto&amp; i : mp) &#123;
            if (i.second) &#123;
                merge(i.first.first, i.first.second);
            &#125;
        &#125;
        int cnt = 0;
        for (int i = q - 1; i &gt;= 0; i--) &#123;
            if (operation[i].flag == 0) &#123;
                merge(operation[i].a, operation[i].b);
            &#125;
            else &#123;
                int tmp = Find(operation[i].a);
                if (power[tmp] &gt; power[operation[i].a] &amp;&amp; tmp != operation[i].a)
                    ans[cnt++] = tmp;
                else
                    ans[cnt++] = -1;
            &#125;
        &#125;
        for (int i = cnt - 1; i &gt;= 0; i--) &#123;
            cout &lt;&lt; ans[i] &lt;&lt; endl;
        &#125;

    &#125;
    return 0;
&#125;
</code></pre>
<h2 id="POJ2492-–-A-Bug’s-Life"><a href="#POJ2492-–-A-Bug’s-Life" class="headerlink" title="POJ2492 – A Bug’s Life "></a><a href="http://poj.org/problem?id=2492">POJ2492 – A Bug’s Life </a></h2><p><em>2021.7.20</em></p>
<p>题意是给定点的数量和关系数目，每个点都有一种性别，总共两种性别，在接下来的信息中表示两个点有互动，即两个点是异性的，判断给出的信息中是否出现了同性互动。</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p><strong>简单带权并查集的应用</strong> ，像这种关系只有两种的并查集可以通过异或来操作，其它情况也有相应的公式，这道题就是一行一行的扫描合并，只不过在合并过程当中如果发现已经连通要判断一下两者关系，如果两者与根节点的关系相同那两者就是同性。</p>
<!---more--->

<pre><code class="cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn = 2005;
int pre[maxn];
int rela[maxn];//关系数组，存的是节点与父亲节点的关系，而不是与根的关系，在Find那里要用到
int n, m;
int Case;
void init()
&#123;
    for (int i = 0; i &lt;= n; i++)
        pre[i] = i;
    //这里初始要将rela设为0表示自己与自己是同性的
    memset(rela, 0, sizeof(rela));
&#125;
int Find(int x) &#123;
    if (x == pre[x])
        return x;
    int root = Find(pre[x]);
    rela[x] ^= rela[pre[x]];//此时的pre[x]还是原来的父亲，由于是递归的，此刻父亲的父亲即pre[pre[x]]已经指向根节点了，而rela[pre[x]]就是此刻父亲节点与根节点的关系，由于要压缩路径需要把x的父亲指向root，因此x与root的关系可以又此刻的父亲pre[x]来搭建，就有了rela[x]^rela[pre[x]],因为这是一个只有01两种情况的并查集才用异或，其它情况就需要分析一下
    pre[x] = root;//关系确定好后改变自己的父亲节点
    //因此每一次调用Find都会更新出x与root的关系
    return root;
&#125;
inline void merge(int x, int y, int flag) &#123;
    int fx = Find(x);
    int fy = Find(y);
    if (fx != fy) &#123;
        pre[fx] = fy;
        rela[fx] = rela[x] ^ rela[y] ^ flag;//套路，可以枚举一下情况看看是不是对的。其实也能理解肯定需要知道x与fx的关系和y与fy的关系，然后通过x与y的关系flag将fx与fy联系起来，只不过这里是恰好用到了异或，其它情况不一定是异或但肯定需要这三个数据
    &#125;
&#125;
int main()
&#123;
    scanf(&quot;%d&quot;, &amp;Case);
    int id = 1;
    while (Case--) &#123;
        printf(&quot;Scenario #%d:\n&quot;, id++);
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        init();
        bool flag = true;
        while (m--) &#123;
            int a, b;
            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
            if (!flag)
                continue;
            if (Find(a) == Find(b) &amp;&amp; rela[a] == rela[b]) &#123;//同祖先，与祖先的关系还相同
                flag = false;
            &#125;
            else &#123;
                merge(a, b, 1);
            &#125;
        &#125;
        if (flag) &#123;
            printf(&quot;No suspicious bugs found!\n\n&quot;);
        &#125;
        else &#123;
            printf(&quot;Suspicious bugs found!\n\n&quot;);
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<h2 id="POJ2912-–-Rochambeau"><a href="#POJ2912-–-Rochambeau" class="headerlink" title="POJ2912 – Rochambeau"></a><a href="http://poj.org/problem?id=2912">POJ2912 – Rochambeau</a></h2><p><em>2021.7.20</em></p>
<p>题意是给定人数和信息数，这些人可以被分成三组，三组的关系就是石头剪刀布的关系，相互克制，一个组的人永远出一个手势，但所有人当中有一个裁判会随便出，在接下来的信息当中能否判断谁是裁判，并输出最少判断出裁判是谁是在第几条信息之后，如果无法判断或者有矛盾的情况分别判断出来。</p>
<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p><strong>枚举加并查集</strong> 首先可以确定的是没有裁判的话就不会有矛盾出现，因为三组人分别只会出自己那组的手势，<strong>也就是说裁判会导致矛盾的出现</strong>，那我们可以去枚举每个编号，第一层for循环用来枚举编号，并且每次都要init并查集，每条信息是以结构体存储的，第二层for枚举所有的边，用与该节点无关的边建立并查集，如果还是出现了矛盾那该节点就肯定不是裁判，记录可能是裁判的个数，最后判断是不是恰好为1,为0就是Impossible,大于1则无法判断。</p>
<p>最后是要判断在第几行可以得出裁判，因为要判断n-1个人都不是裁判，因此最少行应该是判断出n-1个人不是裁判里最长的那个信息，具体参见代码</p>
<pre><code class="cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 505;
int pre[maxn];
int rela[maxn];
struct node &#123;
    int x, y;
    char flag;//本题采用的是离线操作，需要存储每条边的信息
&#125;r[2005];
int n, m;
int Case;
void init()
&#123;
    for (int i = 0; i &lt;= n; i++)
        pre[i] = i;
    memset(rela, 0, sizeof(rela));
&#125;
int Find(int x) &#123;
    if (x == pre[x])
        return x;
    int root = Find(pre[x]);
    rela[x] = (rela[x] + rela[pre[x]]) % 3;//公式得出详见下图
    pre[x] = root;
    return root;
&#125;
inline bool merge(int x, int y,int flag) &#123;
    int fx = Find(x);
    int fy = Find(y);
    if (fx != fy) &#123;
        pre[fx] = fy;
        rela[fx] = (rela[y] + flag - rela[x] + 3) % 3;//公式得出详见下图
        return true;
    &#125;
    else &#123;
        if ((rela[x] - rela[y] + 3) % 3 != flag)
            return false;
    &#125;
&#125;
int main()
&#123;
    while (cin &gt;&gt; n &gt;&gt; m) &#123;

        for (int i = 1; i &lt;= m; i++) &#123;
            int a, b;
            char c;
            cin &gt;&gt; r[i].x &gt;&gt; r[i].flag &gt;&gt; r[i].y;
        &#125;
        int ans = 0;
        int pos, lstline = 0;
        for (int i = 0; i &lt; n; i++) &#123;
            init();
            bool flag = true;
            for (int j = 1; j &lt;=m; j++) &#123;
                if (r[j].x == i || r[j].y == i)
                    continue;
                if (!merge(r[j].x, r[j].y, r[j].flag == &#39;=&#39; ? 0 : (r[j].flag == &#39;&lt;&#39; ? 1 : 2))) &#123;
                    flag = false;
                    lstline = max(j, lstline);//记录每次判断出来哪个编号不是裁判需要的最大边的编号
                    break;
                &#125;
            &#125;
            if (flag) &#123;
                ans++;//记录裁判人数
                pos = i;//记录裁判编号
            &#125;
        &#125;

        if (ans == 0) &#123;
            printf(&quot;Impossible\n&quot;);
        &#125;
        else if (ans == 1) &#123;
            printf(&quot;Player %d can be determined to be the judge after %d lines\n&quot;,pos,lstline);
        &#125;
        else &#123;
            printf(&quot;Can not determine\n&quot;);
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<h2 id="POJ1733-–-Parity-game"><a href="#POJ1733-–-Parity-game" class="headerlink" title="POJ1733 – Parity game"></a><a href="http://poj.org/problem?id=1733">POJ1733 – Parity game</a></h2><p><em>2021.7.23</em></p>
<p>这道题跟how many wrong那道题很像,题意是一个01序列最多能满足到下列第几条信息</p>
<p>每条信息由a b s组成，表示[a,b]这段区间内1的个数为偶数或者奇数个</p>
<h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p><strong>带权并查集处理区间关系与离散化处理数据</strong>。思路也跟那道题很像，只不过那道题的关系更偏向于一种距离。容易发现如果[a,b]这段区间内的1为偶数个，那么</p>
<p>[1,b]与[1,a-1]含有的1的个数奇偶性是相同的，反之则相反，这就能将a,b建立起一种关系了，这个关系就是并查集需要维护的，另外的就是这道题的N开得很大，但实际数字比较少，直接开一个Pre[N]会爆空间，对数据进行一个离散化的处理即可。即假设有数据10 2 8 4 100000000，先用一个数组把这些数据存起来，之后就假设按照升序排序，那就应该是[2,4,8,10,100000000],只需要开一个pre[4]即可，利用一个中间函数Query(int)将数字映射到相应的位置即可，即假设要让100000000的根为2,那实际的操作就是pre[Query(100000000)]&#x3D;pre[Query(2)],即pre[5]&#x3D;pre[1]。最后有可能下面所有信息都能满足，这个地方wa了一次┑(￣Д ￣)┍</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 1e4 + 5;
int pre[maxn];
int pos[maxn];//离散映射数组，pos[i]表示第i大的数字
int rela[maxn];
int n, m;
int cnt = 0;
struct node &#123;
    long long a, b;
    int flag;
&#125;info[maxn];//离线操作,存储信息，一方面是离散化需要得到所有数据，一方面是就算之前能判断出结果还是需要读掉后面的数据。
int num[maxn * 2];//离散操作需要的数组，因为该数组会先存好所有数据，每条信息两个数字，开到maxn*2
//离散化函数
void decret() &#123;
    sort(num, num + m * 2);//先排序
    for (int i = 0; i &lt; m * 2; i++) &#123;
        if (!i || num[i] != num[i - 1]) &#123;//后面这个判断是去掉那些重复的数字，防止[1,2,2,2]这种情况将2多次存到pos里面
            pos[cnt++] = num[i];
        &#125;
    &#125;
&#125;
int Query(long long x) &#123;
    return lower_bound(pos,pos+cnt, x) - pos;//x在pos中的位置就能代表x
&#125;
int Find(int x) &#123;

    if (x == pre[x])
        return pre[x];
    int root = Find(pre[x]);
    rela[x] ^= rela[pre[x]];
    pre[x] = root;
    return pre[x];
&#125;
void merge(int x, int y,int flag) &#123;
    int fx = Find(x);
    int fy = Find(y);
    if (fx != fy) &#123;
        pre[fx] = fy;
        rela[fx] = rela[x] ^ rela[y] ^ flag;
    &#125;
&#125;
int main()
&#123;
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 0; i &lt; m * 2; i++) &#123;
        pre[i] = i;
    &#125;
    int id = 0;
    char s[10];
    
    for (int i = 0; i &lt; m; i++) &#123;
        cin &gt;&gt; info[i].a &gt;&gt; info[i].b &gt;&gt; s;
        if (s[0] == &#39;e&#39;) &#123;
            info[i].flag = 0;//如果是偶数个是不会改变之前的奇偶性的，而异或操作当中与0异或结果不变，所以用0代表是偶数个
        &#125;
        else
            info[i].flag = 1;
        info[i].b++;//跟那道题一样，边界交界处的处理
        num[id++] = info[i].a;
        num[id++] = info[i].b;
    &#125;
    decret();
    int i;
    for ( i = 0; i &lt; m; i++) &#123;
        if (Find(Query(info[i].a)) != Find(Query(info[i].b))) &#123;
            merge(Query(info[i].a),Query(info[i].b), info[i].flag);
        &#125;
        else if (rela[Query(info[i].a)] ^ rela[Query(info[i].b)] != info[i].flag)&#123;
            cout &lt;&lt; i &lt;&lt; endl;
            break;
        &#125;
    &#125;
    if (i == m)//万一人家能全满足呢
        cout &lt;&lt; i &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<h2 id="POJ1984-–-Navigation-Nightmare"><a href="#POJ1984-–-Navigation-Nightmare" class="headerlink" title="POJ1984 – Navigation Nightmare"></a><a href="http://poj.org/problem?id=1984">POJ1984 – Navigation Nightmare</a></h2><p>题意是有N个农场标号1到N，它们分布在一个二维平面上，两个农场之间只能由垂直或者水平的路连接.会给定m条信息 a b c s,表示农场从a往s方向走c的距离就能到达b，比如1 2 10 S表示2在1以南10的距离。需要处理输入a b index表示从前面的index条信息中能否得到a到b的曼哈顿距离,曼哈顿距离就是$|x_1-x_2|+|y_1-y_2|$​.(1,2)与(5,7)的曼哈顿距离就为9</p>
<h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p><strong>多重带权并查集</strong>，如果只有一条线上是很好分析的，就是假设1到2的距离知道，2到3的距离知道那很容易推出1到3的距离，典型的一个带权并查集就够了，现在这道题是在一个二维平面上，但它的连接方式只有水平跟垂直两种，所要求的曼哈顿距离也是水平跟垂直分开求的，所以可以开两个权值数组，用来分别维护水平和竖直两个直线方向上的关系即可求解。另外需要注意一下的是这道题的index是非递减的，之前每次处理一个输入就要清空并查集再重新建立就TE了，我也是看了别人的博客才看到的，之前就一直TE ┑(￣Д ￣)┍</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn = 4e4 + 5;
int n, m, k;
int pre[maxn];
int vertical[maxn];
int horisontal[maxn];
struct node &#123;
    int a, b;
    int h, v;
&#125;info[maxn];//离线操作，存储信息
void init() &#123;
    for (int i = 0; i &lt;= n; i++) &#123;
        pre[i] = i;
        vertical[i] = 0;
        horisontal[i] = 0;
    &#125;
    memset(info, 0, sizeof(0));//这里主要是为了把h与v置为0，但是放在静态区本来也会置为0
&#125;
int Find(int x) &#123;
    if (x == pre[x])
        return pre[x];
    int root = Find(pre[x]);
    //每次维护的时候两个方向的权值数组信息要同时维护
    vertical[x] += vertical[pre[x]];
    horisontal[x] += horisontal[pre[x]];
    pre[x] = root;
    return pre[x];
&#125;
void merge(int x, int y, int ver, int hor) &#123;
    int fx = Find(x);
    int fy = Find(y);
    if (fx ^ fy) &#123;
        pre[fx] = fy;
        //很简单的公式，画一下图就能推出来
        vertical[fx] = vertical[y] + ver - vertical[x];
        horisontal[fx] = horisontal[y] + hor - horisontal[x];
    &#125;
&#125;
int main()
&#123;

    cin &gt;&gt; n &gt;&gt; m;
    init();
    char s[10];
    int tmp;
    for (int i = 1; i &lt;= m; i++)
    &#123;
        cin &gt;&gt; info[i].a &gt;&gt; info[i].b;
        cin &gt;&gt; tmp &gt;&gt; s;
        if (s[0] == &#39;N&#39;) &#123;
            info[i].h = tmp;
        &#125;
        else if (s[0] == &#39;S&#39;) &#123;
            info[i].h = -tmp;//规定好方向
        &#125;
        else if (s[0] == &#39;E&#39;) &#123;
            info[i].v = tmp;
        &#125;
        else &#123;
            info[i].v = -tmp;
        &#125;

    &#125;
    cin &gt;&gt; k;
    int now = 1;
    while (k--) &#123;
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        for (; now &lt;= c; now++) &#123;//由于index非递减才有这个for循环
            merge(info[now].a, info[now].b, info[now].v, info[now].h);
        &#125;
        if (Find(a) != Find(b)) &#123;
            cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;
        &#125;
        else &#123;
            cout &lt;&lt; abs(vertical[a] - vertical[b]) + abs(horisontal[a] - horisontal[b]) &lt;&lt; endl;
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>acm学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Kuangbin-简单搜索</title>
    <url>/2021/07/20/Kuangbin-%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="简单搜索"><a href="#简单搜索" class="headerlink" title="简单搜索"></a>简单搜索</h1><p>[poj1321](##<a href="http://poj.org/problem?id=1321">POJ1321 – 棋盘问题 </a>)</p>
<h2 id="POJ1321-–-棋盘问题"><a href="#POJ1321-–-棋盘问题" class="headerlink" title="POJ1321 – 棋盘问题"></a><a href="http://poj.org/problem?id=1321">POJ1321 – 棋盘问题</a></h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>变版的八皇后问题，只不过棋盘不再规则只能在某些格子放棋子而已，思路不变。先假设前面k行已经摆好且没有相互矛盾，那在第k+1行就有摆和不摆两种选择，如果摆，那又有摆在哪一列的选择，用一个col数组记录前面哪些列已经用过了，如果col[x]的状态表示没有用过，那[k+1][x]就是一个可行的位置，把col[x]标记一下，然后继续向下一行探索。</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
bool col[10];//存哪些列用过来了,false表示没用过
char grid[10][10];//存图
int n, k, ans;
void dfs(int line, int num) &#123;//line表示现在在第几行，num表示前面填好了几个
    if (line==n||num == k) &#123;//行号最多n-1,到n肯定不行了
        if (num == k)//如果已经填好k个，总方案数加1
            ans++;
        return;
    &#125;
    for (int i = 0; i &lt; n; i++) &#123;
        //在该行填，将改行的每一列遍历一遍，看看哪些列可以填
        if (!col[i] &amp;&amp; grid[line][i] == &#39;#&#39;) &#123;
            col[i] = true;
            dfs(line + 1, num + 1);
            col[i] = false;//j
        &#125;
    &#125;
    //不在改行填，所以num没有加1
    dfs(line + 1, num);
&#125;
int main()
&#123;
    while (cin &gt;&gt; n &gt;&gt; k) &#123;
        if (n == k &amp;&amp; n == -1)
            break;
        memset(col, false, sizeof(col));//初始化
        ans = 0;
        for (int i = 0; i &lt; n; i++) &#123;
            cin &gt;&gt; grid[i];
        &#125;
        dfs(0, 0);//从第0行开始，已经填好0个
        cout &lt;&lt; ans &lt;&lt; endl;
    &#125;
    return 0;
&#125;
</code></pre>
<h2 id="POJ3278-3278-–-Catch-That-Cow-poj-org"><a href="#POJ3278-3278-–-Catch-That-Cow-poj-org" class="headerlink" title="[POJ3278](3278 – Catch That Cow (poj.org))"></a>[POJ3278](<a href="http://poj.org/problem?id=3278">3278 – Catch That Cow (poj.org)</a>)</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>该题注意剪枝，不让会RE（虽然我用的map），剪枝不可将x+1&gt;K和x*2&gt;k的情况剪掉，例如100-&gt;199</p>
<p>另外由于时间卡得比较紧，数量比较大所以不能用map，用map会TE</p>
<h2 id="poj3279"><a href="#poj3279" class="headerlink" title="poj3279"></a><a href="http://poj.org/problem?id=3279">poj3279</a></h2><p>题意大概说的是给定一个m*n的01矩阵，每次去翻一个位置周围四个方向的位置都会翻转，问能不能翻到全是0，能的话输出字典序最小的翻法</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>这是遇到的第一个枚举题，二进制枚举，首先确定的是每个位置只有翻和不翻两种情况，翻两次等于没翻，翻奇数次等于一次。如果去考察每一个位置的翻的情况就会有2^mn^次结果，显然时间超限，观察（看博客）易得出规律——&#x3D;&#x3D;假设第一行的状态确定（就是第一行哪些位置翻不翻确定，确定之后会得到第一行确定的状态，哪些位置是0哪些是1），从第二行开始扫描，如果发现该位置上头上的位置为1那该位置一定要翻，因为头上的位置上左右都确定了&#x3D;&#x3D;，以此扫描完整个数组，最后再对最后一行做一个检查，如果有1则不行，因为现在只能由下一行来翻转该位置，但没有下一行。</p>
<blockquote>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
using namespace std;
const int maxn = 20;
int n, m;
int maze[maxn][maxn];
int grid[maxn][maxn];
int ans[maxn][maxn];
int dir[5][2] = &#123; &#123;0,0&#125;,&#123;1,0&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;0,-1&#125; &#125;;
bool legal(int x, int y) &#123;
    return (x &gt;= 0 &amp;&amp; x &lt; n&amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m);
&#125;
void flip(int x, int y) &#123;
    ans[x][y] = 1;
    int nx, ny;
    for (int i = 0; i &lt; 5; i++) &#123;
        nx = x + dir[i][0];
        ny = y + dir[i][1];
        if (legal(nx, ny)) &#123;
            grid[nx][ny] ^= 1;
        &#125;
    &#125;
&#125;
void solve() &#123;
    for (int i = 0; i &lt; n; i++) &#123;
        for (int j = 0; j &lt; m; j++) &#123;
            printf(&quot;%d%c&quot;, ans[i][j], &quot; \n&quot;[j == (m - 1)]);
        &#125;
    &#125;
&#125;
int main() &#123;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 0; i &lt; n; i++) &#123;
        for (int j = 0; j &lt; m; j++) &#123;
            scanf(&quot;%d&quot;, &amp;maze[i][j]);
        &#125;
    &#125;
    int end = 1 &lt;&lt; m;
    int bsk;
    bool ok = true;
    for (int i = 0; i &lt; end; i++) &#123;
        ok = true;
        bsk = i;
        memcpy(grid, maze, sizeof(maze));
        memset(ans, 0, sizeof(ans));
        for (int k = 0; k &lt; m; k++) &#123;
            if (bsk &amp; 1)
                flip(0, k);
            bsk &gt;&gt;= 1;
        &#125;
        for (int j = 1; j &lt; n; j++) &#123;
            for (int k = 0; k &lt; m; k++) &#123;
                if (grid[j - 1][k])
                    flip(j, k);
            &#125;
        &#125;
        for (int k = 0, j = n - 1; k &lt; m; k++) &#123;
            if (grid[j][k]) &#123;
                ok = false;
                continue;
            &#125;
        &#125;
        if (ok) &#123;
            solve();
            break;
        &#125;
    &#125;
    if (!ok)
        printf(&quot;IMPOSSIBLE\n&quot;);
    return 0;
&#125;
</code></pre>
</blockquote>
<h2 id="POJ1426-–-Find-The-Multiple"><a href="#POJ1426-–-Find-The-Multiple" class="headerlink" title="POJ1426 – Find The Multiple "></a><a href="http://poj.org/problem?id=1426">POJ1426 – Find The Multiple </a></h2><p>题意大概是给一个数字n,找出一个n的十进制倍数m，m只能由01组成</p>
<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>虽然这道题说m不超过100位，但用unsigned long long过了，要是完全按照题意的话就还要处理大数问题，看其它文章好像也没有很好的可以解决，就直接当unsigned long long 过了</p>
<p>bfs和dfs都可以，dfs注意判断不要溢出,当然由于n比较小可以先得出200个结果打表然后再过，因为可能搜索会超时，时间卡得较紧</p>
<pre><code class="c++">#include&lt;iostream&gt;
#include&lt;queue&gt;
using namespace std;

int n;
typedef unsigned long long ull;
void bfs() &#123;
    queue&lt;ull&gt; que;
    que.push(1);

    while (!que.empty()) &#123;
        ull tmp = que.front();
        que.pop();
        if (tmp % n == 0) &#123;
            cout &lt;&lt; tmp &lt;&lt; endl;
            return;
        &#125;
        que.push(tmp * 10);
        que.push(tmp * 10 + 1);
    &#125;
&#125;
int main()
&#123;
    while (cin &gt;&gt; n&amp;&amp;n) &#123;
        bfs();
    &#125;
    return 0;
&#125;
</code></pre>
<h2 id="hdu2612"><a href="#hdu2612" class="headerlink" title="hdu2612"></a><a href="https://acm.dingbacode.com/showproblem.php?pid=2612">hdu2612</a></h2><p>题意为求两个人要到同一个@需要的最少步数乘以11.</p>
<h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>两边bfs之后将每次每一个@的步数相加，最后找出最小的那个@即可，但是要注意可能有些@是两个人都到不了的，其步数一直为0所以最后需要特殊判断一下，我legal判断x&lt;n写成x&lt;m了，RE了好几发━┳━　━┳━</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
vector&lt;string&gt; maze;
struct node &#123;
    int x, y, v;
    void init(int _x, int _y) &#123;
        x = _x;
        y = _y;
        v = 0;
    &#125;
    node(int _x, int _y) &#123;
        x = _x;
        y = _y;
        v = 0;
    &#125;
    node() &#123;&#125;
&#125;;
vector&lt;node&gt; End;
node yifenfi, mercki;
int n, m;
int dir[4][2] = &#123; &#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125; &#125;;
bool legal(int x, int y, vector&lt;string&gt;&amp; grid) &#123;
    return (x &gt;= 0 &amp;&amp; x &lt; n&amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m&amp;&amp; grid[x][y] != &#39;#&#39;);
&#125;
void bfs(node&amp; start) &#123;
    vector&lt;string&gt; grid(maze.begin(), maze.end());
    int step[205][205];
    memset(step, 0, sizeof(step));
    queue&lt;node&gt; que;
    grid[start.x][start.y] = &#39;#&#39;;
    que.push(start);
    while (!que.empty()) &#123;
        node tmp = que.front();
        que.pop();
        int nx, ny;
        for (int i = 0; i &lt; 4; i++) &#123;
            nx = tmp.x + dir[i][0];
            ny = tmp.y + dir[i][1];
            if (legal(nx, ny, grid)) &#123;
                step[nx][ny] = step[tmp.x][tmp.y] + 1;
                grid[nx][ny] = &#39;#&#39;;
                que.push(node(nx, ny));
            &#125;
        &#125;
    &#125;
    for (auto&amp; i : End) &#123;
        i.v += step[i.x][i.y];
    &#125;
&#125;
int main() &#123;

    while (cin &gt;&gt; n &gt;&gt; m&amp;&amp;n&gt;=2&amp;&amp;m&gt;=2) &#123;
        string s;
        maze.clear();
        End.clear();
        yifenfi.x = yifenfi.y = 0;
        mercki.x = mercki.y = 0;
        for (int i = 0; i &lt; n; i++) &#123;
            cin &gt;&gt; s;
            for (int j = 0; j &lt; m; j++) &#123;
                if (s[j] == &#39;@&#39;) &#123;
                    End.push_back(node(i, j));
                &#125;
                else if (s[j] == &#39;Y&#39;) &#123;
                    yifenfi.init(i, j);
                &#125;
                else if (s[j] == &#39;M&#39;)
                    mercki.init(i, j);
            &#125;
            maze.push_back(s);
        &#125;
        bfs(yifenfi);
        bfs(mercki);
        int Min = 10000;
        for (auto i : End) &#123;
            if (Min &gt; i.v&amp;&amp;i.v!=0) &#123;
                Min = i.v;
            &#125;
        &#125;
        cout &lt;&lt; Min * 11 &lt;&lt; endl;
    &#125;
    return 0;
&#125;
</code></pre>
<h2 id="hdu1401"><a href="#hdu1401" class="headerlink" title="hdu1401 "></a><a href="https://acm.dingbacode.com/showproblem.php?pid=1401">hdu1401 </a></h2><p>题意为给定一个8 $\times$ 8的棋盘，给定四个棋子的起始坐标和终止坐标，问是否能在8步以内从起始状态到终点状态</p>
<h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p>第一道双向广搜题，棋盘布局问题的一个重点是怎么查重，这就需要将每一步之后的棋盘状态给表示出来，这道题给的是一个8 $\times$ 8的棋盘，一共64个位置，因此整个棋盘的状态可以用一个long long数据来存储，64个bit位上分别可以对应棋盘上一个点是否摆放了棋子，再者还需要存储该状态是第几步得到，为了方便快速取出棋子，需要一个二维数组来存放四颗棋子的状态。中间再使用map来标记哪些状态已经到达，该map能记录每个状态需要多少步到达。</p>
<pre><code class="c++">#include&lt;bits/stdc++.h&gt;
#include&lt;unordered_map&gt;
using namespace std;
typedef unsigned long long ull;
struct maze &#123;
    int chess[4][2];//棋子状态
    ull hash;//每个状态独有的hash值
    bool grid[8][8];//棋盘状态
&#125;Front, Tail;//定义开始棋盘与终点棋盘
int dir1[4][2] = &#123; &#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125; &#125;;
int dir2[4][2] = &#123; &#123;-2,0&#125;,&#123;2,0&#125;,&#123;0,2&#125;,&#123;0,-2&#125; &#125;;//遇到旁边有棋子的移动步数

ull ToHash(maze&amp; m) &#123;
    ull re = 0;
    //将棋盘上每一个点的状态对应到long long 上每一个位
    for (int i = 0; i &lt; 8; i++) &#123;
        for (int j = 0; j &lt; 8; j++) &#123;
            re = re &lt;&lt; 1 | m.grid[i][j];
        &#125;
    &#125;
    return re;
&#125;
int solve(queue&lt;maze&gt;&amp; que, unordered_map&lt;ull, int&gt;&amp; mp1, unordered_map&lt;ull, int&gt;&amp; mp2) &#123;
    //该函数相当于while循环当中的一次que.front()...que.push()...
    maze tmp = que.front();
    que.pop();
    for (int i = 0; i &lt; 4; i++) &#123;
        //第一重遍历，遍历四颗棋子
        int x = tmp.chess[i][0], y = tmp.chess[i][1];
        for (int j = 0; j &lt; 4; j++) &#123;
            //第二重遍历，遍历四个方向
            int nx = x + dir1[j][0];
            int ny = y + dir1[j][1];
            if (nx &gt;= 0 &amp;&amp; nx &lt; 8 &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; 8 &amp;&amp; tmp.grid[nx][ny] == false) &#123;//先尝试移动一步
                maze next = tmp;
                next.grid[nx][ny] = true;
                next.grid[x][y] = false;//下一个状态里面,(x,y)已经变成了false，不用担心走回头路，因为当前棋盘的hash已经记录在map里面了
                next.hash = ToHash(next);
                next.chess[i][0] = nx, next.chess[i][1] = ny;
                if (!mp1.count(next.hash)) &#123;//如果变化后是以前没有的状态
                    mp1[next.hash] = mp1[tmp.hash] + 1;
                    que.push(next);
                    if (mp2.count(next.hash))//如果变化后与终点变过来的某一状态相同，则已经找到答案
                        return mp1[next.hash] + mp2[next.hash];
                &#125;
            &#125;
            else if (nx &gt;= 0 &amp;&amp; nx &lt; 8 &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; 8 &amp;&amp; tmp.grid[nx][ny] == true) &#123;//走一步遇到了棋子
                 nx = x + dir2[j][0];
                 ny = y + dir2[j][1];
                 if (nx &gt;= 0 &amp;&amp; nx &lt; 8 &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; 8 &amp;&amp; tmp.grid[nx][ny] == false) &#123;//尝试走两步，后面代码同上
                     maze next = tmp;
                     next.grid[nx][ny] = true;
                     next.grid[x][y] = false;
                     next.hash = ToHash(next);
                     next.chess[i][0] = nx, next.chess[i][1] = ny;
                     if (!mp1.count(next.hash)) &#123;
                         mp1[next.hash] = mp1[tmp.hash] + 1;
                         que.push(next);
                         if (mp2.count(next.hash))
                             return mp1[next.hash] + mp2[next.hash];
                     &#125;
                 &#125;
            &#125;
        &#125;
    &#125;
    return -1;//四颗棋子遍历完发现都没有return，返回失败标记
&#125;
int bfs() &#123;
    queue&lt;maze&gt; que1, que2;
    que1.push(Front);
    que2.push(Tail);
    unordered_map&lt;ull, int&gt; mp1, mp2;
    mp1[Front.hash] = 0;
    mp2[Tail.hash] = 0;
    //两个队列与map的初始化，que1代表从起始状态遍历，que2从终止状态开始，mp1和mp2分别对应两者出现过的状态
    while (que1.size() &amp;&amp; que2.size()) &#123;
        if (mp1[Front.hash] + mp2[Tail.hash] &gt; 8)//如果两者的步数和已经超过8，返回失败
            return -1;
        int re;
        if (que1.size() &lt;= que2.size()) &#123;//size小的优先，这样就能达到双端遍历的效果
            re = solve(que1, mp1, mp2);
        &#125;
        else
            re = solve(que2, mp2, mp1);
        if (re != -1 &amp;&amp; re &lt;= 8)
            return re;
        if (re &gt; 8)
            return -1;
    &#125;
    return -1;
&#125;
int main()
&#123;
    int x, y;
    while (cin &gt;&gt; x &gt;&gt; y) &#123;
        x--, y--;
        memset(Front.grid, false, sizeof(Front.grid));
        memset(Tail.grid, false , sizeof(Tail.grid));
        Front.grid[x][y] = true;
        Front.chess[0][0] = x, Front.chess[0][1] = y;
        for (int i = 1; i &lt;= 3; i++) &#123;
            cin &gt;&gt; x &gt;&gt; y;
            x--, y--;
            Front.grid[x][y] = true;
            Front.chess[i][0] = x, Front.chess[i][1] = y;
        &#125;
        for (int i = 0; i &lt; 4; i++) &#123;
            cin &gt;&gt; x &gt;&gt; y;
            x--, y--;
            Tail.grid[x][y] = true;
            Tail.chess[i][0] = x, Tail.chess[i][1] = y;
        &#125;
        Front.hash = ToHash(Front);
        Tail.hash = ToHash(Tail);
        if (Front.hash == Tail.hash)
            cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;
        else &#123;
            int re = bfs();
            if (re == -1)
                cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;
            else
                cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<h2 id="hdu1495"><a href="#hdu1495" class="headerlink" title="hdu1495 "></a><a href="https://acm.dingbacode.com/showproblem.php?pid=1495">hdu1495 </a></h2><p>题意是给定三个杯子，第一个被子装满水，通过这三个被子互相倒进倒出能否把水平分</p>
<h3 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3><p>题目的要求是出现一个杯子为空，其它两个杯子装等量的水的情况（我第一次理解成了只要可以两个人喝到相同的水就行了，于是一边倒水一边喝，wa了老久━┳━　━┳━)。搜索的重点就是去记录状态，这道题将三个杯子当前的装水量为一个状态进行搜索，所以开一个三维的vis[s的水量][n的水量][m的水量]bool数组来记录当前状态，每一个状态有6个方向分别是s-&gt;n,s-&gt;m,n-&gt;s,n-&gt;m,m-&gt;s,m-&gt;n(看起来代码长其实很多都是重复操作)</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define MAXN 105
bool vis[MAXN][MAXN][MAXN];
int s, n, m;
struct node &#123;
    int s, n, m, step;
&#125;;
node start;
node re;
int bfs() &#123;
    queue&lt;node&gt; que;
    memset(vis, false, sizeof(vis));
    vis[start.s][start.n][start.m] = true;
    que.push(start);
    while (!que.empty()) &#123;
        node tmp = que.front();
        que.pop();
        if (tmp.s == 0 &amp;&amp; tmp.m == tmp.n || tmp.m == 0 &amp;&amp; tmp.s == tmp.n || tmp.n == 0 &amp;&amp; tmp.s == tmp.m)
        &#123;
            return tmp.step;
        &#125;
        //s--&gt;n
    
        if (tmp.s &amp;&amp; n &gt; tmp.n) &#123;//s有水并且n还没灌满
            node x = tmp;
            if (tmp.s &gt; n - tmp.n) &#123;//s的水比n现在能装的还多
                x.s -= n - tmp.n;
                x.n = n;
                x.step += 1;
                if (!vis[x.s][x.n][x.m]) &#123;
                    que.push(x);
                    vis[x.s][x.n][x.m] = true;
                &#125;
            &#125;
            else &#123;
                x.s = 0;
                x.n += tmp.s;
                x.step += 1;
                if (!vis[x.s][x.n][x.m]) &#123;
                    que.push(x);
                    vis[x.s][x.n][x.m] = true;
                &#125;
            &#125;
        &#125;
        //s--&gt;m
        if (tmp.s &amp;&amp; m &gt; tmp.m) &#123;//s有水并且m还没灌满
            node x = tmp;
            if (tmp.s &gt; m - tmp.m) &#123;//s的水比m现在能装的还多
                x.s -= m - tmp.m;
                x.m = m;
                x.step += 1;
                if (!vis[x.s][x.n][x.m]) &#123;
                    que.push(x);
                    vis[x.s][x.n][x.m] = true;
                &#125;
            &#125;
            else &#123;
                x.s = 0;
                x.m += tmp.s;
                x.step += 1;
                if (!vis[x.s][x.n][x.m]) &#123;
                    que.push(x);
                    vis[x.s][x.n][x.m] = true;
                &#125;
            &#125;
        &#125;
        //n--&gt;s
        if (tmp.n &amp;&amp; s &gt; tmp.s) &#123;//n有水并且s还没灌满
            node x = tmp;
            if (tmp.n &gt; s - tmp.s) &#123;//n的水比s现在能装的还多
                x.n -= s - tmp.s;
                x.s = s;
                x.step += 1;
                if (!vis[x.s][x.n][x.m]) &#123;
                    que.push(x);
                    vis[x.s][x.n][x.m] = true;
                &#125;
            &#125;
            else &#123;
                x.n = 0;
                x.s += tmp.n;
                x.step += 1;
                if (!vis[x.s][x.n][x.m]) &#123;
                    que.push(x);
                    vis[x.s][x.n][x.m] = true;
                &#125;
            &#125;
        &#125;
        //n--&gt;m
        if (tmp.n &amp;&amp; m &gt; tmp.m) &#123;//n有水并且m还没灌满
            node x = tmp;
            if (tmp.n &gt; m - tmp.m) &#123;//n的水比m现在能装的还多
                x.n -= m - tmp.m;
                x.m = m;
                x.step += 1;
                if (!vis[x.s][x.n][x.m]) &#123;
                    que.push(x);
                    vis[x.s][x.n][x.m] = true;
                &#125;
            &#125;
            else &#123;
                x.n = 0;
                x.m += tmp.n;
                x.step += 1;
                if (!vis[x.s][x.n][x.m]) &#123;
                    que.push(x);
                    vis[x.s][x.n][x.m] = true;
                &#125;
            &#125;
        &#125;
        //m--&gt;n
        if (tmp.m &amp;&amp; n &gt; tmp.n) &#123;//n有水并且n还没灌满
            node x = tmp;
            if (tmp.m &gt; n - tmp.n) &#123;//m的水比n现在能装的还多
                x.m -= n - tmp.n;
                x.n = n;
                x.step += 1;
                if (!vis[x.s][x.n][x.m]) &#123;
                    que.push(x);
                    vis[x.s][x.n][x.m] = true;
                &#125;
            &#125;
            else &#123;
                x.m = 0;
                x.n += tmp.m;
                x.step += 1;
                if (!vis[x.s][x.n][x.m]) &#123;
                    que.push(x);
                    vis[x.s][x.n][x.m] = true;
                &#125;
            &#125;
        &#125;
        //m--&gt;s
        if (tmp.m &amp;&amp; s &gt; tmp.s) &#123;//m有水并且s还没灌满
            node x = tmp;
            if (tmp.m &gt; s - tmp.s) &#123;//m的水比s现在能装的还多
                x.m -= s - tmp.s;
                x.s = s;
                x.step += 1;
                if (!vis[x.s][x.n][x.m]) &#123;
                    que.push(x);
                    vis[x.s][x.n][x.m] = true;
                &#125;
            &#125;
            else &#123;
                x.m = 0;
                x.s += tmp.m;
                x.step += 1;
                if (!vis[x.s][x.n][x.m]) &#123;
                    que.push(x);
                    vis[x.s][x.n][x.m] = true;
                &#125;
            &#125;
        &#125;
    &#125;
    return 0;
&#125;
int main()
&#123;
    while (cin &gt;&gt; s &gt;&gt; n &gt;&gt; m) &#123;
        if (s == n &amp;&amp; n == m &amp;&amp; s == 0)
            break;
        start.s = s, start.n = 0, start.m = 0;
        start.step = 0;
        if (s &amp; 1) &#123;
            cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;
        &#125;
        else &#123;
            int re = bfs();
            if (re) &#123;
                cout &lt;&lt; re &lt;&lt; endl;
            &#125;
            else
                cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<p><a href="http://poj.org/problem?id=3126">POJ3126 – Prime Path</a></p>
<p><em>2021.7.19</em></p>
<p>题意是给定一个起始的四位的素数和目标四位的素数，每一步可以变动一个位置上的数字，要求变动之后数字还是素数，且还是要四位数，求最少步数。</p>
<h3 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h3><p>最近做这个专题发现基本上都是问最少步数，也基本上都是bfs,这道题的状态可以直接由一个数字本身确定，由于范围较小，可以提前将所有的四位素数计算出来，方便后面判断。代码如下</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;queue&gt;
#include&lt;map&gt;
using namespace std;
bool prime[100000];//判断素数

int main()
&#123;
    for (int i = 2; i &lt; 100000; i++) &#123;
        if (!prime[i]) &#123;
            for (int j = 2; j * i &lt; 100000; j++) &#123;
                prime[i * j] = true;
            &#125;
        &#125;
    &#125;//埃氏筛
    
    int t, a, b;
    cin &gt;&gt; t;
    bool flag = false;
    while (t--) &#123;
        cin &gt;&gt; a &gt;&gt; b;
        queue&lt;int&gt;que;
        map&lt;int, int&gt; mp;//bfs的标记数组，mp[1000]=1表示1000y
        mp[a] = 0;
        que.push(a);
        while (!que.empty()) &#123;
            int tmp = que.front();
            que.pop();
            if (tmp == b) &#123;
                flag = true;
                break;
            &#125;
            //下面四个for循环分别对应修改四个位置上的数字
            for (int i = 0; i &lt; 10; i++) &#123;
                int num = tmp % 1000 + i * 1000;
                if (!prime[num] &amp;&amp; mp.count(num) == 0&amp;&amp;num&gt;1000) &#123;
                    mp[num] = mp[tmp] + 1;
                    que.push(num);
                &#125;
            &#125;
            for (int i = 0; i &lt; 10; i++) &#123;
                int num = tmp - ((tmp / 100) % 10) * 100 + i * 100;
                if (!prime[num] &amp;&amp; mp.count(num) == 0&amp;&amp;num&gt;1000) &#123;
                    mp[num] = mp[tmp] + 1;
                    que.push(num);
                &#125;
            &#125;
            for (int i = 0; i &lt; 10; i++) &#123;
                int num = tmp - ((tmp / 10) % 10) * 10 + i * 10;
                if (!prime[num] &amp;&amp; mp.count(num) == 0&amp;&amp;num&gt;1000) &#123;
                    mp[num] = mp[tmp] + 1;
                    que.push(num);
                &#125;
            &#125;
            for (int i = 0; i &lt; 10; i++) &#123;
                int num = tmp -(tmp%10) + i;
                if (!prime[num] &amp;&amp; mp.count(num) == 0&amp;&amp;num&gt;1000) &#123;
                    mp[num] = mp[tmp] + 1;
                    que.push(num);
                &#125;
            &#125;
        &#125;
        if (flag)
            cout &lt;&lt; mp[b]&lt;&lt;endl;
        else
            cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;
        

    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows编程</title>
    <url>/2022/04/04/Windows%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="键盘与鼠标"><a href="#键盘与鼠标" class="headerlink" title="键盘与鼠标"></a>键盘与鼠标</h4><ul>
<li>WM_KEYDOWN中不区分大小写，字母的虚拟键码分别为’A’~’Z’对应的ascill码，如果要在这里判断是否CTRL，使用GetKeyState(VK_CONTROL)判断其值是否小于0即可，当按下的键可以产生一个可见字符时会发送一个WM_CHAR的消息，所以WM_KEYDOWN是先于WM_CHAR的</li>
<li>WM_CHAR中区分大小写,如果是CTRL+字符发送过来的wParam等于字母对应字母表的位置,CTRL+’A’以及CTRL+’a’为1，以此类推</li>
<li>Ctrl+鼠标左击的判断通过&amp;方式判断,如在WM_LBUTTONDOWN中判断是否按下Ctrl可以通过(wParam &amp; MK_CONTROL)判断</li>
<li>在鼠标移动过程中判断左键是否按下，(wParam &amp; MK_LBUTTON)</li>
</ul>
<h4 id="资源在Windows中的应用"><a href="#资源在Windows中的应用" class="headerlink" title="资源在Windows中的应用"></a>资源在Windows中的应用</h4><blockquote>
<p>由于这篇文章主要供自己在学习过程当中偶尔查阅使用，因此不展开对资源的代码生成，只是简单地记下一些使用方式</p>
</blockquote>
<ul>
<li>菜单资源:<br>1.窗口主菜单<br>2.菜单项(包含加速键标识于热键标识)<br>3.分隔符<br>手动的定义方式如下:</li>
</ul>
<pre><code class="cpp">#include&quot;Menu.h&quot;
My_menu MENU MOVEABLE         //My_menu是资源名字,用于载入菜单资源时使用,MENU是关键字，MOVEALBE是一种模式
｛POPUP &quot;文件（&amp;F）&quot;            //POPUP是说定义一个弹出式菜单 后面就是要显示的文字,&amp;符号后面的文字显示出来会有下划线
 ｛      MENUITEM     &quot;新建（&amp;N）&quot;，    IDM_NEW             MENUITEM     &quot;打开（&amp;O）&quot;，    IDM_OPEN
         MENUITEM     &quot;关闭（&amp;C）&quot;，    IDM_CLOSE
         MENUITEM     &quot;保存（&amp;S）&quot;，    IDM_SAVE
         MENUITEM     &quot;另存为（&amp;A）&quot;，    IDM_SAVEAS
         MENUITEM     SEPARATOR              //分隔符
        MENUITEM    “退出（&amp;X）”，    IDM_EXIT
        //IDM_NEW,IDM_CLOSE,...是在Menu.h里自己定义好的宏，是一个1~65535的整数，用以唯一标识一个菜单项
  ｝
｝
</code></pre>
<p>资源编辑器定义:<br>在VS里面可以点开资源文件，点开.rc文件，找到Menu点开里面的那个文件后就有一个GUI式的编写界面，按照提示编写即可，需要注意的是创建一个新的菜单项时如果想自定义它的ID对应的宏名字，可以点开旁边的属性，然后在ID那里输入想要的名字，VS会自动生成一个相应的宏,但要注意不要与已有的名字冲突</p>
<p><em>菜单的加载</em><br>1.创建窗口时加载</p>
<pre><code class="cpp">HMENU hMenu = LoadMenu(hInstance,MAKEINTERSOURCE(菜单ID))
//MAKEINTERSOURCE的作用跟一个数字转字符串的函数差不多
CreateWindow(...,hMenu,...);
</code></pre>
<p>2.动态加载</p>
<pre><code class="cpp">HMENU hMenu = LoadMenu(...);
SetMenu(hWnd,hMenu);
</code></pre>
<p><strong>与菜单项有关的一些函数</strong></p>
<pre><code class="cpp">//1．禁止或激活菜单项 
BOOL EnableMenuItem
(HMENU hmenu,
 UlNT wIDEnableItem,//被禁止或激活的菜单项标识
 UINT dwEnable
)
/*下面的一些宏是第三个参数*/
// MF_BYCOMMAND以ID值标识菜单项
// MF_ENABLED    激活菜单项
// MF_BYPOSITION    表明以位置标识菜单项
// MF_GRAYED    禁止菜单项并使其变灰显示
// MF_DISABLED    禁止菜单项

//2. 选中
DWORD CheckMenuItem
(
HMENU hmenu,    
UINT wIDCheckItem,    //菜单项标识
UINT dwCheck            //操作标识MF_CHECKED和MF_UNCHECKED
) 

//3.增加菜单项 
//末尾添加
BOOL AppendMenu
( HMENU hmenu,
  UINT dwFlags,        // 新加入的菜单项类型标识
  UINT dwIDNewItem,    // 新加入菜单项的ID
  LPCTSTR lpNewItem    // 新加入的菜单项内容
) 
AppendMenu (hmenu, MF_ENABLED,IDM_ABOUT, &quot;关于(&amp;A)&quot;)
//插入
BOOL InsertMenu
(HMENU hmenu,         //菜单句柄
UINT wPosition,    //指定新菜单项插入的位置
UINT dwFlag,         //新加入的菜单项的信息
UINT dwIDNweItem,    //新加入的菜单项的标识
LPCTSTR lpNewItem    //新插入的菜单项的内容
) 
InsertMenu (hmenu,IDM_EXIT,
MF_BYCOMMAND|MF_ENABLED,
IDM_PRINT,&quot;打印（&amp;P）&quot;);
/*还可以通过位置来插入,第二个参数为位置,第三个参数变为MF_BYPOSITION | MF_ENABLED*/

//4 删除菜单项
 BOOL DeleteMenu
(
HMENU hmenu,
UINT wPosition, //要删除的菜单项的位置
UINT dwFlag      //对wPosition的解释,使用方式与InsertMenu类似,
  )  
</code></pre>
]]></content>
      <tags>
        <tag>专业学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Test</title>
    <url>/2022/04/25/Test/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习</title>
    <url>/2022/07/04/git%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>参考：<a href="https://zhuanlan.zhihu.com/p/356166493">https://zhuanlan.zhihu.com/p/356166493</a></p>
<p><strong>Git是一个分布式版本控制器，所以安装之后要配置自己的邮箱和用户名</strong><br><code>git config --global user.name &quot;...&quot;</code><br><code>git config --global user.email &quot;...&quot;</code></p>
<h4 id="三个区：工作区，版本区，暂存区"><a href="#三个区：工作区，版本区，暂存区" class="headerlink" title="三个区：工作区，版本区，暂存区"></a>三个区：工作区，版本区，暂存区</h4><ul>
<li>工作区：简单地理解为当前电脑上看到的情况</li>
<li>暂存区：介于版本与工作之间</li>
<li>版本库：工作区有一个隐藏目录.git，这是版本库</li>
</ul>
<p><code>git add ...</code>把文件放进暂存区<br><code>git commit ...</code>把暂存区内容提交到版本库</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h5><p><code>git init</code>会创建出一个.git文件夹，有默认的一些配置，不要修改<br><code>git add</code>与<code>git commit</code>前面已经说过<br><code>git status</code>查看状态，红色表示在工作区，绿色表示在暂存区，没有表示在版本库<br><em>git commit一定需要一个跟当前版本有关的文本信息才会提交成功,直接git commit会失败，常用的形式:</em><br><code>git commit -m &#39;....&#39;</code>表示将暂存区所有文件提交到版本库，并且附带信息’….’</p>
<h4 id="差异对比"><a href="#差异对比" class="headerlink" title="差异对比"></a>差异对比</h4><p><code>git diff</code> 比较暂存区与工作区<br><code>git diff -cached</code> 版本区与暂存区<br><code>git diff master</code> 版本去与工作区</p>
<h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p><code>git log</code>打印所有日志<br><code>git reflog</code>显示所有提交的id</p>
<h4 id="版本回退与穿梭"><a href="#版本回退与穿梭" class="headerlink" title="版本回退与穿梭"></a>版本回退与穿梭</h4><p><code>git reset --hard HEAD^</code>回退一次提交，两次就打两个^,三次就三个^,…，想要回退1000个版本或指定数量的话用<code>git reset --hard HEAD~1000</code>的形式<br><code>git reset --hard id</code>回退到指定id的版本<br><code>git reset HEAD</code>用版本库文件替换所有暂存区的文件<br><code>git checkout -- x.txt</code>用暂存区的指定文件区替换工作区的文件<br><code>git checkout HEAD x.txt</code>用版本库中的文件去替换暂存和工作区的文件</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/07/18/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>数字图像处理-图像增强</title>
    <url>/2022/04/23/%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/</url>
    <content><![CDATA[<h3 id="图像增强"><a href="#图像增强" class="headerlink" title="图像增强"></a>图像增强</h3><h4 id="空间域图像处理"><a href="#空间域图像处理" class="headerlink" title="空间域图像处理"></a>空间域图像处理</h4><pre><code class="python"># 平滑处理
import cv2
import matplotlib.pyplot as plt

</code></pre>
<pre><code class="python"># 边缘处理

</code></pre>
<pre><code class="python">
</code></pre>
<h4 id="图像直方图均衡化处理"><a href="#图像直方图均衡化处理" class="headerlink" title="图像直方图均衡化处理"></a>图像直方图均衡化处理</h4><pre><code class="python">import cv2
import matplotlib.pyplot as plt

im = cv2.imread(&#39;../TestFigs/lenna.jpg&#39;)
b,g,r = cv2.split(im)
#均衡化
eb = cv2.equalizeHist(b)

#计算直方图
hist = cv2.calcHist([b],[0],None,[64],[0,256])
ehist = cv2.calcHist([eb],[0],None,[64],[0,256])
#画图
fig,ax = plt.subplots(2,2)
ax[0,0].set_title(&#39;orignHist&#39;)
ax[0,0].plot(hist)

ax[0,1].set_title(&#39;equalHist&#39;)
ax[0,1].plot(ehist)

ax[1,0].set_title(&#39;orign&#39;)
ax[1,0].imshow(b,&#39;gray&#39;)

ax[1,1].set_title(&#39;equaled&#39;)
ax[1,1].imshow(eb,&#39;gray&#39;)
plt.show()
</code></pre>
<p><img src="https://s2.loli.net/2022/04/07/PApihE4O7eWayzZ.png" alt="图像增强_6_0.png"></p>
<pre><code class="python">
</code></pre>
]]></content>
      <tags>
        <tag>专业学习</tag>
      </tags>
  </entry>
  <entry>
    <title>大话设计模式</title>
    <url>/2022/04/24/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><blockquote>
<p>这个模式与面向对象相关,通过面向对象的三大特征来使得程序达到可复用,易修改,易扩展的效果</p>
</blockquote>
<p>本模式以写一个计算器功能,要求根据用户的输入输出相应的结果<br>如果没有使用任何模式代码可能如下</p>
<pre><code class="cpp">int main()
&#123;
    try&#123;
        std::cout&lt;&lt;&quot;请输入数字A:\n&quot;;
        double a;
        std::cin&gt;&gt;a;
        std::cout&lt;&lt;&quot;请输入运算符号+,-,*,/:\n&quot;;
        char opt;
        std::cin&gt;&gt;opt;
        //下面再类似地读入B
        switch(opt)
        &#123;
            case &#39;*&#39;:
            //操作
            break;
            case &#39;/&#39;:
            //操作,注意除法需要自己判断除数是否为0,try catch不捕捉除零错误
            break;
            //类似的
        &#125;
    &#125;catch(...)&#123;
        std::cout&lt;&lt;&quot;您的输入有误\n&quot;;
    &#125;
    return 0;
&#125;
</code></pre>
<p>上面的代码想要复用就必须拷贝粘贴代码,如果有多个地方要使用那多个地方就会出现重复的代码,这是在编码时应该避免的。下面通过面向的封装特性将该功能进行封装,使得其<strong>复用性</strong>大大提高</p>
<pre><code class="cpp">class Operation&#123;
    public:
    static double GetResult(double numA,double numB,string operate)&#123;
        double result = 0;
        switch(operate)&#123;
            case:
            //实现相应功能
        &#125;
        return result;
    &#125;
&#125;;
</code></pre>
<p>将计算这个功能给封装起来,数据的读入和检查由客户完成,这样这个代码的复用性就大大提高了,不单是现在这个程序可以用它,只要是需要通过输入得到结果的地方都可以使用</p>
<p>但是如果此时想要给这个功能添加一些新的计算如开根求幂等,就需要去修改switch case的结构,一方面需要将所有运算的源码交给修改人员,这不安全可能会破坏其它的运算,另一方面这样的修改会使得原来已有的运算重新编译,这是不合理的.说白了这里需要解开各个运算之间的编译<strong>耦合</strong><br>下面是利用继承的方式修改的代码</p>
<pre><code class="cpp">class Operation&#123;
    protected:
    double numA_;
    double numB_;
    public:
    void SetA(double val);
    double GetA()const;
    //numB_类似有get与set
    virtual double GetResult()&#123;
        double ans=0;
        return ans;
    &#125;
&#125;;
class OperationAdd:public Operation&#123;
    public:
    virtual double GetResult()&#123;
        return numA_ + numB_;
    &#125;   
&#125;;

class OperationDiv:public Operation&#123;
    public:
    virtual double GetResult()override &#123;
        if(numB_ == 0 )
            throw Error;
        return numA_ / numB_;
    &#125;
&#125;;
//原先其它运算符类似
class OperationSqrt:public Opearation&#123;
    if (numA_ &lt;0)
        throw Error;
    return sqrt(numA_);
&#125;;
</code></pre>
<p>这样既增加了安全性又提高了扩展性,现在的问题就是客户必须要知道自己的运算需要调用什么样的类,但如果程序很大,对客户来说去众多类里面找到自己想要的类是很不方便的,利用<strong>多态的性质</strong>将这个任务交给一个特定的类去完成,这个类即工厂</p>
<pre><code class="cpp">class OperationFactory&#123;
    public:
    static Operation* createOperate(char operate)&#123;
        Operation* opt = nullptr;
        switch(operate)&#123;
            case &#39;*&#39;:
            opt = new OperationMul();
            break;
            case &#39;+&#39;:
            opt = new OperationAdd();
            break;
            //...
        &#125;
        return opt;
    &#125;
&#125;;
//客户端的代码
Operation *opt;
opt = OperationFactory::createOperate(&#39;+&#39;);
opt-&gt;setA(10);
opt-&gt;setB(20);
double result = opt-&gt;GetResult();
</code></pre>
<h3 id="策略模式-Stretagy"><a href="#策略模式-Stretagy" class="headerlink" title="策略模式(Stretagy)"></a>策略模式(Stretagy)</h3><h3 id="单一职责原则-SRP"><a href="#单一职责原则-SRP" class="headerlink" title="单一职责原则(SRP)"></a>单一职责原则(SRP)</h3><blockquote>
<p>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会影响到其它职责的实现，这种耦合会导致脆弱的设计</p>
</blockquote>
<h3 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h3><blockquote>
<p>对修改关闭,对扩展开放</p>
</blockquote>
<h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><blockquote>
<p>抽象不应该依赖底层模块,两个都应该依赖抽象。抽象不应该依赖细节，细节应该依赖于抽象。<br>简单地说就是应该针对接口编程而不是针对实现编程</p>
</blockquote>
<p>假设在做一个大项目时需要访问数据库，常用代码会写成函数库，在上层模块中调用这些函数即可，这里就是上层模块对底层模块的依赖。但如果上层的逻辑没有变化但需要换掉访问的数据库，那就出现问题了，因为上层模块与底层是绑在一起的。</p>
<p>再举一个例子就是主机,CPU，内存，硬盘都是根据接口标准制造的，如果说它们根据主板实现那主板一坏其它部件都不能使用了<br>@startuml<br>(登录论坛)<br>(发帖子) as (tiezi_add)<br>usecase 删帖子 as tiezi_del<br>@enduml</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>数字图像处理</title>
    <url>/2022/04/06/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3 id="图像增强"><a href="#图像增强" class="headerlink" title="图像增强"></a>图像增强</h3><h4 id="空间域图像处理"><a href="#空间域图像处理" class="headerlink" title="空间域图像处理"></a>空间域图像处理</h4><pre><code class="python"># 平滑处理
import cv2
import matplotlib.pyplot as plt

</code></pre>
<pre><code class="python"># 边缘处理

</code></pre>
<pre><code class="python">
</code></pre>
<h4 id="图像直方图均衡化处理"><a href="#图像直方图均衡化处理" class="headerlink" title="图像直方图均衡化处理"></a>图像直方图均衡化处理</h4><pre><code class="python">import cv2
import matplotlib.pyplot as plt

im = cv2.imread(&#39;../TestFigs/lenna.jpg&#39;)
b,g,r = cv2.split(im)
#均衡化
eb = cv2.equalizeHist(b)

#计算直方图
hist = cv2.calcHist([b],[0],None,[64],[0,256])
ehist = cv2.calcHist([eb],[0],None,[64],[0,256])
#画图
fig,ax = plt.subplots(2,2)
ax[0,0].set_title(&#39;orignHist&#39;)
ax[0,0].plot(hist)

ax[0,1].set_title(&#39;equalHist&#39;)
ax[0,1].plot(ehist)

ax[1,0].set_title(&#39;orign&#39;)
ax[1,0].imshow(b,&#39;gray&#39;)

ax[1,1].set_title(&#39;equaled&#39;)
ax[1,1].imshow(eb,&#39;gray&#39;)
plt.show()
</code></pre>
<p><img src="https://s2.loli.net/2022/04/07/PApihE4O7eWayzZ.png" alt="图像增强_6_0.png">    </p>
<pre><code class="python">
</code></pre>
]]></content>
  </entry>
</search>
